# Design

- We can in principle add quantities with the same dimension (`m [L] + ft [L]`)
- Note that dimensions cannot be determined by exponents: `ft^2` is an area, but so is `acre^1`.
- To avoid overflow issues and general ugliness, we should keep prefixes with units (e.g. `nm` or `km`).

# Implementation

## A view from 30000 feet
#### (or 9144 meters)

Like SIUnits.jl, units are part of the type signature of a quantity. From there,
the implementations diverge. Unitful.jl uses generated functions to enable more
flexibility than found in SIUnits.jl. Support is targeted to Julia 0.5+
because of some limitations in how `promote_op` is used in Julia 0.4. See
[issue #13803](https://github.com/julialang/Julia/issues/13803).

We make an immutable `UnitDatum` that stores a base unit (expressed a bits type
generated by an `@enum`), a rational exponent, and a prefix. We don't allow
arbitrary floating point exponents of units because they probably aren't very useful.

We define the immutable singleton `UnitData{T}`, where `T` is always a tuple
of `UnitDatum` (variable number of arguments). Usually, the user interacts
only with `UnitData{T}` objects, not `UnitDatum`.

We define methods `dimension` that turn, for example, `acre^2` into `[L]^4`.

We define unitful quantities `Quantity{T<:Real, Units}` where `Units` is
a type `UnitData{T}`. In this way, staged functions can be used to offload
as much of the unit computation to compile-time as is possible.

## Discussion

- If there is a need for complex numbers to have units, please implement that
and submit a PR, adding tests where appropriate.

- [SIUnits issue 18](https://github.com/Keno/SIUnits.jl/issues/18): Some discussion
regarding how to define `one(x)` and `zero(x)` for quantities with units. Right now
`one(x)` returns no units, but `zero(x)` returns units. This is consistent with
Julia documentation; `one(x)` should be multiplicative identity and `zero(x)`
should be additive identity.

## Potential improvements to Base

In writing this package I’ve noticed a few places where changes to Base could be helpful. I keep redefinitions of methods found in Base in `Redefinitions.jl`. If I receive some encouraging feedback from a Julia contributor, maybe I’ll submit a PR. In the meantime, try not to be annoyed by the redefinition warnings.

To give a flavor of the kind of changes I suggest, here is an example.
According to the documentation, `one(x)` is supposed to be the multiplicative identity for the type of x. There are several places in `base/range.jl`, for example, where `one(x)` is being used instead of `oftype(x,1)`. This distinction could be important for types with units:
`(1m) * one(1m) == 1m`, but `1m+oftype(1m, 1) == 2m`, and `1m+one(1m)` is invalid
since we cannot add unitful and unitless quantities.

## To do

- `LinSpace` does not work yet

- Conversion between units is always multiplicative, therefore handling
degrees Fahrenheit and degrees Celsius is problematic.

- How to handle cases where there is an exact conversion between two
non-SI units? Right now if we convert 12 inches to feet there is an epsilon
error from some floating-point math.

  - `basefactor(x::UnitDatum)`: right now there is an explicit floating point
  conversion because of the 10^x.
