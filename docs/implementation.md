# Implementation

## A view from 30000 feet
#### (or 9144 meters)

We make an immutable `UnitDatum` that stores a base unit (expressed a bits type
generated by an `@enum`), a rational exponent, and a prefix. We don't allow
arbitrary floating point exponents of units because they probably aren't very useful.

We define the immutable singleton `UnitData{T}`, where `T` is always a tuple
of `UnitDatum` (variable number of arguments). Usually, the user interacts
only with `UnitData{T}` objects, not `UnitDatum`.

We define methods `dimension` that turn, for example, `acre^2` into `[L]^4`.

We define unitful quantities `Quantity{T<:Real, Units}` where `Units` is
a type `UnitData{T}`. In this way, staged functions can be used to offload
as much of the unit computation to compile-time as is possible.

## Discussion

- If there is a need for complex numbers to have units, please implement that
and submit a PR, adding tests where appropriate.

- [SIUnits issue 18](https://github.com/Keno/SIUnits.jl/issues/18): Some discussion
regarding how to define `one(x)` and `zero(x)` for quantities with units. Right now
I have it returning units. The problem is that we would all want `one(x)` to behave
differently depending on if we are adding one or requesting multiplicative identity.
I override some of range.jl in this package and in doing so find that the former
is more useful, for my purposes anyway.

## To do

- Conversion between units is always multiplicative, therefore handling
degrees Fahrenheit and degrees Celsius is problematic.

- How to handle cases where there is an exact conversion between two
non-SI units? Right now if we convert 12 inches to feet there is an epsilon
error from some floating-point math.
