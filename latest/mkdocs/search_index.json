{
    "docs": [
        {
            "location": "/", 
            "text": "Unitful.jl\n\n\nA Julia package for physical units. Available \nhere\n. Inspired by:\n\n\n\n\nSIUnits.jl\n\n\nEngUnits.jl\n\n\nUnits.jl\n\n\n\n\nWe want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.\n\n\n\n\nNote\n\n\nIf you have been previously using Unitful 0.0.4 or earlier, the defaults mechanism has been completely rewritten. This means you will now need to define new units in your \n.juliarc.jl\n file or in a new module. See \nDefining new units\n and \nExtending Unitful\n for details. Additionally, to specify custom rules for promotion, see \nPromotion mechanisms\n.\n\n\n\n\n\n\nQuick start\n\n\n\n\nThis package requires Julia 0.5. Older versions will not be supported.\n\n\nPkg.add(\"Unitful\")\n\n\nusing Unitful\n\n\n\n\nUnitful aims for generality, but has some useful functionality out of the box.\n\n\n\n\nBase dimensions like length, mass, time, etc. are defined.\n\n\nDerived dimensions like volume, energy, momentum, etc. are defined.\n\n\nBase and derived SI units with their power-of-ten prefixes are defined.\n\n\nSome other common units are defined, without power-of-ten prefixes.\n\n\nSensible default promotion behavior is specified.\n\n\n\n\nTake a look at \nsrc/pkgdefaults.jl\n for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:\n\n\n\n\ninch\n is used instead of \nin\n, since \nin\n conflicts with Julia syntax\n\n\nminute\n is used instead of \nmin\n, since \nmin\n is a commonly used function\n\n\nhr\n is used instead of \nh\n, since \nh\n is revered as the Planck constant\n\n\n\n\n\n\nImportant note on namespaces\n\n\nUnits, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:\n\n\n\n\nUse the \n@u_str\n string macro.\n\n\nExplicitly import from the \nUnitful\n package to bring specific symbols into the calling namespace.\n\n\n\n\nusing Unitful.DefaultSymbols\n will bring the following symbols into the calling namespace:\n\n\n\n\nDimensions \n\ud835\udc0b,\ud835\udc0c,\ud835\udc13,\ud835\udc08,\ud835\udeaf,\ud835\udc09,\ud835\udc0d\n for length, mass, time, current, temperature,\n\n\n\n\nluminosity, and amount, respectively.\n\n\n\n\nBase and derived SI units, with SI prefixes.\n\n\n\u00b0\n (degrees)\n\n\n\n\n\n\n\n\nIf you have been using the \nSIUnits.jl\n   package, this is not unlike typing \nusing SIUnits.ShortUnits\n with that package.\n\n\n\n\nUsage examples\n\n\njulia\n 1u\nkg\n == 1000u\ng\n             # Equivalence implies unit conversion\ntrue\n\njulia\n !(1u\nkg\n === 1000u\ng\n)         # ...and yet we can distinguish these...\ntrue\n\njulia\n 1u\nkg\n === 1u\nkg\n              # ...and these are indistinguishable.\ntrue\n\n\n\n\nIn the next examples we assume we have brought some units into our namespace, e.g. using \nm = u\"m\"\n, etc.\n\n\njulia\n uconvert(\u00b0C, 212\u00b0F)\n100//1 \u00b0C\n\njulia\n uconvert(\u03bcm/(m*\u00b0F), 9\u03bcm/(m*\u00b0C))\n5//1 \u00b0F^-1 \u03bcm m^-1\n\njulia\n mod(1hr+3minute+5s, 24s)\n17//1 s\n\n\n\n\nSee \ntest/runtests.jl\n for more usage examples.", 
            "title": "Home"
        }, 
        {
            "location": "/#unitfuljl", 
            "text": "A Julia package for physical units. Available  here . Inspired by:   SIUnits.jl  EngUnits.jl  Units.jl   We want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.   Note  If you have been previously using Unitful 0.0.4 or earlier, the defaults mechanism has been completely rewritten. This means you will now need to define new units in your  .juliarc.jl  file or in a new module. See  Defining new units  and  Extending Unitful  for details. Additionally, to specify custom rules for promotion, see  Promotion mechanisms .", 
            "title": "Unitful.jl"
        }, 
        {
            "location": "/#quick-start", 
            "text": "This package requires Julia 0.5. Older versions will not be supported.  Pkg.add(\"Unitful\")  using Unitful   Unitful aims for generality, but has some useful functionality out of the box.   Base dimensions like length, mass, time, etc. are defined.  Derived dimensions like volume, energy, momentum, etc. are defined.  Base and derived SI units with their power-of-ten prefixes are defined.  Some other common units are defined, without power-of-ten prefixes.  Sensible default promotion behavior is specified.   Take a look at  src/pkgdefaults.jl  for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:   inch  is used instead of  in , since  in  conflicts with Julia syntax  minute  is used instead of  min , since  min  is a commonly used function  hr  is used instead of  h , since  h  is revered as the Planck constant", 
            "title": "Quick start"
        }, 
        {
            "location": "/#important-note-on-namespaces", 
            "text": "Units, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:   Use the  @u_str  string macro.  Explicitly import from the  Unitful  package to bring specific symbols into the calling namespace.   using Unitful.DefaultSymbols  will bring the following symbols into the calling namespace:   Dimensions  \ud835\udc0b,\ud835\udc0c,\ud835\udc13,\ud835\udc08,\ud835\udeaf,\ud835\udc09,\ud835\udc0d  for length, mass, time, current, temperature,   luminosity, and amount, respectively.   Base and derived SI units, with SI prefixes.  \u00b0  (degrees)     If you have been using the  SIUnits.jl    package, this is not unlike typing  using SIUnits.ShortUnits  with that package.", 
            "title": "Important note on namespaces"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "julia  1u kg  == 1000u g              # Equivalence implies unit conversion\ntrue\n\njulia  !(1u kg  === 1000u g )         # ...and yet we can distinguish these...\ntrue\n\njulia  1u kg  === 1u kg               # ...and these are indistinguishable.\ntrue  In the next examples we assume we have brought some units into our namespace, e.g. using  m = u\"m\" , etc.  julia  uconvert(\u00b0C, 212\u00b0F)\n100//1 \u00b0C\n\njulia  uconvert(\u03bcm/(m*\u00b0F), 9\u03bcm/(m*\u00b0C))\n5//1 \u00b0F^-1 \u03bcm m^-1\n\njulia  mod(1hr+3minute+5s, 24s)\n17//1 s  See  test/runtests.jl  for more usage examples.", 
            "title": "Usage examples"
        }, 
        {
            "location": "/highlights/", 
            "text": "Dispatch on dimensions\n\n\nConsider the following toy example, converting from voltage or power ratios to decibels:\n\n\njulia\n dB(num::Unitful.Voltage, den::Unitful.Voltage) = 20*log10(num/den)\n dB (generic function with 1 method)\n\njulia\n dB(num::Unitful.Power, den::Unitful.Power) = 10*log10(num/den)\n dB (generic function with 2 methods)\n\njulia\n dB(1u\nmV\n, 1u\nV\n)\n-60.0\n\njulia\n dB(1u\nmW\n, 1u\nW\n)\n-30.0\n\n\n\n\nWe don't currently implement dB as a unit because the log scale would require special treatment, but it is under consideration.\n\n\n\n\nDimensions in a type definition\n\n\nIt may be tempting to specify the dimensions of a quantity in a type definition, e.g.\n\n\ntype Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend\n\n\n\n\nHowever, these are abstract types. If performance is important, it may be better just to pick a concrete \nQuantity\n type:\n\n\ntype Person\n    height::typeof(1.0u\nm\n)\n    mass::typeof(1.0u\nkg\n)\nend\n\n\n\n\nYou can still create a \nPerson\n as \nPerson(5u\"ft\"+10u\"inch\", 75u\"kg\")\n; the unit conversion happens automatically.\n\n\n\n\nMaking new units and dimensions\n\n\nYou can make new units using the \n@unit\n macro on the fly:\n\n\njulia\n @unit c \nc\n SpeedOfLight 299792458u\nm/s\n false\nc\n\n\n\n\n\n\nArrays\n\n\nPromotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from \n[1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"]\n). However, it could be useful in toy calculations for \ngeneral relativity\n where some conventions yield matrices with mixed dimensions:\n\n\njulia\n @unit c \nc\n SpeedOfLight 299792458u\nm/s\n false\nc\n\njulia\n Diagonal([-1.0c^2, 1.0, 1.0, 1.0])\n4\u00d74 Diagonal{Unitful.Quantity{Float64,D,U}}:\n -1.0 c^2   \u22c5    \u22c5    \u22c5\n       \u22c5   1.0   \u22c5    \u22c5\n       \u22c5    \u22c5   1.0   \u22c5\n       \u22c5    \u22c5    \u22c5   1.0\n\n\n\n\n\n\nUnits with rational exponents\n\n\njulia\n 1.0u\nV/sqrt(Hz)\n\n1.0 Hz^-1/2 V\n\n\n\n\n\n\nExact conversions respected\n\n\njulia\n uconvert(u\nft\n,1u\ninch\n)\n1//12 ft", 
            "title": "Highlighted features"
        }, 
        {
            "location": "/highlights/#dispatch-on-dimensions", 
            "text": "Consider the following toy example, converting from voltage or power ratios to decibels:  julia  dB(num::Unitful.Voltage, den::Unitful.Voltage) = 20*log10(num/den)\n dB (generic function with 1 method)\n\njulia  dB(num::Unitful.Power, den::Unitful.Power) = 10*log10(num/den)\n dB (generic function with 2 methods)\n\njulia  dB(1u mV , 1u V )\n-60.0\n\njulia  dB(1u mW , 1u W )\n-30.0  We don't currently implement dB as a unit because the log scale would require special treatment, but it is under consideration.", 
            "title": "Dispatch on dimensions"
        }, 
        {
            "location": "/highlights/#dimensions-in-a-type-definition", 
            "text": "It may be tempting to specify the dimensions of a quantity in a type definition, e.g.  type Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend  However, these are abstract types. If performance is important, it may be better just to pick a concrete  Quantity  type:  type Person\n    height::typeof(1.0u m )\n    mass::typeof(1.0u kg )\nend  You can still create a  Person  as  Person(5u\"ft\"+10u\"inch\", 75u\"kg\") ; the unit conversion happens automatically.", 
            "title": "Dimensions in a type definition"
        }, 
        {
            "location": "/highlights/#making-new-units-and-dimensions", 
            "text": "You can make new units using the  @unit  macro on the fly:  julia  @unit c  c  SpeedOfLight 299792458u m/s  false\nc", 
            "title": "Making new units and dimensions"
        }, 
        {
            "location": "/highlights/#arrays", 
            "text": "Promotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from  [1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"] ). However, it could be useful in toy calculations for  general relativity  where some conventions yield matrices with mixed dimensions:  julia  @unit c  c  SpeedOfLight 299792458u m/s  false\nc\n\njulia  Diagonal([-1.0c^2, 1.0, 1.0, 1.0])\n4\u00d74 Diagonal{Unitful.Quantity{Float64,D,U}}:\n -1.0 c^2   \u22c5    \u22c5    \u22c5\n       \u22c5   1.0   \u22c5    \u22c5\n       \u22c5    \u22c5   1.0   \u22c5\n       \u22c5    \u22c5    \u22c5   1.0", 
            "title": "Arrays"
        }, 
        {
            "location": "/highlights/#units-with-rational-exponents", 
            "text": "julia  1.0u V/sqrt(Hz) \n1.0 Hz^-1/2 V", 
            "title": "Units with rational exponents"
        }, 
        {
            "location": "/highlights/#exact-conversions-respected", 
            "text": "julia  uconvert(u ft ,1u inch )\n1//12 ft", 
            "title": "Exact conversions respected"
        }, 
        {
            "location": "/types/", 
            "text": "Overview\n\n\nWe define a \nUnitful.Unit{U,D}\n type to represent a unit (\nU\n is a symbol, like \n:Meter\n, and \nD\n keeps track of dimensional information). Fields of a \nUnit\n object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g. \nnm\n or \nkm\n) may help to avoid overflow issues and general ugliness.\n\n\nWe define the immutable singleton \nUnitful.Units{N,D}\n, where \nN\n is always a tuple of \nUnit\n objects, and \nD\n is some type, like \ntypeof(Unitful.\ud835\udc0b)\n, where \n\ud835\udc0b\n is the object representing the length dimension. Usually, the user interacts only with \nUnits\n objects, not \nUnit\n objects.\n\n\nWe define a function \ndimension\n that turns, for example, \nacre^2\n into \n\ud835\udc0b^4\n. We can add quantities with the same dimension, regardless of specific units. Note that dimensions cannot be determined by powers of the units: \nft^2\n is an area, but so is \nac^1\n (an acre).\n\n\nWe define physical quantity types as \nQuantity{T\n:Number, D, U}\n, where \nD \n: Dimensions\n and \nU \n: Units\n. By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions: \nisa(1m, Length) == true\n. This works because \nLength\n is a type alias for some subset of \nUnitful.Quantity\n subtypes.\n\n\n\n\nQuantities\n\n\n#\n\n\nUnitful.Quantity\n \n \nType\n.\n\n\nimmutable Quantity{T,D,U} \n: Number\n\n\n\n\nA quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.\n\n\nThe type parameter \nT\n represents the numeric backing type. The type parameters \nD \n:\n \nUnitful.Dimensions\n and \nU \n:\n \nUnitful.Units\n. Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.\n\n\nsource\n\n\n#\n\n\nUnitful.DimensionlessQuantity\n \n \nConstant\n.\n\n\ntypealias DimensionlessQuantity{T,U} Quantity{T, Dimensions{()},U}\n\n\n\n\nUseful for dispatching on \nUnitful.Quantity\n types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)\n\n\nExample:\n\n\njulia\n isa(1.0u\nmV/V\n, DimensionlessQuantity)\ntrue\n\n\n\n\nsource\n\n\n\n\nUnits and dimensions\n\n\n#\n\n\nUnitful.Unitlike\n \n \nType\n.\n\n\nabstract Unitlike\n\n\n\n\nAbstract type facilitating some code reuse between \nUnitful.Units\n and \nUnitful.Dimensions\n objects.\n\n\nsource\n\n\n#\n\n\nUnitful.Units\n \n \nType\n.\n\n\nimmutable Units{N,D} \n: Unitlike\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. Example: the unit \nm\n is actually a singleton of type \nUnitful.Units{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),),typeof(\ud835\udc0b)\n. After dividing by \ns\n, a singleton of type \nUnitful.Units{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),Unitful.Unit{:Second,typeof(\ud835\udc13)}(0,-1//1,1.0,1//1)),typeof(\ud835\udc0b/\ud835\udc13)}\n is returned.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimensions\n \n \nType\n.\n\n\nimmutable Dimensions{N} \n: Unitlike\n\n\n\n\nInstances of this object represent dimensions, possibly combinations thereof.\n\n\nsource\n\n\n#\n\n\nUnitful.Unit\n \n \nType\n.\n\n\nimmutable Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend\n\n\n\n\nDescription of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter \nU\n as a symbol, e.g. \n:Meter\n, \n:Second\n, \n:Gram\n, etc. The type parameter \nD\n contains dimension information, for instance \nUnit{:Meter, typeof(\ud835\udc0b)}\n or \nUnit{:Liter, typeof(\ud835\udc0b^3)}\n. Note that the dimension information refers to the unit, not powers of the unit.\n\n\nUnit{U,D}\n objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter \nN\n of a \nUnits{N,D}\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimension\n \n \nType\n.\n\n\nimmutable Dimension{D}\n    power::Rational{Int}\nend\n\n\n\n\nDescription of a dimension. The name of the dimension \nD\n is a symbol, e.g. \n:Length\n, \n:Time\n, \n:Mass\n, etc.\n\n\nDimension{D}\n objects are collected in a tuple, which is used for the type parameter \nN\n of a \nDimensions{N}\n object.\n\n\nsource", 
            "title": "Types"
        }, 
        {
            "location": "/types/#overview", 
            "text": "We define a  Unitful.Unit{U,D}  type to represent a unit ( U  is a symbol, like  :Meter , and  D  keeps track of dimensional information). Fields of a  Unit  object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g.  nm  or  km ) may help to avoid overflow issues and general ugliness.  We define the immutable singleton  Unitful.Units{N,D} , where  N  is always a tuple of  Unit  objects, and  D  is some type, like  typeof(Unitful.\ud835\udc0b) , where  \ud835\udc0b  is the object representing the length dimension. Usually, the user interacts only with  Units  objects, not  Unit  objects.  We define a function  dimension  that turns, for example,  acre^2  into  \ud835\udc0b^4 . We can add quantities with the same dimension, regardless of specific units. Note that dimensions cannot be determined by powers of the units:  ft^2  is an area, but so is  ac^1  (an acre).  We define physical quantity types as  Quantity{T :Number, D, U} , where  D  : Dimensions  and  U  : Units . By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions:  isa(1m, Length) == true . This works because  Length  is a type alias for some subset of  Unitful.Quantity  subtypes.", 
            "title": "Overview"
        }, 
        {
            "location": "/types/#quantities", 
            "text": "#  Unitful.Quantity     Type .  immutable Quantity{T,D,U}  : Number  A quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.  The type parameter  T  represents the numeric backing type. The type parameters  D  :   Unitful.Dimensions  and  U  :   Unitful.Units . Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.  source  #  Unitful.DimensionlessQuantity     Constant .  typealias DimensionlessQuantity{T,U} Quantity{T, Dimensions{()},U}  Useful for dispatching on  Unitful.Quantity  types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)  Example:  julia  isa(1.0u mV/V , DimensionlessQuantity)\ntrue  source", 
            "title": "Quantities"
        }, 
        {
            "location": "/types/#units-and-dimensions", 
            "text": "#  Unitful.Unitlike     Type .  abstract Unitlike  Abstract type facilitating some code reuse between  Unitful.Units  and  Unitful.Dimensions  objects.  source  #  Unitful.Units     Type .  immutable Units{N,D}  : Unitlike  Instances of this object represent units, possibly combinations thereof. Example: the unit  m  is actually a singleton of type  Unitful.Units{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),),typeof(\ud835\udc0b) . After dividing by  s , a singleton of type  Unitful.Units{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),Unitful.Unit{:Second,typeof(\ud835\udc13)}(0,-1//1,1.0,1//1)),typeof(\ud835\udc0b/\ud835\udc13)}  is returned.  source  #  Unitful.Dimensions     Type .  immutable Dimensions{N}  : Unitlike  Instances of this object represent dimensions, possibly combinations thereof.  source  #  Unitful.Unit     Type .  immutable Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend  Description of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter  U  as a symbol, e.g.  :Meter ,  :Second ,  :Gram , etc. The type parameter  D  contains dimension information, for instance  Unit{:Meter, typeof(\ud835\udc0b)}  or  Unit{:Liter, typeof(\ud835\udc0b^3)} . Note that the dimension information refers to the unit, not powers of the unit.  Unit{U,D}  objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter  N  of a  Units{N,D}  object.  source  #  Unitful.Dimension     Type .  immutable Dimension{D}\n    power::Rational{Int}\nend  Description of a dimension. The name of the dimension  D  is a symbol, e.g.  :Length ,  :Time ,  :Mass , etc.  Dimension{D}  objects are collected in a tuple, which is used for the type parameter  N  of a  Dimensions{N}  object.  source", 
            "title": "Units and dimensions"
        }, 
        {
            "location": "/newunits/", 
            "text": "Defining new units\n\n\nThe package automatically generates a useful set of units and dimensions in the \nUnitful\n module in \nsrc/pkgdefaults.jl\n.\n\n\nIf a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the \n@unit\n macro.\n\n\nA note for the experts: Some care should be taken if explicitly creating \nUnitful.Units\n objects. The ordering of \nUnitful.Unit\n objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the \nUnits\n object will return a \"canonically sorted\" \nUnits\n object. Indeed, this is how we avoid ordering issues when multiplying quantities together.\n\n\n\n\nUseful functions and macros\n\n\n#\n\n\nUnitful.@dimension\n \n \nMacro\n.\n\n\nmacro dimension(symb, abbr, name)\n\n\n\n\nCreates new dimensions. \nname\n will be used like an identifier in the type parameter for a \nUnitful.Dimension\n object. \nsymb\n will be a symbol defined in the namespace from which this macro is called that is bound to a \nUnitful.Dimensions\n object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.\n\n\nThis macro extends \nUnitful.abbr\n to display the new dimension in an abbreviated format using the string \nabbr\n.\n\n\nType aliases are created that allow the user to dispatch on \nUnitful.Quantity\n and \nUnitful.Units\n objects of the newly defined dimension. The type alias for quantities is simply given by \nname\n, and the type alias for units is given by \nname*\"Unit\"\n, e.g. \nLengthUnit\n.\n\n\nFinally, if you define new dimensions with \n@dimension\n you will need to specify a preferred unit for that dimension with \nUnitful.preferunits\n, otherwise promotion will not work with that dimension.\n\n\nUsage example from \nsrc/pkgdefaults.jl\n: \n@dimension \ud835\udc0b \"L\" Length\n\n\nsource\n\n\n#\n\n\nUnitful.@derived_dimension\n \n \nMacro\n.\n\n\nmacro derived_dimension(name, dims)\n\n\n\n\nCreates type aliases to allow dispatch on \nUnitful.Quantity\n and \nUnitful.Units\n objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.\n\n\ndims\n is a \nUnitful.Dimensions\n object.\n\n\nUsage examples:\n\n\n\n\n@derived_dimension Area \ud835\udc0b^2\n gives \nArea\n and \nAreaUnit\n type aliases\n\n\n@derived_dimension Speed \ud835\udc0b/\ud835\udc13\n gives \nSpeed\n and \nSpeedUnit\n type aliases\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.@refunit\n \n \nMacro\n.\n\n\nmacro refunit(symb, name, abbr, dimension, tf)\n\n\n\n\nDefine a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.\n\n\nThis macro extends \nUnitful.abbr\n so that the reference unit can be displayed in an abbreviated format. If \ntf == true\n, this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A \ndimension\n must be given (\nUnitful.Dimensions\n object) that specifies the dimension of the reference unit.\n\n\nIn principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using \n@dimension\n, then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.\n\n\nUsage example: \n@refunit m \"m\" Meter \ud835\udc0b true\n\n\nThis example, found in \nsrc/pkgdefaults.jl\n, generates \nkm\n, \nm\n, \ncm\n, ...\n\n\nsource\n\n\n#\n\n\nUnitful.@unit\n \n \nMacro\n.\n\n\nmacro unit(symb,abbr,name,equals,tf)\n\n\n\n\nDefine a unit. Rather than specifying a dimension like in \n@refunit\n, \nequals\n should be a \nUnitful.Quantity\n equal to one of the unit being defined. If \ntf == true\n, symbols will be made for each power-of-ten prefix.\n\n\nUsage example: \n@unit mi \"mi\" Mile (201168//125)*m false\n\n\nThis example will \nnot\n generate \nkmi\n (kilomiles).\n\n\nsource\n\n\n#\n\n\nUnitful.offsettemp\n \n \nFunction\n.\n\n\noffsettemp(::Unit)\n\n\n\n\nFor temperature units, this function is used to set the scale offset.\n\n\nsource\n\n\n\n\nInternals\n\n\n#\n\n\nUnitful.@prefixed_unit_symbols\n \n \nMacro\n.\n\n\nmacro prefixed_unit_symbols(symb,name,dimension,basefactor)\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.\n\n\nExample: \n@prefixed_unit_symbols m Meter \ud835\udc0b (1.0,1)\n results in nm, cm, m, km, ... all getting defined in the calling namespace.\n\n\nsource\n\n\n#\n\n\nUnitful.@unit_symbols\n \n \nMacro\n.\n\n\nmacro unit_symbols(symb,name)\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.\n\n\nExample: \n@unit_symbols ft Foot \ud835\udc0b\n results in \nft\n getting defined but not \nkft\n.\n\n\nsource\n\n\n#\n\n\nUnitful.basefactor\n \n \nFunction\n.\n\n\nbasefactor(x::Unit)\n\n\n\n\nSpecifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.\n\n\nsource", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#defining-new-units", 
            "text": "The package automatically generates a useful set of units and dimensions in the  Unitful  module in  src/pkgdefaults.jl .  If a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the  @unit  macro.  A note for the experts: Some care should be taken if explicitly creating  Unitful.Units  objects. The ordering of  Unitful.Unit  objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the  Units  object will return a \"canonically sorted\"  Units  object. Indeed, this is how we avoid ordering issues when multiplying quantities together.", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#useful-functions-and-macros", 
            "text": "#  Unitful.@dimension     Macro .  macro dimension(symb, abbr, name)  Creates new dimensions.  name  will be used like an identifier in the type parameter for a  Unitful.Dimension  object.  symb  will be a symbol defined in the namespace from which this macro is called that is bound to a  Unitful.Dimensions  object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.  This macro extends  Unitful.abbr  to display the new dimension in an abbreviated format using the string  abbr .  Type aliases are created that allow the user to dispatch on  Unitful.Quantity  and  Unitful.Units  objects of the newly defined dimension. The type alias for quantities is simply given by  name , and the type alias for units is given by  name*\"Unit\" , e.g.  LengthUnit .  Finally, if you define new dimensions with  @dimension  you will need to specify a preferred unit for that dimension with  Unitful.preferunits , otherwise promotion will not work with that dimension.  Usage example from  src/pkgdefaults.jl :  @dimension \ud835\udc0b \"L\" Length  source  #  Unitful.@derived_dimension     Macro .  macro derived_dimension(name, dims)  Creates type aliases to allow dispatch on  Unitful.Quantity  and  Unitful.Units  objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.  dims  is a  Unitful.Dimensions  object.  Usage examples:   @derived_dimension Area \ud835\udc0b^2  gives  Area  and  AreaUnit  type aliases  @derived_dimension Speed \ud835\udc0b/\ud835\udc13  gives  Speed  and  SpeedUnit  type aliases   source  #  Unitful.@refunit     Macro .  macro refunit(symb, name, abbr, dimension, tf)  Define a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.  This macro extends  Unitful.abbr  so that the reference unit can be displayed in an abbreviated format. If  tf == true , this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A  dimension  must be given ( Unitful.Dimensions  object) that specifies the dimension of the reference unit.  In principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using  @dimension , then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.  Usage example:  @refunit m \"m\" Meter \ud835\udc0b true  This example, found in  src/pkgdefaults.jl , generates  km ,  m ,  cm , ...  source  #  Unitful.@unit     Macro .  macro unit(symb,abbr,name,equals,tf)  Define a unit. Rather than specifying a dimension like in  @refunit ,  equals  should be a  Unitful.Quantity  equal to one of the unit being defined. If  tf == true , symbols will be made for each power-of-ten prefix.  Usage example:  @unit mi \"mi\" Mile (201168//125)*m false  This example will  not  generate  kmi  (kilomiles).  source  #  Unitful.offsettemp     Function .  offsettemp(::Unit)  For temperature units, this function is used to set the scale offset.  source", 
            "title": "Useful functions and macros"
        }, 
        {
            "location": "/newunits/#internals", 
            "text": "#  Unitful.@prefixed_unit_symbols     Macro .  macro prefixed_unit_symbols(symb,name,dimension,basefactor)  Not called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.  Example:  @prefixed_unit_symbols m Meter \ud835\udc0b (1.0,1)  results in nm, cm, m, km, ... all getting defined in the calling namespace.  source  #  Unitful.@unit_symbols     Macro .  macro unit_symbols(symb,name)  Not called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.  Example:  @unit_symbols ft Foot \ud835\udc0b  results in  ft  getting defined but not  kft .  source  #  Unitful.basefactor     Function .  basefactor(x::Unit)  Specifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.  source", 
            "title": "Internals"
        }, 
        {
            "location": "/conversion/", 
            "text": "Converting between units\n\n\nSince \nconvert\n in Julia already means something specific (conversion between Julia types), we define \nuconvert\n for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.\n\n\nExact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.\n\n\n#\n\n\nUnitful.uconvert\n \n \nFunction\n.\n\n\nuconvert{T,D,U}(a::Units, x::Quantity{T,D,U})\n\n\n\n\nConvert a \nUnitful.Quantity\n to different units. The conversion will fail if the target units \na\n have a different dimension than the dimension of the quantity \nx\n. You can use this method to switch between equivalent representations of the same unit, like \nN m\n and \nJ\n.\n\n\nExample:\n\n\njulia\n uconvert(u\nhr\n,3602u\ns\n)\n1801//1800 hr\njulia\n uconvert(u\nJ\n,1.0u\nN*m\n)\n1.0 J\n\n\n\n\nsource\n\n\nuconvert{T,D,U}(a::Units, x::Quantity{T,TempDim,Units{U,TempDim}})\n\n\n\n\nIn this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions. We abbreviate \nTempDim = Dimensions{(Dimension{:Temperature}(1),)}\n for clarity.\n\n\nsource\n\n\nSince objects are callable, we can also make \nUnitful.Units\n callable with a \nNumber\n as an argument, for a unit conversion shorthand:\n\n\njulia\n u\ncm\n(1u\nm\n)\n100//1 cm\n\n\n\n\nThis syntax is a little confusing, but becomes appealing with the function chaining operator \n|\n:\n\n\njulia\n 1u\nm\n |\n u\ncm\n\n100//1 cm\n\n\n\n\nNote that since \nUnitful.Units\n objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling \nuconvert\n.\n\n\n\n\nDimensionless quantities\n\n\nFor dimensionless quantities, \nuconvert\n can be used to strip the units without losing power-of-ten information:\n\n\njulia\n uconvert(Unitful.NoUnits, 1.0u\n\u03bcm/m\n)\n1.0e-6\n\njulia\n uconvert(Unitful.NoUnits, 1.0u\nm\n)\nERROR: Unitful.DimensionError()\n\n\n\n\nYou can also directly convert to a subtype of \nReal\n or \nComplex\n:\n\n\njulia\n Float64(1.0u\n\u03bcm/m\n)\n1.0e-6\n\n\n\n\n\n\nTemperature conversion\n\n\nIf the dimension of a \nQuantity\n is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature \nintervals\n.\n\n\n\n\nPromotion mechanisms\n\n\nWe decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance. If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.\n\n\n\n\nPromotion rules for specific dimensions\n\n\nYou can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session, specifically \nbefore\n \nupreferred\n \nhas been called or quantities have been promoted\n. For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in \ng*cm^2/s^2\n. This is accomplished by defining a \nBase.promote_rule\n for the units themselves. Here's an example.\n\n\njulia\n using Unitful\n\njulia\n Base.promote_rule{S\n:Unitful.EnergyUnit, T\n:Unitful.EnergyUnit}(::Type{S}, ::Type{T}) = typeof(u\ng*cm^2/s^2\n)\n\njulia\n promote(2.0u\nJ\n, 1.0u\nkg*m^2/s^2\n)\n(2.0e7 g cm^2 s^-2,1.0e7 g cm^2 s^-2)\n\njulia\n Base.promote_rule{S\n:Unitful.EnergyUnit, T\n:Unitful.EnergyUnit}(::Type{S}, ::Type{T}) = typeof(u\nJ\n)\n\njulia\n promote(2.0u\nJ\n, 1.0u\nkg*m^2/s^2\n)\n(2.0e7 g cm^2 s^-2,1.0e7 g cm^2 s^-2)\n\n\n\n\nNotice how the first definition of \nBase.promote_rule\n had a permanent effect. This is true of promotion rules for types defined in Base too; try defining a new promotion rule for \nInt\n and \nFloat64\n and you'll see it has no effect.\n\n\nIf you're wondering where \nUnitful.EnergyUnit\n comes from, it is defined in \nsrc/pkgdefaults.jl\n by the \n@derived_dimension\n macro. Similarly, the calls to the \n@dimension\n macro define \nUnitful.LengthUnit\n, \nUnitful.MassUnit\n, etc. None of these are exported.\n\n\nExisting users of Unitful may want to call \nUnitful.promote_to_derived\n after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default because otherwise users who want different behavior would have to suffer through method redefinition warnings every time.\n\n\n#\n\n\nUnitful.promote_to_derived\n \n \nFunction\n.\n\n\nUnitful.promote_to_derived()\n\n\n\n\nDefines promotion rules to use derived SI units in promotion for common dimensions of quantities:\n\n\n\n\nJ\n (joule) for energy\n\n\nN\n (newton) for force\n\n\nW\n (watt) for power\n\n\nPa\n (pascal) for pressure\n\n\nC\n (coulomb) for charge\n\n\nV\n (volt) for voltage\n\n\n\u03a9\n (ohm) for resistance\n\n\nF\n (farad) for capacitance\n\n\nH\n (henry) for inductance\n\n\nWb\n (weber) for magnetic flux\n\n\nT\n (tesla) for B-field\n\n\nJ*s\n (joule-second) for action\n\n\n\n\nIf you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your \n.juliarc.jl\n file which is loaded when you open Julia. This function is not exported.\n\n\nsource\n\n\n\n\nFallback promotion rules\n\n\nThe \nUnitful.preferunits\n function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.\n\n\nThe default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension \n\ud835\udc0c*\ud835\udc0b^2/(\ud835\udc13^2*\ud835\udeaf)\n would be converted to \nkg*m^2/(s^2*K)\n:\n\n\njulia\n promote(1.0u\nJ/K\n, 1.0u\ng*cm^2/s^2/K\n)\n(1.0 kg K^-1 m^2 s^-2,1.0e-7 kg K^-1 m^2 s^-2)\n\n\n\n\nYou can however override this behavior by calling \nUnitful.preferunits\n at the start of a Julia session, specifically \nbefore\n \nupreferred\n \nhas been called or quantities have been promoted\n.\n\n\n#\n\n\nUnitful.preferunits\n \n \nFunction\n.\n\n\nfunction preferunits(u0::Units, u::Units...)\n\n\n\n\nThis function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like \ud835\udc0b or \ud835\udc13 but not \ud835\udc0b/\ud835\udc13 or \ud835\udc0b^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user.\n\n\nOnce \nUnitful.upreferred\n has been called or quantities have been promoted, this function will appear to have no effect.\n\n\nUsage example: \npreferunits(u\"m,s,A,K,cd,kg,mol\"...)\n\n\nsource\n\n\n\n\nArray promotion\n\n\nArrays are typed with as much specificity as possible upon creation. consider the following three cases:\n\n\njulia\n [1.0u\nm\n, 2.0u\nm\n]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1.0 m\n 2.0 m\n\njulia\n [1.0u\nm\n, 2.0u\ncm\n]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n  1.0 m\n 0.02 m\n\njulia\n [1.0u\nm\n, 2.0]\n2-element Array{Unitful.Quantity{Float64,D,U},1}:\n 1.0 m\n   2.0\n\n\n\n\nIn the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:\n\n\njulia\n f{T\n:Unitful.Length}(x::AbstractArray{T}) = sum(x)\nf (generic function with 1 method)\n\njulia\n f([1.0u\nm\n, 2.0u\ncm\n])\n1.02 m\n\njulia\n f([1.0u\ng\n, 2.0u\ncm\n])\nERROR: MethodError: no method matching f(::Array{Unitful.Quantity{Float64,D,U},1})\n\n\n\n\n\n\nUnit cancellation\n\n\nFor multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance, \nmV/V\n is not simplified, although \nV/V\n is. Also, \nN*m/J\n is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Conversion / promotion"
        }, 
        {
            "location": "/conversion/#converting-between-units", 
            "text": "Since  convert  in Julia already means something specific (conversion between Julia types), we define  uconvert  for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.  Exact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.  #  Unitful.uconvert     Function .  uconvert{T,D,U}(a::Units, x::Quantity{T,D,U})  Convert a  Unitful.Quantity  to different units. The conversion will fail if the target units  a  have a different dimension than the dimension of the quantity  x . You can use this method to switch between equivalent representations of the same unit, like  N m  and  J .  Example:  julia  uconvert(u hr ,3602u s )\n1801//1800 hr\njulia  uconvert(u J ,1.0u N*m )\n1.0 J  source  uconvert{T,D,U}(a::Units, x::Quantity{T,TempDim,Units{U,TempDim}})  In this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions. We abbreviate  TempDim = Dimensions{(Dimension{:Temperature}(1),)}  for clarity.  source  Since objects are callable, we can also make  Unitful.Units  callable with a  Number  as an argument, for a unit conversion shorthand:  julia  u cm (1u m )\n100//1 cm  This syntax is a little confusing, but becomes appealing with the function chaining operator  | :  julia  1u m  |  u cm \n100//1 cm  Note that since  Unitful.Units  objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling  uconvert .", 
            "title": "Converting between units"
        }, 
        {
            "location": "/conversion/#dimensionless-quantities", 
            "text": "For dimensionless quantities,  uconvert  can be used to strip the units without losing power-of-ten information:  julia  uconvert(Unitful.NoUnits, 1.0u \u03bcm/m )\n1.0e-6\n\njulia  uconvert(Unitful.NoUnits, 1.0u m )\nERROR: Unitful.DimensionError()  You can also directly convert to a subtype of  Real  or  Complex :  julia  Float64(1.0u \u03bcm/m )\n1.0e-6", 
            "title": "Dimensionless quantities"
        }, 
        {
            "location": "/conversion/#temperature-conversion", 
            "text": "If the dimension of a  Quantity  is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature  intervals .", 
            "title": "Temperature conversion"
        }, 
        {
            "location": "/conversion/#promotion-mechanisms", 
            "text": "We decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance. If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.", 
            "title": "Promotion mechanisms"
        }, 
        {
            "location": "/conversion/#promotion-rules-for-specific-dimensions", 
            "text": "You can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session, specifically  before   upreferred   has been called or quantities have been promoted . For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in  g*cm^2/s^2 . This is accomplished by defining a  Base.promote_rule  for the units themselves. Here's an example.  julia  using Unitful\n\njulia  Base.promote_rule{S :Unitful.EnergyUnit, T :Unitful.EnergyUnit}(::Type{S}, ::Type{T}) = typeof(u g*cm^2/s^2 )\n\njulia  promote(2.0u J , 1.0u kg*m^2/s^2 )\n(2.0e7 g cm^2 s^-2,1.0e7 g cm^2 s^-2)\n\njulia  Base.promote_rule{S :Unitful.EnergyUnit, T :Unitful.EnergyUnit}(::Type{S}, ::Type{T}) = typeof(u J )\n\njulia  promote(2.0u J , 1.0u kg*m^2/s^2 )\n(2.0e7 g cm^2 s^-2,1.0e7 g cm^2 s^-2)  Notice how the first definition of  Base.promote_rule  had a permanent effect. This is true of promotion rules for types defined in Base too; try defining a new promotion rule for  Int  and  Float64  and you'll see it has no effect.  If you're wondering where  Unitful.EnergyUnit  comes from, it is defined in  src/pkgdefaults.jl  by the  @derived_dimension  macro. Similarly, the calls to the  @dimension  macro define  Unitful.LengthUnit ,  Unitful.MassUnit , etc. None of these are exported.  Existing users of Unitful may want to call  Unitful.promote_to_derived  after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default because otherwise users who want different behavior would have to suffer through method redefinition warnings every time.  #  Unitful.promote_to_derived     Function .  Unitful.promote_to_derived()  Defines promotion rules to use derived SI units in promotion for common dimensions of quantities:   J  (joule) for energy  N  (newton) for force  W  (watt) for power  Pa  (pascal) for pressure  C  (coulomb) for charge  V  (volt) for voltage  \u03a9  (ohm) for resistance  F  (farad) for capacitance  H  (henry) for inductance  Wb  (weber) for magnetic flux  T  (tesla) for B-field  J*s  (joule-second) for action   If you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your  .juliarc.jl  file which is loaded when you open Julia. This function is not exported.  source", 
            "title": "Promotion rules for specific dimensions"
        }, 
        {
            "location": "/conversion/#fallback-promotion-rules", 
            "text": "The  Unitful.preferunits  function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.  The default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension  \ud835\udc0c*\ud835\udc0b^2/(\ud835\udc13^2*\ud835\udeaf)  would be converted to  kg*m^2/(s^2*K) :  julia  promote(1.0u J/K , 1.0u g*cm^2/s^2/K )\n(1.0 kg K^-1 m^2 s^-2,1.0e-7 kg K^-1 m^2 s^-2)  You can however override this behavior by calling  Unitful.preferunits  at the start of a Julia session, specifically  before   upreferred   has been called or quantities have been promoted .  #  Unitful.preferunits     Function .  function preferunits(u0::Units, u::Units...)  This function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like \ud835\udc0b or \ud835\udc13 but not \ud835\udc0b/\ud835\udc13 or \ud835\udc0b^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user.  Once  Unitful.upreferred  has been called or quantities have been promoted, this function will appear to have no effect.  Usage example:  preferunits(u\"m,s,A,K,cd,kg,mol\"...)  source", 
            "title": "Fallback promotion rules"
        }, 
        {
            "location": "/conversion/#array-promotion", 
            "text": "Arrays are typed with as much specificity as possible upon creation. consider the following three cases:  julia  [1.0u m , 2.0u m ]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1.0 m\n 2.0 m\n\njulia  [1.0u m , 2.0u cm ]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n  1.0 m\n 0.02 m\n\njulia  [1.0u m , 2.0]\n2-element Array{Unitful.Quantity{Float64,D,U},1}:\n 1.0 m\n   2.0  In the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:  julia  f{T :Unitful.Length}(x::AbstractArray{T}) = sum(x)\nf (generic function with 1 method)\n\njulia  f([1.0u m , 2.0u cm ])\n1.02 m\n\njulia  f([1.0u g , 2.0u cm ])\nERROR: MethodError: no method matching f(::Array{Unitful.Quantity{Float64,D,U},1})", 
            "title": "Array promotion"
        }, 
        {
            "location": "/conversion/#unit-cancellation", 
            "text": "For multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance,  mV/V  is not simplified, although  V/V  is. Also,  N*m/J  is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Unit cancellation"
        }, 
        {
            "location": "/manipulations/", 
            "text": "#\n\n\nUnitful.@u_str\n \n \nMacro\n.\n\n\nmacro u_str(unit)\n\n\n\n\nString macro to easily recall units, dimensions, or quantities defined in unit modules that have been registered with \nUnitful.register\n.\n\n\nIf the same symbol is used for a \nUnitful.Units\n object defined in different modules, then the symbol found in the most recently registered module will be used.\n\n\nNote that what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".\n\n\nExamples:\n\n\njulia\n 1.0u\nm/s\n\n1.0 m s^-1\n\njulia\n 1.0u\nN*m\n\n1.0 m N\n\njulia\n u\nm,kg,s\n\n(m,kg,s)\n\njulia\n typeof(1.0u\nm/s\n)\nQuantity{Float64, Dimensions:{\ud835\udc0b \ud835\udc13^-1}, Units:{m s^-1}}\n\njulia\n u\n\u0127\n\n1.0545718001391127e-34 J s\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.register\n \n \nFunction\n.\n\n\nfunction register(unit_module::Module)\n\n\n\n\nMakes the \n@u_str\n macro aware of units defined in new unit modules.\n\n\nExample:\n\n\n# somewhere in a custom units package...\nmodule MyUnitsPackage\nusing Unitful\n\nfunction __init__()\n    ...\n    Unitful.register(MyUnitsPackage)\nend\nend #module\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.unit\n \n \nFunction\n.\n\n\nunit{T,D,U}(x::Quantity{T,D,U})\n\n\n\n\nReturns the units associated with a quantity, \nU()\n.\n\n\nExamples:\n\n\njulia\n unit(1.0u\nm\n) == u\nm\n\ntrue\n\njulia\n typeof(u\nm\n)\nUnitful.Units{(Unitful.Unit{:Meter,Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}(0,1//1),),Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}\n\n\n\n\nsource\n\n\nunit{T,D,U}(x::Type{Quantity{T,D,U}})\n\n\n\n\nReturns the units associated with a quantity type, \nU()\n.\n\n\nExamples:\n\n\njulia\n unit(typeof(1.0u\nm\n)) == u\nm\n\ntrue\n\n\n\n\nsource\n\n\nunit(x::Number)\n\n\n\n\nReturns a \nUnitful.Units{(), Dimensions{()}}\n object to indicate that ordinary numbers have no units. This is a singleton, which we export as \nNoUnits\n. The unit is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n typeof(unit(1.0))\nUnitful.Units{(),Unitful.Dimensions{()}}\njulia\n typeof(unit(Float64))\nUnitful.Units{(),Unitful.Dimensions{()}}\njulia\n unit(1.0) == NoUnits\ntrue\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.ustrip\n \n \nFunction\n.\n\n\nustrip(x::Number)\n\n\n\n\nReturns the number out in front of any units. This may be different from the value in the case of dimensionless quantities. See \nuconvert\n and the example below. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is just calling \nx/unit(x)\n, which is as fast as directly accessing the \nval\n field of \nx::Quantity\n, but also works for any other kind of number.\n\n\nThis function is mainly intended for compatibility with packages that don't know how to handle quantities. This function may be deprecated in the future.\n\n\njulia\n ustrip(2u\n\u03bcm/m\n) == 2\ntrue\n\njulia\n uconvert(NoUnits, 2u\n\u03bcm/m\n) == 2//1000000\ntrue\n\n\n\n\nsource\n\n\nustrip{T,D,U}(x::Array{Quantity{T,D,U}})\n\n\n\n\nStrip units from an \nArray\n by reinterpreting to type \nT\n. The resulting \nArray\n is a \"unit free view\" into array \nx\n. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.\n\n\njulia\n a = [1u\nm\n, 2u\nm\n]\n2-element Array{Quantity{Int64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1 m\n 2 m\n\njulia\n b = ustrip(a)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia\n a[1] = 3u\nm\n; b\n2-element Array{Int64,1}:\n 3\n 2\n\n\n\n\nsource\n\n\nustrip{T,D,U}(x::AbstractArray{Quantity{T,D,U}})\n\n\n\n\nStrip units from an \nAbstractArray\n by making a new array without units using array comprehensions.\n\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.\n\n\nsource\n\n\nustrip{T\n:Number}(x::AbstractArray{T})\n\n\n\n\nFall-back that returns \nx\n.\n\n\nsource\n\n\n#\n\n\nUnitful.upreferred\n \n \nFunction\n.\n\n\nupreferred(x::Number)\n\n\n\n\nUnit-convert \nx\n to units which are preferred for the dimensions of \nx\n, as specified by the \npreferunits\n function. If you are using the factory defaults, this function will unit-convert to a product of powers of base SI units.\n\n\nsource\n\n\nupreferred(x::Units)\n\n\n\n\nReturn units which are preferred for the dimensions of \nx\n, which may or may not be equal to \nx\n, as specified by the \npreferunits\n function. If you are using the factory defaults, this function will return a product of powers of base SI units.\n\n\nsource\n\n\nupreferred(x::Dimensions)\n\n\n\n\nReturn units which are preferred for dimensions \nx\n. If you are using the factory defaults, this function will return a product of powers of base SI units.\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(x::Number)\ndimension{T\n:Number}(x::Type{T})\n\n\n\n\nReturns a \nUnitful.Dimensions{()}\n object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as \nNoDims\n. The dimension is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n typeof(dimension(1.0))\nUnitful.Dimensions{()}\njulia\n typeof(dimension(Float64))\nUnitful.Dimensions{()}\njulia\n dimension(1.0) == NoDims\ntrue\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{U,D}(u::Units{U,D})\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(u\nm\n))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia\n typeof(dimension(u\nm/km\n))\nUnitful.Dimensions{()}\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{T,D}(x::Quantity{T,D})\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(1.0u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(1.0u\nm/\u03bcm\n))\nUnitful.Dimensions{()}\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{T\n:Units}(x::AbstractArray{T})\n\n\n\n\nJust calls \nmap(dimension, x)\n.\n\n\nsource\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Units, a::Units...)\n\n\n\n\nGiven however many units, multiply them together.\n\n\nCollect \nUnitful.Unit\n objects from the type parameter of the \nUnitful.Units\n objects. For identical units including SI prefixes (i.e. cm \u2260 m), collect powers and sort uniquely by the name of the \nUnit\n. The unique sorting permits easy unit comparisons.\n\n\nExamples:\n\n\njulia\n u\nkg*m/s^2\n\nkg m s^-2\n\njulia\n u\nm/s*kg/s\n\nkg m s^-2\n\njulia\n typeof(u\nm/s*kg/s\n) == typeof(u\nkg*m/s^2\n)\ntrue\n\n\n\n\nsource\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Dimensions, a::Dimensions...)\n\n\n\n\nGiven however many dimensions, multiply them together.\n\n\nCollect \nUnitful.Dimension\n objects from the type parameter of the \nUnitful.Dimensions\n objects. For identical dimensions, collect powers and sort uniquely by the name of the \nDimension\n.\n\n\nExamples:\n\n\njulia\n u\n\ud835\udc0c*\ud835\udc0b/\ud835\udc13^2\n\n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\njulia\n u\n\ud835\udc0b*\ud835\udc0c/\ud835\udc13^2\n\n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\njulia\n typeof(u\n\ud835\udc0b*\ud835\udc0c/\ud835\udc13^2\n) == typeof(u\n\ud835\udc0c*\ud835\udc0b/\ud835\udc13^2\n)\ntrue\n\n\n\n\nsource", 
            "title": "Manipulating units"
        }, 
        {
            "location": "/display/", 
            "text": "#\n\n\nUnitful.abbr\n \n \nFunction\n.\n\n\nabbr(x)\n provides abbreviations for units or dimensions. Since a method should always be defined for each unit and dimension type, absence of a method for a specific unit or dimension type is likely an error. Consequently, we return \u2753 for generic arguments to flag unexpected behavior.\n\n\nsource\n\n\n#\n\n\nUnitful.prefix\n \n \nFunction\n.\n\n\nprefix(x::Unit)\n\n\n\n\nReturns a string representing the SI prefix for the power-of-ten held by this particular unit.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO, x::Quantity)\n\n\n\n\nShow a unitful quantity by calling \nshow\n on the numeric value, appending a space, and then calling \nshow\n on a units object \nU()\n.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow{T,D,U}(io::IO, ::Type{Quantity{T,D,U}})\n\n\n\n\nShow the type of a unitful quantity in a succinct way. Otherwise, array summaries are nearly unreadable.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO,x::Unitlike)\n\n\n\n\nCall \nUnitful.showrep\n on each object in the tuple that is the type variable of a \nUnitful.Units\n or \nUnitful.Dimensions\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Unit)\n\n\n\n\nShow the unit, prefixing with any decimal prefix and appending the exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Dimension)\n\n\n\n\nShow the dimension, appending any exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.superscript\n \n \nFunction\n.\n\n\nsuperscript(i::Rational)\n\n\n\n\nPrints exponents.\n\n\nsource", 
            "title": "How units are displayed"
        }, 
        {
            "location": "/extending/", 
            "text": "Extending Unitful\n\n\n\n\nMaking your own units package\n\n\nNew units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in \nUnitfulUS.jl\n, which defines U.S. customary units. It's actually very easy! Just make sure you read the cautionary notes below.\n\n\nIf you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!\n\n\n\n\nSome limitations\n\n\n\n\nPrecompilation\n\n\nWhen creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following or something very similar make it into your code:\n\n\nconst localunits = Unitful.basefactors\nconst localpromotion = Unitful.promotion # only if you've used @dimension\nfunction __init__()\n    merge!(Unitful.basefactors, localunits)\n    merge!(Unitful.promotion, localpromotion) # only if you've used @dimension\nend\n\n\n\n\nThe definition of \nlocalunits\n (\nlocalpromotion\n) must happen \nafter all new units (dimensions) have been defined\n.\n\n\nThe problem is that the \n@unit\n macro needs to add some information to a dictionary defined in Unitful, regardless of where the macro is executed (the use of this dictionary does not lead to run-time penalties, if you were wondering). However, because Unitful is precompiled, changes made to it from another module at compile-time will not persist.\n\n\nThe \nconst localunits = Unitful.basefactors\n line makes a copy of the compile-time-modified dictionary, which can be precompiled into the module where this code appears, and then the dictionary is merged into Unitful's dictionary at runtime.\n\n\nIf you'd like, you can also consider adding a call to \nUnitful.register\n in your \n__init__\n function, which will make your units accessible using Unitful's \n@u_str\n macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the \n@u_str\n macro will still work, but it will use the unit found in whichever package was registered most recently, and it will omit a warning every time.\n\n\n\n\nType uniqueness\n\n\nCurrently, when the \n@dimension\n, \n@derived_dimension\n, \n@refunit\n, or \n@unit\n macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g. \nLength\n, \nMeter\n, etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.\n\n\nI don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of \nBase.gensym()\n if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.", 
            "title": "Extending Unitful"
        }, 
        {
            "location": "/extending/#extending-unitful", 
            "text": "", 
            "title": "Extending Unitful"
        }, 
        {
            "location": "/extending/#making-your-own-units-package", 
            "text": "New units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in  UnitfulUS.jl , which defines U.S. customary units. It's actually very easy! Just make sure you read the cautionary notes below.  If you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!", 
            "title": "Making your own units package"
        }, 
        {
            "location": "/extending/#some-limitations", 
            "text": "", 
            "title": "Some limitations"
        }, 
        {
            "location": "/extending/#precompilation", 
            "text": "When creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following or something very similar make it into your code:  const localunits = Unitful.basefactors\nconst localpromotion = Unitful.promotion # only if you've used @dimension\nfunction __init__()\n    merge!(Unitful.basefactors, localunits)\n    merge!(Unitful.promotion, localpromotion) # only if you've used @dimension\nend  The definition of  localunits  ( localpromotion ) must happen  after all new units (dimensions) have been defined .  The problem is that the  @unit  macro needs to add some information to a dictionary defined in Unitful, regardless of where the macro is executed (the use of this dictionary does not lead to run-time penalties, if you were wondering). However, because Unitful is precompiled, changes made to it from another module at compile-time will not persist.  The  const localunits = Unitful.basefactors  line makes a copy of the compile-time-modified dictionary, which can be precompiled into the module where this code appears, and then the dictionary is merged into Unitful's dictionary at runtime.  If you'd like, you can also consider adding a call to  Unitful.register  in your  __init__  function, which will make your units accessible using Unitful's  @u_str  macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the  @u_str  macro will still work, but it will use the unit found in whichever package was registered most recently, and it will omit a warning every time.", 
            "title": "Precompilation"
        }, 
        {
            "location": "/extending/#type-uniqueness", 
            "text": "Currently, when the  @dimension ,  @derived_dimension ,  @refunit , or  @unit  macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g.  Length ,  Meter , etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.  I don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of  Base.gensym()  if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.", 
            "title": "Type uniqueness"
        }, 
        {
            "location": "/trouble/", 
            "text": "Why do unit conversions yield rational numbers sometimes?\n\n\nWe use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point \n2.54\n is not equal to \n254//100\n. As a consequence, \n1inch != 2.54cm\n, because Unitful respects exact conversions. To test for equivalence, instead use \n\u2248\n (\n\\approx\n tab-completion).\n\n\n\n\nBut I want a floating point number...\n\n\nfloat(x)\n is defined for \nUnitful.Quantity\n types, and is forwarded to the underlying numeric type (units are not affected).\n\n\nWe may consider adding an option in the defaults to turn on/off use of \nRational\n numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that \ninv(2) === 0.5\n, not \n1//2\n).\n\n\n\n\nExponentiation\n\n\nMost operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a \nUnitful.Quantity\n object, raising a \nQuantity\n to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance. Example:\n\n\njulia\n typeof((1.0u\nm\n)^2)\nQuantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}\n\njulia\n typeof((1.0u\nm\n)^3)\nQuantity{Float64, Dimensions:{\ud835\udc0b^3}, Units:{m^3}}\n\n\n\n\nBecause the functions \ninv\n and \nsqrt\n are raising a \nQuantity\n to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a \nQuantity\n will be type-stable if done as \nx*x\n but not as \nx^2\n.\n\n\n\n\nPromotion with dimensionless numbers\n\n\nMost of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that \n\u03bcm/m\n and \nrad\n are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.\n\n\nThe result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles, \n1 rad\n is essentially just \n1\n, giving sane behavior:\n\n\njulia\n \u03c0/2*u\nrad\n+90u\n\u00b0\n\n3.141592653589793\n\n\n\n\n\n\nOther random problems\n\n\nIf using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:\n\n\njulia\n using Unitful: m,cm\n\njulia\n uconvert(m,0x01cm)   # the user means cm, not 0x01c*m\n0x001c m\n\n\n\n\nThis behavior is a consequence of \na Julia issue\n.\n\n\n\n\nI have a different problem\n\n\nPlease raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/trouble/#why-do-unit-conversions-yield-rational-numbers-sometimes", 
            "text": "We use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point  2.54  is not equal to  254//100 . As a consequence,  1inch != 2.54cm , because Unitful respects exact conversions. To test for equivalence, instead use  \u2248  ( \\approx  tab-completion).", 
            "title": "Why do unit conversions yield rational numbers sometimes?"
        }, 
        {
            "location": "/trouble/#but-i-want-a-floating-point-number", 
            "text": "float(x)  is defined for  Unitful.Quantity  types, and is forwarded to the underlying numeric type (units are not affected).  We may consider adding an option in the defaults to turn on/off use of  Rational  numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that  inv(2) === 0.5 , not  1//2 ).", 
            "title": "But I want a floating point number..."
        }, 
        {
            "location": "/trouble/#exponentiation", 
            "text": "Most operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a  Unitful.Quantity  object, raising a  Quantity  to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance. Example:  julia  typeof((1.0u m )^2)\nQuantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}\n\njulia  typeof((1.0u m )^3)\nQuantity{Float64, Dimensions:{\ud835\udc0b^3}, Units:{m^3}}  Because the functions  inv  and  sqrt  are raising a  Quantity  to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a  Quantity  will be type-stable if done as  x*x  but not as  x^2 .", 
            "title": "Exponentiation"
        }, 
        {
            "location": "/trouble/#promotion-with-dimensionless-numbers", 
            "text": "Most of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that  \u03bcm/m  and  rad  are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.  The result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles,  1 rad  is essentially just  1 , giving sane behavior:  julia  \u03c0/2*u rad +90u \u00b0 \n3.141592653589793", 
            "title": "Promotion with dimensionless numbers"
        }, 
        {
            "location": "/trouble/#other-random-problems", 
            "text": "If using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:  julia  using Unitful: m,cm\n\njulia  uconvert(m,0x01cm)   # the user means cm, not 0x01c*m\n0x001c m  This behavior is a consequence of  a Julia issue .", 
            "title": "Other random problems"
        }, 
        {
            "location": "/trouble/#i-have-a-different-problem", 
            "text": "Please raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "I have a different problem"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nThe Unitful.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "The Unitful.jl package is licensed under the MIT \"Expat\" License:   Copyright (c) 2016: Andrew Keller.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}