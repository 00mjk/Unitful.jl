{
    "docs": [
        {
            "location": "/", 
            "text": "Unitful.jl\n\n\nA Julia package for physical units. Available \nhere\n. Inspired by:\n\n\n\n\nSIUnits.jl\n\n\nEngUnits.jl\n\n\nUnits.jl\n\n\n\n\nWe want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.\n\n\n\n\nNote\n\n\nIf you have been previously using Unitful 0.0.4 or earlier, the defaults mechanism has been completely rewritten. This means you will now need to define new units in your \n.juliarc.jl\n file or in a new module. See \nDefining new units\n and \nExtending Unitful\n for details. Additionally, to specify custom rules for promotion, see \nBasic promotion mechanisms\n and \nAdvanced promotion mechanisms\n.\n\n\n\n\n\n\nQuick start\n\n\n\n\nThis package requires Julia 0.5. Older versions will not be supported.\n\n\nPkg.add(\"Unitful\")\n\n\nusing Unitful\n\n\n\n\nUnitful aims for generality, but has some useful functionality out of the box.\n\n\n\n\nBase dimensions like length, mass, time, etc. are defined.\n\n\nDerived dimensions like volume, energy, momentum, etc. are defined.\n\n\nBase and derived SI units with their power-of-ten prefixes are defined.\n\n\nSome other common units are defined, without power-of-ten prefixes.\n\n\nSensible default promotion behavior is specified.\n\n\n\n\nTake a look at \nsrc/pkgdefaults.jl\n for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:\n\n\n\n\ninch\n is used instead of \nin\n, since \nin\n conflicts with Julia syntax\n\n\nminute\n is used instead of \nmin\n, since \nmin\n is a commonly used function\n\n\nhr\n is used instead of \nh\n, since \nh\n is revered as the Planck constant\n\n\n\n\n\n\nImportant note on namespaces\n\n\nUnits, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:\n\n\n\n\nUse the \n@u_str\n string macro.\n\n\nExplicitly import from the \nUnitful\n package to bring specific symbols into the calling namespace.\n\n\n\n\nusing Unitful.DefaultSymbols\n will bring the following symbols into the calling namespace:\n\n\n\n\nDimensions \n\ud835\udc0b,\ud835\udc0c,\ud835\udc13,\ud835\udc08,\ud835\udeaf,\ud835\udc09,\ud835\udc0d\n for length, mass, time, current, temperature,\n\n\n\n\nluminosity, and amount, respectively.\n\n\n\n\nBase and derived SI units, with SI prefixes.\n\n\n\u00b0\n (degrees)\n\n\n\n\n\n\n\n\nIf you have been using the \nSIUnits.jl\n   package, this is not unlike typing \nusing SIUnits.ShortUnits\n with that package.\n\n\n\n\nUsage examples\n\n\njulia\n \n1\nu\nkg\n \n==\n \n1000\nu\ng\n             \n# Equivalence implies unit conversion\n\n\ntrue\n\n\n\njulia\n \n!\n(\n1\nu\nkg\n \n===\n \n1000\nu\ng\n)\n         \n# ...and yet we can distinguish these...\n\n\ntrue\n\n\n\njulia\n \n1\nu\nkg\n \n===\n \n1\nu\nkg\n              \n# ...and these are indistinguishable.\n\n\ntrue\n\n\n\n\n\n\nIn the next examples we assume we have brought some units into our namespace, e.g. using \nm = u\"m\"\n, etc.\n\n\njulia\n \nuconvert\n(\n\u00b0C\n,\n \n212\n\u00b0F\n)\n\n\n100//1 \u00b0C\n\n\n\njulia\n \nuconvert\n(\n\u03bcm\n/\n(\nm\n*\n\u00b0F\n),\n \n9\n\u03bcm\n/\n(\nm\n*\n\u00b0C\n))\n\n\n5//1 \u00b0F^-1 \u03bcm m^-1\n\n\n\njulia\n \nmod\n(\n1\nhr\n+\n3\nminute\n+\n5\ns\n,\n \n24\ns\n)\n\n\n17//1 s\n\n\n\n\n\n\nSee \ntest/runtests.jl\n for more usage examples.", 
            "title": "Home"
        }, 
        {
            "location": "/#unitfuljl", 
            "text": "A Julia package for physical units. Available  here . Inspired by:   SIUnits.jl  EngUnits.jl  Units.jl   We want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.   Note  If you have been previously using Unitful 0.0.4 or earlier, the defaults mechanism has been completely rewritten. This means you will now need to define new units in your  .juliarc.jl  file or in a new module. See  Defining new units  and  Extending Unitful  for details. Additionally, to specify custom rules for promotion, see  Basic promotion mechanisms  and  Advanced promotion mechanisms .", 
            "title": "Unitful.jl"
        }, 
        {
            "location": "/#quick-start", 
            "text": "This package requires Julia 0.5. Older versions will not be supported.  Pkg.add(\"Unitful\")  using Unitful   Unitful aims for generality, but has some useful functionality out of the box.   Base dimensions like length, mass, time, etc. are defined.  Derived dimensions like volume, energy, momentum, etc. are defined.  Base and derived SI units with their power-of-ten prefixes are defined.  Some other common units are defined, without power-of-ten prefixes.  Sensible default promotion behavior is specified.   Take a look at  src/pkgdefaults.jl  for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:   inch  is used instead of  in , since  in  conflicts with Julia syntax  minute  is used instead of  min , since  min  is a commonly used function  hr  is used instead of  h , since  h  is revered as the Planck constant", 
            "title": "Quick start"
        }, 
        {
            "location": "/#important-note-on-namespaces", 
            "text": "Units, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:   Use the  @u_str  string macro.  Explicitly import from the  Unitful  package to bring specific symbols into the calling namespace.   using Unitful.DefaultSymbols  will bring the following symbols into the calling namespace:   Dimensions  \ud835\udc0b,\ud835\udc0c,\ud835\udc13,\ud835\udc08,\ud835\udeaf,\ud835\udc09,\ud835\udc0d  for length, mass, time, current, temperature,   luminosity, and amount, respectively.   Base and derived SI units, with SI prefixes.  \u00b0  (degrees)     If you have been using the  SIUnits.jl    package, this is not unlike typing  using SIUnits.ShortUnits  with that package.", 
            "title": "Important note on namespaces"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "julia   1 u kg   ==   1000 u g               # Equivalence implies unit conversion  true  julia   ! ( 1 u kg   ===   1000 u g )           # ...and yet we can distinguish these...  true  julia   1 u kg   ===   1 u kg                # ...and these are indistinguishable.  true   In the next examples we assume we have brought some units into our namespace, e.g. using  m = u\"m\" , etc.  julia   uconvert ( \u00b0C ,   212 \u00b0F )  100//1 \u00b0C  julia   uconvert ( \u03bcm / ( m * \u00b0F ),   9 \u03bcm / ( m * \u00b0C ))  5//1 \u00b0F^-1 \u03bcm m^-1  julia   mod ( 1 hr + 3 minute + 5 s ,   24 s )  17//1 s   See  test/runtests.jl  for more usage examples.", 
            "title": "Usage examples"
        }, 
        {
            "location": "/highlights/", 
            "text": "Dispatch on dimensions\n\n\nConsider the following toy example, converting from voltage or power ratios to decibels:\n\n\njulia\n \ndB\n(\nnum\n::\nUnitful\n.\nVoltage\n,\n \nden\n::\nUnitful\n.\nVoltage\n)\n \n=\n \n20\n*\nlog10\n(\nnum\n/\nden\n)\n\n\n dB (generic function with 1 method)\n\n\n\njulia\n \ndB\n(\nnum\n::\nUnitful\n.\nPower\n,\n \nden\n::\nUnitful\n.\nPower\n)\n \n=\n \n10\n*\nlog10\n(\nnum\n/\nden\n)\n\n\n dB (generic function with 2 methods)\n\n\n\njulia\n \ndB\n(\n1\nu\nmV\n,\n \n1\nu\nV\n)\n\n\n-60.0\n\n\n\njulia\n \ndB\n(\n1\nu\nmW\n,\n \n1\nu\nW\n)\n\n\n-30.0\n\n\n\n\n\n\nWe don't currently implement dB as a unit because the log scale would require special treatment, but it is under consideration.\n\n\n\n\nDimensions in a type definition\n\n\nIt may be tempting to specify the dimensions of a quantity in a type definition, e.g.\n\n\ntype Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend\n\n\n\n\n\nHowever, these are abstract types. If performance is important, it may be better just to pick a concrete \nQuantity\n type:\n\n\ntype Person\n    height::typeof(1.0u\nm\n)\n    mass::typeof(1.0u\nkg\n)\nend\n\n\n\n\n\nYou can still create a \nPerson\n as \nPerson(5u\"ft\"+10u\"inch\", 75u\"kg\")\n; the unit conversion happens automatically.\n\n\n\n\nMaking new units and dimensions\n\n\nYou can make new units using the \n@unit\n macro on the fly:\n\n\njulia\n \n@unit\n \nyd5\n \nyd5\n \nFiveYards\n \n5\nu\nyd\n \nfalse\n\n\nyd5\n\n\n\n\n\n\n\n\nArrays\n\n\nPromotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from \n[1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"]\n). However, it could be useful in toy calculations for \ngeneral relativity\n where some conventions yield matrices with mixed dimensions:\n\n\njulia\n Diagonal([-1.0u\nc^2\n, 1.0, 1.0, 1.0])\n4\u00d74 Diagonal{Unitful.Quantity{Float64,D,U}}:\n -1.0 c^2   \u22c5    \u22c5    \u22c5\n       \u22c5   1.0   \u22c5    \u22c5\n       \u22c5    \u22c5   1.0   \u22c5\n       \u22c5    \u22c5    \u22c5   1.0\n\n\n\n\n\n\n\nUnits with rational exponents\n\n\njulia\n \n1.0\nu\nV/sqrt(Hz)\n\n\n1.0 Hz^-1/2 V\n\n\n\n\n\n\n\n\nExact conversions respected\n\n\njulia\n \nuconvert\n(\nu\nft\n,\n1\nu\ninch\n)\n\n\n1//12 ft", 
            "title": "Highlighted features"
        }, 
        {
            "location": "/highlights/#dispatch-on-dimensions", 
            "text": "Consider the following toy example, converting from voltage or power ratios to decibels:  julia   dB ( num :: Unitful . Voltage ,   den :: Unitful . Voltage )   =   20 * log10 ( num / den )   dB (generic function with 1 method)  julia   dB ( num :: Unitful . Power ,   den :: Unitful . Power )   =   10 * log10 ( num / den )   dB (generic function with 2 methods)  julia   dB ( 1 u mV ,   1 u V )  -60.0  julia   dB ( 1 u mW ,   1 u W )  -30.0   We don't currently implement dB as a unit because the log scale would require special treatment, but it is under consideration.", 
            "title": "Dispatch on dimensions"
        }, 
        {
            "location": "/highlights/#dimensions-in-a-type-definition", 
            "text": "It may be tempting to specify the dimensions of a quantity in a type definition, e.g.  type Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend  However, these are abstract types. If performance is important, it may be better just to pick a concrete  Quantity  type:  type Person\n    height::typeof(1.0u m )\n    mass::typeof(1.0u kg )\nend  You can still create a  Person  as  Person(5u\"ft\"+10u\"inch\", 75u\"kg\") ; the unit conversion happens automatically.", 
            "title": "Dimensions in a type definition"
        }, 
        {
            "location": "/highlights/#making-new-units-and-dimensions", 
            "text": "You can make new units using the  @unit  macro on the fly:  julia   @unit   yd5   yd5   FiveYards   5 u yd   false  yd5", 
            "title": "Making new units and dimensions"
        }, 
        {
            "location": "/highlights/#arrays", 
            "text": "Promotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from  [1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"] ). However, it could be useful in toy calculations for  general relativity  where some conventions yield matrices with mixed dimensions:  julia  Diagonal([-1.0u c^2 , 1.0, 1.0, 1.0])\n4\u00d74 Diagonal{Unitful.Quantity{Float64,D,U}}:\n -1.0 c^2   \u22c5    \u22c5    \u22c5\n       \u22c5   1.0   \u22c5    \u22c5\n       \u22c5    \u22c5   1.0   \u22c5\n       \u22c5    \u22c5    \u22c5   1.0", 
            "title": "Arrays"
        }, 
        {
            "location": "/highlights/#units-with-rational-exponents", 
            "text": "julia   1.0 u V/sqrt(Hz)  1.0 Hz^-1/2 V", 
            "title": "Units with rational exponents"
        }, 
        {
            "location": "/highlights/#exact-conversions-respected", 
            "text": "julia   uconvert ( u ft , 1 u inch )  1//12 ft", 
            "title": "Exact conversions respected"
        }, 
        {
            "location": "/types/", 
            "text": "Overview\n\n\nWe define a \nUnitful.Unit{U,D}\n type to represent a unit (\nU\n is a symbol, like \n:Meter\n, and \nD\n keeps track of dimensional information). Fields of a \nUnit\n object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g. \nnm\n or \nkm\n) may help to avoid overflow issues and general ugliness.\n\n\nUsually, the user interacts only with \nUnits\n objects, not \nUnit\n objects. This is because generically, more than one unit is needed to describe a quantity. An abstract type \nUnitful.Units{N,D}\n is defined, where \nN\n is always a tuple of \nUnit\n objects, and \nD\n is some type, like \ntypeof(Unitful.\ud835\udc0b)\n, where \n\ud835\udc0b\n is the object representing the length dimension (see \nUnitful.Dimensions{N}\n).\n\n\nSubtypes of \nUnitful.Units{N,D}\n are used to implement different behaviors for how to promote dimensioned quantities. The concrete subtypes have no fields and are therefore immutable singletons. Currently implemented subtypes of \nUnitful.Units{N,D}\n include \nUnitful.FreeUnits{N,D}\n, \nUnitful.ContextUnits{N,D,P}\n, and \nUnitful.FixedUnits{N,D}\n. Units defined in the Unitful.jl package itself are all \nUnitful.FreeUnits{N,D}\n objects.\n\n\nFinally, we define physical quantity types as \nQuantity{T\n:Number, D, U}\n, where \nD \n: Dimensions\n and \nU \n: Units\n. By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions: \nisa(1m, Length) == true\n. This works because \nLength\n is a type alias for some subset of \nUnitful.Quantity\n subtypes.\n\n\n\n\nAPI\n\n\n\n\nQuantities\n\n\n#\n\n\nUnitful.Quantity\n \n \nType\n.\n\n\nimmutable Quantity{T,D,U} \n: Number\n\n\n\n\n\nA quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.\n\n\nThe type parameter \nT\n represents the numeric backing type. The type parameters \nD \n:\n \nUnitful.Dimensions\n and \nU \n:\n \nUnitful.Units\n. Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.\n\n\nsource\n\n\n#\n\n\nUnitful.DimensionlessQuantity\n \n \nType\n.\n\n\nDimensionlessQuantity{T,U} = Quantity{T, Dimensions{()}, U}\n\n\n\n\n\nUseful for dispatching on \nUnitful.Quantity\n types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)\n\n\nExample:\n\n\njulia\n \nisa\n(\n1.0\nu\nmV/V\n,\n \nDimensionlessQuantity\n)\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n\n\nUnits and dimensions\n\n\n#\n\n\nUnitful.Unitlike\n \n \nType\n.\n\n\nabstract type Unitlike end\n\n\n\n\n\nRepresents units or dimensions. Dimensions are unit-like in the sense that they are not numbers but you can multiply or divide them and exponentiate by rationals.\n\n\nsource\n\n\n#\n\n\nUnitful.Units\n \n \nType\n.\n\n\nabstract type Units{N,D} \n: Unitlike end\n\n\n\n\n\nAbstract supertype of all units objects, which can differ in their implementation details.\n\n\nsource\n\n\n#\n\n\nUnitful.FreeUnits\n \n \nType\n.\n\n\nimmutable FreeUnits{N,D} \n: Units{N,D}\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. These behave like units have behaved in previous versions of Unitful, and provide a basic level of functionality that should be acceptable to most users. See \nBasic promotion mechanisms\n in the docs for details.\n\n\nExample: the unit \nm\n is actually a singleton of type \nUnitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),),typeof(\ud835\udc0b)\n. After dividing by \ns\n, a singleton of type \nUnitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1), Unitful.Unit{:Second,typeof(\ud835\udc13)}(0,-1//1,1.0,1//1)),typeof(\ud835\udc0b/\ud835\udc13)}\n is returned.\n\n\nsource\n\n\n#\n\n\nUnitful.ContextUnits\n \n \nType\n.\n\n\nimmutable ContextUnits{N,D,P} \n: Units{N,D}\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. It is in most respects like \nFreeUnits{N,D}\n, except that the type parameter \nP\n is again a \nFreeUnits{M,D}\n type that specifies a preferred unit for promotion. See \nAdvanced promotion mechanisms\n in the docs for details.\n\n\nsource\n\n\n#\n\n\nUnitful.FixedUnits\n \n \nType\n.\n\n\nimmutable FixedUnits{N,D} \n: Units{N,D} end\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. These are primarily intended for use when you would like to disable automatic unit conversions. See \nAdvanced promotion mechanisms\n in the docs for details.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimensions\n \n \nType\n.\n\n\nimmutable Dimensions{N} \n: Unitlike\n\n\n\n\n\nInstances of this object represent dimensions, possibly combinations thereof.\n\n\nsource\n\n\n#\n\n\nUnitful.Unit\n \n \nType\n.\n\n\nimmutable Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend\n\n\n\n\n\nDescription of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter \nU\n as a symbol, e.g. \n:Meter\n, \n:Second\n, \n:Gram\n, etc. The type parameter \nD\n contains dimension information, for instance \nUnit{:Meter, typeof(\ud835\udc0b)}\n or \nUnit{:Liter, typeof(\ud835\udc0b^3)}\n. Note that the dimension information refers to the unit, not powers of the unit.\n\n\nUnit{U,D}\n objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter \nN\n of a \nUnits{N,D}\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimension\n \n \nType\n.\n\n\nimmutable Dimension{D}\n    power::Rational{Int}\nend\n\n\n\n\n\nDescription of a dimension. The name of the dimension \nD\n is a symbol, e.g. \n:Length\n, \n:Time\n, \n:Mass\n, etc.\n\n\nDimension{D}\n objects are collected in a tuple, which is used for the type parameter \nN\n of a \nDimensions{N}\n object.\n\n\nsource", 
            "title": "Types"
        }, 
        {
            "location": "/types/#overview", 
            "text": "We define a  Unitful.Unit{U,D}  type to represent a unit ( U  is a symbol, like  :Meter , and  D  keeps track of dimensional information). Fields of a  Unit  object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g.  nm  or  km ) may help to avoid overflow issues and general ugliness.  Usually, the user interacts only with  Units  objects, not  Unit  objects. This is because generically, more than one unit is needed to describe a quantity. An abstract type  Unitful.Units{N,D}  is defined, where  N  is always a tuple of  Unit  objects, and  D  is some type, like  typeof(Unitful.\ud835\udc0b) , where  \ud835\udc0b  is the object representing the length dimension (see  Unitful.Dimensions{N} ).  Subtypes of  Unitful.Units{N,D}  are used to implement different behaviors for how to promote dimensioned quantities. The concrete subtypes have no fields and are therefore immutable singletons. Currently implemented subtypes of  Unitful.Units{N,D}  include  Unitful.FreeUnits{N,D} ,  Unitful.ContextUnits{N,D,P} , and  Unitful.FixedUnits{N,D} . Units defined in the Unitful.jl package itself are all  Unitful.FreeUnits{N,D}  objects.  Finally, we define physical quantity types as  Quantity{T :Number, D, U} , where  D  : Dimensions  and  U  : Units . By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions:  isa(1m, Length) == true . This works because  Length  is a type alias for some subset of  Unitful.Quantity  subtypes.", 
            "title": "Overview"
        }, 
        {
            "location": "/types/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/types/#quantities", 
            "text": "#  Unitful.Quantity     Type .  immutable Quantity{T,D,U}  : Number  A quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.  The type parameter  T  represents the numeric backing type. The type parameters  D  :   Unitful.Dimensions  and  U  :   Unitful.Units . Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.  source  #  Unitful.DimensionlessQuantity     Type .  DimensionlessQuantity{T,U} = Quantity{T, Dimensions{()}, U}  Useful for dispatching on  Unitful.Quantity  types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)  Example:  julia   isa ( 1.0 u mV/V ,   DimensionlessQuantity )  true   source", 
            "title": "Quantities"
        }, 
        {
            "location": "/types/#units-and-dimensions", 
            "text": "#  Unitful.Unitlike     Type .  abstract type Unitlike end  Represents units or dimensions. Dimensions are unit-like in the sense that they are not numbers but you can multiply or divide them and exponentiate by rationals.  source  #  Unitful.Units     Type .  abstract type Units{N,D}  : Unitlike end  Abstract supertype of all units objects, which can differ in their implementation details.  source  #  Unitful.FreeUnits     Type .  immutable FreeUnits{N,D}  : Units{N,D}  Instances of this object represent units, possibly combinations thereof. These behave like units have behaved in previous versions of Unitful, and provide a basic level of functionality that should be acceptable to most users. See  Basic promotion mechanisms  in the docs for details.  Example: the unit  m  is actually a singleton of type  Unitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),),typeof(\ud835\udc0b) . After dividing by  s , a singleton of type  Unitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1), Unitful.Unit{:Second,typeof(\ud835\udc13)}(0,-1//1,1.0,1//1)),typeof(\ud835\udc0b/\ud835\udc13)}  is returned.  source  #  Unitful.ContextUnits     Type .  immutable ContextUnits{N,D,P}  : Units{N,D}  Instances of this object represent units, possibly combinations thereof. It is in most respects like  FreeUnits{N,D} , except that the type parameter  P  is again a  FreeUnits{M,D}  type that specifies a preferred unit for promotion. See  Advanced promotion mechanisms  in the docs for details.  source  #  Unitful.FixedUnits     Type .  immutable FixedUnits{N,D}  : Units{N,D} end  Instances of this object represent units, possibly combinations thereof. These are primarily intended for use when you would like to disable automatic unit conversions. See  Advanced promotion mechanisms  in the docs for details.  source  #  Unitful.Dimensions     Type .  immutable Dimensions{N}  : Unitlike  Instances of this object represent dimensions, possibly combinations thereof.  source  #  Unitful.Unit     Type .  immutable Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend  Description of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter  U  as a symbol, e.g.  :Meter ,  :Second ,  :Gram , etc. The type parameter  D  contains dimension information, for instance  Unit{:Meter, typeof(\ud835\udc0b)}  or  Unit{:Liter, typeof(\ud835\udc0b^3)} . Note that the dimension information refers to the unit, not powers of the unit.  Unit{U,D}  objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter  N  of a  Units{N,D}  object.  source  #  Unitful.Dimension     Type .  immutable Dimension{D}\n    power::Rational{Int}\nend  Description of a dimension. The name of the dimension  D  is a symbol, e.g.  :Length ,  :Time ,  :Mass , etc.  Dimension{D}  objects are collected in a tuple, which is used for the type parameter  N  of a  Dimensions{N}  object.  source", 
            "title": "Units and dimensions"
        }, 
        {
            "location": "/newunits/", 
            "text": "Defining new units\n\n\nThe package automatically generates a useful set of units and dimensions in the \nUnitful\n module in \nsrc/pkgdefaults.jl\n.\n\n\nIf a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the \n@unit\n macro and the \nUnitful.register\n function, which makes units defined in a module available to the \n@u_str\n string macro.\n\n\nAn example of defining units in a module:\n\n\njulia\n \nmodule\n \nMyUnits\n;\n \nusing\n \nUnitful\n;\n \n@unit\n \nmyMeter\n \nm\n \nMyMeter\n \n1\nu\nm\n \nfalse\n;\n \nend\n\n\nMyUnits\n\n\n\njulia\n \nusing\n \nUnitful\n\n\n\njulia\n \nu\nmyMeter\n\n\nERROR: Symbol myMeter could not be found in registered unit modules.\n\n\n\njulia\n \nUnitful\n.\nregister\n(\nMyUnits\n)\n\n\n2-element Array{Module,1}:\n\n\n Unitful\n\n\n MyUnits\n\n\n\njulia\n \nu\nmyMeter\n\n\nm\n\n\n\n\n\n\nYou could have also called \nUnitful.register\n inside the \nMyUnits\n module; the choice is somewhat analogous to whether or not to export symbols from a module, although the symbols are never really exported, just made available to the \n@u_str\n macro. If you want to make a precompiled units package, rather than define a module at the REPL, see \nMaking your own units package\n.\n\n\nYou can also define units directly in the \nMain\n module at the REPL:\n\n\njulia\n \nusing\n \nUnitful\n\n\n\njulia\n \nUnitful\n.\nregister\n(\ncurrent_module\n());\n\n\n\njulia\n \n@unit\n \nM\n \nM\n \nMolar\n \n1\nu\nmol/L\n \ntrue\n;\n\n\n\njulia\n \n1\nu\nmM\n\n\n1 mM\n\n\n\n\n\n\nA note for the experts: Some care should be taken if explicitly creating \nUnitful.Units\n objects. The ordering of \nUnitful.Unit\n objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the \nUnits\n object will return a \"canonically sorted\" \nUnits\n object. Indeed, this is how we avoid ordering issues when multiplying quantities together.\n\n\n\n\nUseful functions and macros\n\n\n#\n\n\nUnitful.@dimension\n \n \nMacro\n.\n\n\nmacro dimension(symb, abbr, name)\n\n\n\n\n\nCreates new dimensions. \nname\n will be used like an identifier in the type parameter for a \nUnitful.Dimension\n object. \nsymb\n will be a symbol defined in the namespace from which this macro is called that is bound to a \nUnitful.Dimensions\n object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.\n\n\nThis macro extends \nUnitful.abbr\n to display the new dimension in an abbreviated format using the string \nabbr\n.\n\n\nType aliases are created that allow the user to dispatch on \nUnitful.Quantity\n and \nUnitful.Units\n objects of the newly defined dimension. The type alias for quantities is simply given by \nname\n, and the type alias for units is given by \nname*\"Units\"\n, e.g. \nLengthUnits\n. Note that there is also \nLengthFreeUnits\n, for example, which is an alias for dispatching on \nFreeUnits\n with length dimensions. The aliases are not exported.\n\n\nFinally, if you define new dimensions with \n@dimension\n you will need to specify a preferred unit for that dimension with \nUnitful.preferunits\n, otherwise promotion will not work with that dimension. This is done automatically in the \n@refunit\n macro.\n\n\nReturns the \nDimensions\n object to which \nsymb\n is bound.\n\n\nUsage example from \nsrc/pkgdefaults.jl\n: \n@dimension \ud835\udc0b \"\ud835\udc0b\" Length\n\n\nsource\n\n\n#\n\n\nUnitful.@derived_dimension\n \n \nMacro\n.\n\n\nmacro derived_dimension(name, dims)\n\n\n\n\n\nCreates type aliases to allow dispatch on \nUnitful.Quantity\n and \nUnitful.Units\n objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.\n\n\ndims\n is a \nUnitful.Dimensions\n object.\n\n\nReturns \nnothing\n.\n\n\nUsage examples:\n\n\n\n\n@derived_dimension Area \ud835\udc0b^2\n gives \nArea\n and \nAreaUnit\n type aliases\n\n\n@derived_dimension Speed \ud835\udc0b/\ud835\udc13\n gives \nSpeed\n and \nSpeedUnit\n type aliases\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.@refunit\n \n \nMacro\n.\n\n\nmacro refunit(symb, name, abbr, dimension, tf)\n\n\n\n\n\nDefine a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.\n\n\nThis macro extends \nUnitful.abbr\n so that the reference unit can be displayed in an abbreviated format. If \ntf == true\n, this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A \ndimension\n must be given (\nUnitful.Dimensions\n object) that specifies the dimension of the reference unit.\n\n\nIn principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using \n@dimension\n, then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.\n\n\nNote that this macro will also choose the new unit (no power-of-ten prefix) as the default unit for promotion given this dimension.\n\n\nReturns the \nUnitful.FreeUnits\n object to which \nsymb\n is bound.\n\n\nUsage example: \n@refunit m \"m\" Meter \ud835\udc0b true\n\n\nThis example, found in \nsrc/pkgdefaults.jl\n, generates \nkm\n, \nm\n, \ncm\n, ...\n\n\nsource\n\n\n#\n\n\nUnitful.@unit\n \n \nMacro\n.\n\n\nmacro unit(symb,abbr,name,equals,tf)\n\n\n\n\n\nDefine a unit. Rather than specifying a dimension like in \n@refunit\n, \nequals\n should be a \nUnitful.Quantity\n equal to one of the unit being defined. If \ntf == true\n, symbols will be made for each power-of-ten prefix.\n\n\nReturns the \nUnitful.FreeUnits\n object to which \nsymb\n is bound.\n\n\nUsage example: \n@unit mi \"mi\" Mile (201168//125)*m false\n\n\nThis example will \nnot\n generate \nkmi\n (kilomiles).\n\n\nsource\n\n\n#\n\n\nUnitful.offsettemp\n \n \nFunction\n.\n\n\noffsettemp(::Unit)\n\n\n\n\n\nFor temperature units, this function is used to set the scale offset.\n\n\nsource\n\n\n\n\nInternals\n\n\n#\n\n\nUnitful.@prefixed_unit_symbols\n \n \nMacro\n.\n\n\nmacro prefixed_unit_symbols(symb,name,dimension,basefactor)\n\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.\n\n\nExample: \n@prefixed_unit_symbols m Meter \ud835\udc0b (1.0,1)\n results in nm, cm, m, km, ... all getting defined in the calling namespace.\n\n\nsource\n\n\n#\n\n\nUnitful.@unit_symbols\n \n \nMacro\n.\n\n\nmacro unit_symbols(symb,name)\n\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.\n\n\nExample: \n@unit_symbols ft Foot \ud835\udc0b\n results in \nft\n getting defined but not \nkft\n.\n\n\nsource\n\n\n#\n\n\nUnitful.basefactor\n \n \nFunction\n.\n\n\nbasefactor(x::Unit)\n\n\n\n\n\nSpecifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.\n\n\nsource", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#defining-new-units", 
            "text": "The package automatically generates a useful set of units and dimensions in the  Unitful  module in  src/pkgdefaults.jl .  If a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the  @unit  macro and the  Unitful.register  function, which makes units defined in a module available to the  @u_str  string macro.  An example of defining units in a module:  julia   module   MyUnits ;   using   Unitful ;   @unit   myMeter   m   MyMeter   1 u m   false ;   end  MyUnits  julia   using   Unitful  julia   u myMeter  ERROR: Symbol myMeter could not be found in registered unit modules.  julia   Unitful . register ( MyUnits )  2-element Array{Module,1}:   Unitful   MyUnits  julia   u myMeter  m   You could have also called  Unitful.register  inside the  MyUnits  module; the choice is somewhat analogous to whether or not to export symbols from a module, although the symbols are never really exported, just made available to the  @u_str  macro. If you want to make a precompiled units package, rather than define a module at the REPL, see  Making your own units package .  You can also define units directly in the  Main  module at the REPL:  julia   using   Unitful  julia   Unitful . register ( current_module ());  julia   @unit   M   M   Molar   1 u mol/L   true ;  julia   1 u mM  1 mM   A note for the experts: Some care should be taken if explicitly creating  Unitful.Units  objects. The ordering of  Unitful.Unit  objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the  Units  object will return a \"canonically sorted\"  Units  object. Indeed, this is how we avoid ordering issues when multiplying quantities together.", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#useful-functions-and-macros", 
            "text": "#  Unitful.@dimension     Macro .  macro dimension(symb, abbr, name)  Creates new dimensions.  name  will be used like an identifier in the type parameter for a  Unitful.Dimension  object.  symb  will be a symbol defined in the namespace from which this macro is called that is bound to a  Unitful.Dimensions  object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.  This macro extends  Unitful.abbr  to display the new dimension in an abbreviated format using the string  abbr .  Type aliases are created that allow the user to dispatch on  Unitful.Quantity  and  Unitful.Units  objects of the newly defined dimension. The type alias for quantities is simply given by  name , and the type alias for units is given by  name*\"Units\" , e.g.  LengthUnits . Note that there is also  LengthFreeUnits , for example, which is an alias for dispatching on  FreeUnits  with length dimensions. The aliases are not exported.  Finally, if you define new dimensions with  @dimension  you will need to specify a preferred unit for that dimension with  Unitful.preferunits , otherwise promotion will not work with that dimension. This is done automatically in the  @refunit  macro.  Returns the  Dimensions  object to which  symb  is bound.  Usage example from  src/pkgdefaults.jl :  @dimension \ud835\udc0b \"\ud835\udc0b\" Length  source  #  Unitful.@derived_dimension     Macro .  macro derived_dimension(name, dims)  Creates type aliases to allow dispatch on  Unitful.Quantity  and  Unitful.Units  objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.  dims  is a  Unitful.Dimensions  object.  Returns  nothing .  Usage examples:   @derived_dimension Area \ud835\udc0b^2  gives  Area  and  AreaUnit  type aliases  @derived_dimension Speed \ud835\udc0b/\ud835\udc13  gives  Speed  and  SpeedUnit  type aliases   source  #  Unitful.@refunit     Macro .  macro refunit(symb, name, abbr, dimension, tf)  Define a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.  This macro extends  Unitful.abbr  so that the reference unit can be displayed in an abbreviated format. If  tf == true , this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A  dimension  must be given ( Unitful.Dimensions  object) that specifies the dimension of the reference unit.  In principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using  @dimension , then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.  Note that this macro will also choose the new unit (no power-of-ten prefix) as the default unit for promotion given this dimension.  Returns the  Unitful.FreeUnits  object to which  symb  is bound.  Usage example:  @refunit m \"m\" Meter \ud835\udc0b true  This example, found in  src/pkgdefaults.jl , generates  km ,  m ,  cm , ...  source  #  Unitful.@unit     Macro .  macro unit(symb,abbr,name,equals,tf)  Define a unit. Rather than specifying a dimension like in  @refunit ,  equals  should be a  Unitful.Quantity  equal to one of the unit being defined. If  tf == true , symbols will be made for each power-of-ten prefix.  Returns the  Unitful.FreeUnits  object to which  symb  is bound.  Usage example:  @unit mi \"mi\" Mile (201168//125)*m false  This example will  not  generate  kmi  (kilomiles).  source  #  Unitful.offsettemp     Function .  offsettemp(::Unit)  For temperature units, this function is used to set the scale offset.  source", 
            "title": "Useful functions and macros"
        }, 
        {
            "location": "/newunits/#internals", 
            "text": "#  Unitful.@prefixed_unit_symbols     Macro .  macro prefixed_unit_symbols(symb,name,dimension,basefactor)  Not called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.  Example:  @prefixed_unit_symbols m Meter \ud835\udc0b (1.0,1)  results in nm, cm, m, km, ... all getting defined in the calling namespace.  source  #  Unitful.@unit_symbols     Macro .  macro unit_symbols(symb,name)  Not called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.  Example:  @unit_symbols ft Foot \ud835\udc0b  results in  ft  getting defined but not  kft .  source  #  Unitful.basefactor     Function .  basefactor(x::Unit)  Specifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.  source", 
            "title": "Internals"
        }, 
        {
            "location": "/conversion/", 
            "text": "Converting between units\n\n\nSince \nconvert\n in Julia already means something specific (conversion between Julia types), we define \nuconvert\n for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.\n\n\nExact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.\n\n\n#\n\n\nUnitful.uconvert\n \n \nFunction\n.\n\n\nuconvert{T,D,U}(a::Units, x::Quantity{T,D,U})\n\n\n\n\n\nConvert a \nUnitful.Quantity\n to different units. The conversion will fail if the target units \na\n have a different dimension than the dimension of the quantity \nx\n. You can use this method to switch between equivalent representations of the same unit, like \nN m\n and \nJ\n.\n\n\nExample:\n\n\njulia\n \nuconvert\n(\nu\nhr\n,\n3602\nu\ns\n)\n\n\n1801//1800 hr\n\n\njulia\n \nuconvert\n(\nu\nJ\n,\n1.0\nu\nN*m\n)\n\n\n1.0 J\n\n\n\n\n\n\nsource\n\n\nuconvert{T,D,U}(a::Units, x::Quantity{T,typeof(\ud835\udeaf),\n:TemperatureUnits})\n\n\n\n\n\nIn this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions.\n\n\nsource\n\n\nSince objects are callable, we can also make \nUnitful.Units\n callable with a \nNumber\n as an argument, for a unit conversion shorthand:\n\n\njulia\n \nu\ncm\n(\n1\nu\nm\n)\n\n\n100//1 cm\n\n\n\n\n\n\nThis syntax is a little confusing, but becomes appealing with the function chaining operator \n|\n:\n\n\njulia\n \n1\nu\nm\n \n|\n \nu\ncm\n\n\n100//1 cm\n\n\n\n\n\n\nNote that since \nUnitful.Units\n objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling \nuconvert\n.\n\n\n\n\nDimensionless quantities\n\n\nFor dimensionless quantities, \nuconvert\n can be used to strip the units without losing power-of-ten information:\n\n\njulia\n \nuconvert\n(\nUnitful\n.\nNoUnits\n,\n \n1.0\nu\n\u03bcm/m\n)\n\n\n1.0e-6\n\n\n\njulia\n \nuconvert\n(\nUnitful\n.\nNoUnits\n,\n \n1.0\nu\nm\n)\n\n\nERROR: DimensionError:  and m are not dimensionally compatible.\n\n\n\n\n\n\nYou can also directly convert to a subtype of \nReal\n or \nComplex\n:\n\n\njulia\n \nFloat64\n(\n1.0\nu\n\u03bcm/m\n)\n\n\n1.0e-6\n\n\n\n\n\n\n\n\nTemperature conversion\n\n\nIf the dimension of a \nQuantity\n is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature \nintervals\n.\n\n\njulia\n \nuconvert\n(\nu\nK\n,\n \n21.0\nu\n\u00b0C\n)\n\n\n294.15 K\n\n\n\n\n\n\n\n\nBasic promotion mechanisms\n\n\nWe decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance.\n\n\nIf two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.\n\n\n\n\nPromotion rules for specific dimensions\n\n\nYou can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session, specifically \nbefore\n \nupreferred\n \nhas been called or quantities have been promoted\n. For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in \ng*cm^2/s^2\n. This is accomplished by defining a \nUnitful.promote_unit\n method for the units themselves. Here's an example.\n\n\njulia\n \nusing\n \nUnitful\n\n\n\njulia\n \nUnitful\n.\npromote_unit\n{\nS\n:\nUnitful\n.\nEnergyUnits\n,\n \nT\n:\nUnitful\n.\nEnergyUnits\n}(\n::\nS\n,\n \n::\nT\n)\n \n=\n \nu\ng*cm^2/s^2\n\n\n\njulia\n \npromote\n(\n2.0\nu\nJ\n,\n \n1.0\nu\nkg*m^2/s^2\n)\n\n\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)\n\n\n\njulia\n \nUnitful\n.\npromote_unit\n{\nS\n:\nUnitful\n.\nEnergyUnits\n,\n \nT\n:\nUnitful\n.\nEnergyUnits\n}(\n::\nS\n,\n \n::\nT\n)\n \n=\n \nu\nJ\n\n\n\njulia\n \npromote\n(\n2.0\nu\nJ\n,\n \n1.0\nu\nkg*m^2/s^2\n)\n\n\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)\n\n\n\n\n\n\nNotice how the first definition of \nBase.promote_rule\n had a permanent effect. This is true of promotion rules for types defined in Base too; try defining a new promotion rule for \nInt\n and \nFloat64\n and you'll see it has no effect.\n\n\nIf you're wondering where \nUnitful.EnergyUnit\n comes from, it is defined in \nsrc/pkgdefaults.jl\n by the \n@derived_dimension\n macro. Similarly, the calls to the \n@dimension\n macro define \nUnitful.LengthUnit\n, \nUnitful.MassUnit\n, etc. None of these are exported.\n\n\nExisting users of Unitful may want to call \nUnitful.promote_to_derived\n after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default.\n\n\n#\n\n\nUnitful.promote_to_derived\n \n \nFunction\n.\n\n\nUnitful.promote_to_derived()\n\n\n\n\n\nDefines promotion rules to use derived SI units in promotion for common dimensions of quantities:\n\n\n\n\nJ\n (joule) for energy\n\n\nN\n (newton) for force\n\n\nW\n (watt) for power\n\n\nPa\n (pascal) for pressure\n\n\nC\n (coulomb) for charge\n\n\nV\n (volt) for voltage\n\n\n\u03a9\n (ohm) for resistance\n\n\nF\n (farad) for capacitance\n\n\nH\n (henry) for inductance\n\n\nWb\n (weber) for magnetic flux\n\n\nT\n (tesla) for B-field\n\n\nJ*s\n (joule-second) for action\n\n\n\n\nIf you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your \n.juliarc.jl\n file which is loaded when you open Julia. This function is not exported.\n\n\nsource\n\n\n\n\nFallback promotion rules\n\n\nThe \nUnitful.preferunits\n function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.\n\n\nThe default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension \n\ud835\udc0c*\ud835\udc0b^2/(\ud835\udc13^2*\ud835\udeaf)\n would be converted to \nkg*m^2/(s^2*K)\n:\n\n\njulia\n \npromote\n(\n1.0\nu\nJ/K\n,\n \n1.0\nu\ng*cm^2/s^2/K\n)\n\n\n(1.0 kg K^-1 m^2 s^-2, 1.0e-7 kg K^-1 m^2 s^-2)\n\n\n\n\n\n\nYou can however override this behavior by calling \nUnitful.preferunits\n at the start of a Julia session, specifically \nbefore\n \nupreferred\n \nhas been called or quantities have been promoted\n.\n\n\n#\n\n\nUnitful.preferunits\n \n \nFunction\n.\n\n\nfunction\n \npreferunits\n(\nu0\n::\nUnits\n,\n \nu\n::\nUnits\n...)\n\n\n\n\n\n\nThis function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like \ud835\udc0b or \ud835\udc13 but not \ud835\udc0b/\ud835\udc13 or \ud835\udc0b^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user.\n\n\nOnce \nUnitful.upreferred\n has been called or quantities have been promoted, this function will appear to have no effect.\n\n\nUsage example: \npreferunits(u\"m,s,A,K,cd,kg,mol\"...)\n\n\nsource\n\n\n\n\nArray promotion\n\n\nArrays are typed with as much specificity as possible upon creation. consider the following three cases:\n\n\njulia\n \n[\n1.0\nu\nm\n,\n \n2.0\nu\nm\n]\n\n\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n\n\n 1.0 m\n\n\n 2.0 m\n\n\n\njulia\n \n[\n1.0\nu\nm\n,\n \n2.0\nu\ncm\n]\n\n\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n\n\n  1.0 m\n\n\n 0.02 m\n\n\n\njulia\n \n[\n1.0\nu\nm\n,\n \n2.0\n]\n\n\n2-element Array{Unitful.Quantity{Float64,D,U} where U where D,1}:\n\n\n 1.0 m\n\n\n   2.0\n\n\n\n\n\n\nIn the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:\n\n\njulia\n \nf\n{\nT\n:\nUnitful\n.\nLength\n}(\nx\n::\nAbstractArray\n{\nT\n})\n \n=\n \nsum\n(\nx\n)\n\n\nf (generic function with 1 method)\n\n\n\njulia\n \nf\n([\n1.0\nu\nm\n,\n \n2.0\nu\ncm\n])\n\n\n1.02 m\n\n\n\njulia\n \nf\n([\n1.0\nu\ng\n,\n \n2.0\nu\ncm\n])\n\n\nERROR: MethodError: no method matching f(::Array{Unitful.Quantity{Float64,D,U} where U where D,1})\n\n\n\n\n\n\n\n\nAdvanced promotion mechanisms\n\n\nThere are some new types as of Unitful.jl v0.2.0 that enable some fairly sophisticated promotion logic. Three concrete subtypes of \nUnitful.Units{N,D}\n are defined: \nUnitful.FreeUnits{N,D}\n, \nUnitful.ContextUnits{N,D,P}\n, and \nUnitful.FixedUnits{N,D}\n.\n\n\nUnits defined in the Unitful.jl package itself are all \nUnitful.FreeUnits{N,D}\n objects. The \"free\" in \nFreeUnits\n indicates that the object carries no information on its own about how it should respond during promotion. Other code in Unitful dictates that by default, quantities should promote to SI units. \nFreeUnits\n use the promotion mechanisms described in the above section, \nBasic promotion mechanisms\n. They used to be called \nUnits\n in prior versions of Unitful.\n\n\n\n\nContextUnits\n\n\nSometimes, a package may want to default to a particular behavior for promotion, in the presence of other packages that may require differing default behaviors. An example would be a CAD package for nanoscale device design: it makes more sense to promote to nanometers or microns than to meters. For this purpose we define \nUnitful.ContextUnits{N,D,P}\n. The \nP\n in this type signature should be some type \nUnitful.FreeUnits{M,D}\n (the dimensions must be the same). We refer to this as the \"context.\" \nContextUnits\n may be easily instantiated by e.g. \nContextUnits(nm, \u03bcm)\n for a \nnm\n unit that will promote to \n\u03bcm\n. Here's an example:\n\n\njulia\n \n\u03bcm\n \n=\n \nUnitful\n.\nContextUnits\n(\nu\n\u03bcm\n,\n \nu\n\u03bcm\n)\n\n\n\u03bcm\n\n\n\njulia\n \nnm\n \n=\n \nUnitful\n.\nContextUnits\n(\nu\nnm\n,\n \nu\n\u03bcm\n)\n\n\nnm\n\n\n\njulia\n \n1.0\n\u03bcm\n \n+\n \n1.0\nnm\n\n\n1.001 \u03bcm\n\n\n\n\n\n\nIf the context does not agree, then we fall back to \nFreeUnits\n:\n\n\njulia\n \n\u03bcm\n \n=\n \nUnitful\n.\nContextUnits\n(\nu\n\u03bcm\n,\n \nu\n\u03bcm\n)\n\n\n\u03bcm\n\n\n\njulia\n \nnm\n \n=\n \nUnitful\n.\nContextUnits\n(\nu\nnm\n,\n \nu\ncm\n)\n\n\nnm\n\n\n\njulia\n \n1.0\n\u03bcm\n \n+\n \n1.0\nnm\n\n\n1.001e-6 m\n\n\n\n\n\n\nMultiplying a \nContextUnits\n by a \nFreeUnits\n yields a \nContextUnits\n object, with the preferred units for the additional dimensions being determined by calling \nupreferred\n on the \nFreeUnits\n object:\n\n\njulia\n \nmm\n \n=\n \nUnitful\n.\nContextUnits\n(\nu\nmm\n,\n \nu\n\u03bcm\n)\n\n\nmm\n\n\n\njulia\n \nisa\n(\nu\ng\n,\n \nUnitful\n.\nFreeUnits\n)\n\n\ntrue\n\n\n\njulia\n \nupreferred\n(\nu\ng\n)\n\n\nkg\n\n\n\njulia\n \nmm\n*\nu\ng\n\n\ng mm\n\n\n\njulia\n \nisa\n(\nmm\n*\nu\ng\n,\n \nUnitful\n.\nContextUnits\n)\n\n\ntrue\n\n\n\njulia\n \nupreferred\n(\nmm\n*\nu\ng\n)\n\n\nkg \u03bcm\n\n\n\n\n\n\n\n\nFixedUnits\n\n\nSometimes, there may be times where it is required to disable automatic conversion between quantities with different units. For this purpose there are \nUnitful.FixedUnits{N,D}\n. Trying to add or compare two quantities with \nFixedUnits\n will throw an error, provided the units are not the same. Note that you can still add/compare a quantity with \nFixedUnits\n to a quantity with another kind of units; in that case, the result units (if applicable) are determined by the \nFixedUnits\n, overriding the preferred units from \nContextUnits\n or \nFreeUnits\n. Multiplying \nFixedUnits\n with any other kind of units returns \nFixedUnits\n:\n\n\njulia\n \nmm_fix\n \n=\n \nUnitful\n.\nFixedUnits\n(\nu\nmm\n)\n\n\nmm\n\n\n\njulia\n \ncm_fix\n \n=\n \nUnitful\n.\nFixedUnits\n(\nu\ncm\n)\n\n\ncm\n\n\n\njulia\n \n1\nmm_fix\n+\n2\nmm_fix\n\n\n3 mm\n\n\n\njulia\n \n1\nmm_fix\n+\n2\nu\ncm\n  \n# u\ncm\n is a FreeUnits object.\n\n\n21//1 mm\n\n\n\njulia\n \n1\nmm_fix\n+\n2\n*\nUnitful\n.\nContextUnits\n(\nu\ncm\n,\n \nu\ncm\n)\n\n\n21//1 mm\n\n\n\njulia\n \nisa\n(\nmm_fix\n*\nu\ncm\n,\n \nUnitful\n.\nFixedUnits\n)\n\n\ntrue\n\n\n\njulia\n \n1\nmm_fix\n+\n2\ncm_fix\n\n\nERROR: automatic conversion prohibited.\n\n\n[...]\n\n\n\njulia\n \n1\nmm_fix\n \n==\n \n1\nmm_fix\n\n\ntrue\n\n\n\njulia\n \n1\nmm_fix\n \n==\n \n0.1\nu\ncm\n\n\ntrue\n\n\n\njulia\n \n1\nmm_fix\n \n==\n \n0.1\ncm_fix\n\n\nERROR: automatic conversion prohibited.\n\n\n[...]\n\n\n\n\n\n\nMuch of this functionality is enabled by \npromote_unit\n definitions. These are not readily extensible by the user at this point.\n\n\n#\n\n\nUnitful.promote_unit\n \n \nFunction\n.\n\n\nfunction\n \npromote_unit\n(\n::\nUnits\n,\n \n::\nUnits\n...)\n\n\n\n\n\n\nGiven \nUnits\n objects as arguments, this function returns a \nUnits\n object appropriate for the result of promoting quantities which have these units. This function is kind of like \npromote_rule\n, except that it doesn't take types. It also does not return a tuple, but rather just a \nUnitful.Units\n object (or it throws an error).\n\n\nAlthough we had used \npromote_rule\n for \nUnits\n objects in prior versions of Unitful, this was always kind of a hack; it doesn't make sense to promote units directly for a variety of reasons.\n\n\nsource\n\n\n\n\nUnit cancellation\n\n\nFor multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance, \nmV/V\n is not simplified, although \nV/V\n is. Also, \nN*m/J\n is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Conversion / promotion"
        }, 
        {
            "location": "/conversion/#converting-between-units", 
            "text": "Since  convert  in Julia already means something specific (conversion between Julia types), we define  uconvert  for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.  Exact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.  #  Unitful.uconvert     Function .  uconvert{T,D,U}(a::Units, x::Quantity{T,D,U})  Convert a  Unitful.Quantity  to different units. The conversion will fail if the target units  a  have a different dimension than the dimension of the quantity  x . You can use this method to switch between equivalent representations of the same unit, like  N m  and  J .  Example:  julia   uconvert ( u hr , 3602 u s )  1801//1800 hr  julia   uconvert ( u J , 1.0 u N*m )  1.0 J   source  uconvert{T,D,U}(a::Units, x::Quantity{T,typeof(\ud835\udeaf), :TemperatureUnits})  In this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions.  source  Since objects are callable, we can also make  Unitful.Units  callable with a  Number  as an argument, for a unit conversion shorthand:  julia   u cm ( 1 u m )  100//1 cm   This syntax is a little confusing, but becomes appealing with the function chaining operator  | :  julia   1 u m   |   u cm  100//1 cm   Note that since  Unitful.Units  objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling  uconvert .", 
            "title": "Converting between units"
        }, 
        {
            "location": "/conversion/#dimensionless-quantities", 
            "text": "For dimensionless quantities,  uconvert  can be used to strip the units without losing power-of-ten information:  julia   uconvert ( Unitful . NoUnits ,   1.0 u \u03bcm/m )  1.0e-6  julia   uconvert ( Unitful . NoUnits ,   1.0 u m )  ERROR: DimensionError:  and m are not dimensionally compatible.   You can also directly convert to a subtype of  Real  or  Complex :  julia   Float64 ( 1.0 u \u03bcm/m )  1.0e-6", 
            "title": "Dimensionless quantities"
        }, 
        {
            "location": "/conversion/#temperature-conversion", 
            "text": "If the dimension of a  Quantity  is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature  intervals .  julia   uconvert ( u K ,   21.0 u \u00b0C )  294.15 K", 
            "title": "Temperature conversion"
        }, 
        {
            "location": "/conversion/#basic-promotion-mechanisms", 
            "text": "We decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance.  If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.", 
            "title": "Basic promotion mechanisms"
        }, 
        {
            "location": "/conversion/#promotion-rules-for-specific-dimensions", 
            "text": "You can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session, specifically  before   upreferred   has been called or quantities have been promoted . For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in  g*cm^2/s^2 . This is accomplished by defining a  Unitful.promote_unit  method for the units themselves. Here's an example.  julia   using   Unitful  julia   Unitful . promote_unit { S : Unitful . EnergyUnits ,   T : Unitful . EnergyUnits }( :: S ,   :: T )   =   u g*cm^2/s^2  julia   promote ( 2.0 u J ,   1.0 u kg*m^2/s^2 )  (2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)  julia   Unitful . promote_unit { S : Unitful . EnergyUnits ,   T : Unitful . EnergyUnits }( :: S ,   :: T )   =   u J  julia   promote ( 2.0 u J ,   1.0 u kg*m^2/s^2 )  (2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)   Notice how the first definition of  Base.promote_rule  had a permanent effect. This is true of promotion rules for types defined in Base too; try defining a new promotion rule for  Int  and  Float64  and you'll see it has no effect.  If you're wondering where  Unitful.EnergyUnit  comes from, it is defined in  src/pkgdefaults.jl  by the  @derived_dimension  macro. Similarly, the calls to the  @dimension  macro define  Unitful.LengthUnit ,  Unitful.MassUnit , etc. None of these are exported.  Existing users of Unitful may want to call  Unitful.promote_to_derived  after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default.  #  Unitful.promote_to_derived     Function .  Unitful.promote_to_derived()  Defines promotion rules to use derived SI units in promotion for common dimensions of quantities:   J  (joule) for energy  N  (newton) for force  W  (watt) for power  Pa  (pascal) for pressure  C  (coulomb) for charge  V  (volt) for voltage  \u03a9  (ohm) for resistance  F  (farad) for capacitance  H  (henry) for inductance  Wb  (weber) for magnetic flux  T  (tesla) for B-field  J*s  (joule-second) for action   If you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your  .juliarc.jl  file which is loaded when you open Julia. This function is not exported.  source", 
            "title": "Promotion rules for specific dimensions"
        }, 
        {
            "location": "/conversion/#fallback-promotion-rules", 
            "text": "The  Unitful.preferunits  function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.  The default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension  \ud835\udc0c*\ud835\udc0b^2/(\ud835\udc13^2*\ud835\udeaf)  would be converted to  kg*m^2/(s^2*K) :  julia   promote ( 1.0 u J/K ,   1.0 u g*cm^2/s^2/K )  (1.0 kg K^-1 m^2 s^-2, 1.0e-7 kg K^-1 m^2 s^-2)   You can however override this behavior by calling  Unitful.preferunits  at the start of a Julia session, specifically  before   upreferred   has been called or quantities have been promoted .  #  Unitful.preferunits     Function .  function   preferunits ( u0 :: Units ,   u :: Units ...)   This function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like \ud835\udc0b or \ud835\udc13 but not \ud835\udc0b/\ud835\udc13 or \ud835\udc0b^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user.  Once  Unitful.upreferred  has been called or quantities have been promoted, this function will appear to have no effect.  Usage example:  preferunits(u\"m,s,A,K,cd,kg,mol\"...)  source", 
            "title": "Fallback promotion rules"
        }, 
        {
            "location": "/conversion/#array-promotion", 
            "text": "Arrays are typed with as much specificity as possible upon creation. consider the following three cases:  julia   [ 1.0 u m ,   2.0 u m ]  2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:   1.0 m   2.0 m  julia   [ 1.0 u m ,   2.0 u cm ]  2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:    1.0 m   0.02 m  julia   [ 1.0 u m ,   2.0 ]  2-element Array{Unitful.Quantity{Float64,D,U} where U where D,1}:   1.0 m     2.0   In the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:  julia   f { T : Unitful . Length }( x :: AbstractArray { T })   =   sum ( x )  f (generic function with 1 method)  julia   f ([ 1.0 u m ,   2.0 u cm ])  1.02 m  julia   f ([ 1.0 u g ,   2.0 u cm ])  ERROR: MethodError: no method matching f(::Array{Unitful.Quantity{Float64,D,U} where U where D,1})", 
            "title": "Array promotion"
        }, 
        {
            "location": "/conversion/#advanced-promotion-mechanisms", 
            "text": "There are some new types as of Unitful.jl v0.2.0 that enable some fairly sophisticated promotion logic. Three concrete subtypes of  Unitful.Units{N,D}  are defined:  Unitful.FreeUnits{N,D} ,  Unitful.ContextUnits{N,D,P} , and  Unitful.FixedUnits{N,D} .  Units defined in the Unitful.jl package itself are all  Unitful.FreeUnits{N,D}  objects. The \"free\" in  FreeUnits  indicates that the object carries no information on its own about how it should respond during promotion. Other code in Unitful dictates that by default, quantities should promote to SI units.  FreeUnits  use the promotion mechanisms described in the above section,  Basic promotion mechanisms . They used to be called  Units  in prior versions of Unitful.", 
            "title": "Advanced promotion mechanisms"
        }, 
        {
            "location": "/conversion/#contextunits", 
            "text": "Sometimes, a package may want to default to a particular behavior for promotion, in the presence of other packages that may require differing default behaviors. An example would be a CAD package for nanoscale device design: it makes more sense to promote to nanometers or microns than to meters. For this purpose we define  Unitful.ContextUnits{N,D,P} . The  P  in this type signature should be some type  Unitful.FreeUnits{M,D}  (the dimensions must be the same). We refer to this as the \"context.\"  ContextUnits  may be easily instantiated by e.g.  ContextUnits(nm, \u03bcm)  for a  nm  unit that will promote to  \u03bcm . Here's an example:  julia   \u03bcm   =   Unitful . ContextUnits ( u \u03bcm ,   u \u03bcm )  \u03bcm  julia   nm   =   Unitful . ContextUnits ( u nm ,   u \u03bcm )  nm  julia   1.0 \u03bcm   +   1.0 nm  1.001 \u03bcm   If the context does not agree, then we fall back to  FreeUnits :  julia   \u03bcm   =   Unitful . ContextUnits ( u \u03bcm ,   u \u03bcm )  \u03bcm  julia   nm   =   Unitful . ContextUnits ( u nm ,   u cm )  nm  julia   1.0 \u03bcm   +   1.0 nm  1.001e-6 m   Multiplying a  ContextUnits  by a  FreeUnits  yields a  ContextUnits  object, with the preferred units for the additional dimensions being determined by calling  upreferred  on the  FreeUnits  object:  julia   mm   =   Unitful . ContextUnits ( u mm ,   u \u03bcm )  mm  julia   isa ( u g ,   Unitful . FreeUnits )  true  julia   upreferred ( u g )  kg  julia   mm * u g  g mm  julia   isa ( mm * u g ,   Unitful . ContextUnits )  true  julia   upreferred ( mm * u g )  kg \u03bcm", 
            "title": "ContextUnits"
        }, 
        {
            "location": "/conversion/#fixedunits", 
            "text": "Sometimes, there may be times where it is required to disable automatic conversion between quantities with different units. For this purpose there are  Unitful.FixedUnits{N,D} . Trying to add or compare two quantities with  FixedUnits  will throw an error, provided the units are not the same. Note that you can still add/compare a quantity with  FixedUnits  to a quantity with another kind of units; in that case, the result units (if applicable) are determined by the  FixedUnits , overriding the preferred units from  ContextUnits  or  FreeUnits . Multiplying  FixedUnits  with any other kind of units returns  FixedUnits :  julia   mm_fix   =   Unitful . FixedUnits ( u mm )  mm  julia   cm_fix   =   Unitful . FixedUnits ( u cm )  cm  julia   1 mm_fix + 2 mm_fix  3 mm  julia   1 mm_fix + 2 u cm    # u cm  is a FreeUnits object.  21//1 mm  julia   1 mm_fix + 2 * Unitful . ContextUnits ( u cm ,   u cm )  21//1 mm  julia   isa ( mm_fix * u cm ,   Unitful . FixedUnits )  true  julia   1 mm_fix + 2 cm_fix  ERROR: automatic conversion prohibited.  [...]  julia   1 mm_fix   ==   1 mm_fix  true  julia   1 mm_fix   ==   0.1 u cm  true  julia   1 mm_fix   ==   0.1 cm_fix  ERROR: automatic conversion prohibited.  [...]   Much of this functionality is enabled by  promote_unit  definitions. These are not readily extensible by the user at this point.  #  Unitful.promote_unit     Function .  function   promote_unit ( :: Units ,   :: Units ...)   Given  Units  objects as arguments, this function returns a  Units  object appropriate for the result of promoting quantities which have these units. This function is kind of like  promote_rule , except that it doesn't take types. It also does not return a tuple, but rather just a  Unitful.Units  object (or it throws an error).  Although we had used  promote_rule  for  Units  objects in prior versions of Unitful, this was always kind of a hack; it doesn't make sense to promote units directly for a variety of reasons.  source", 
            "title": "FixedUnits"
        }, 
        {
            "location": "/conversion/#unit-cancellation", 
            "text": "For multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance,  mV/V  is not simplified, although  V/V  is. Also,  N*m/J  is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Unit cancellation"
        }, 
        {
            "location": "/manipulations/", 
            "text": "Unitful string macro\n\n\n#\n\n\nUnitful.@u_str\n \n \nMacro\n.\n\n\nmacro u_str(unit)\n\n\n\n\n\nString macro to easily recall units, dimensions, or quantities defined in unit modules that have been registered with \nUnitful.register\n.\n\n\nIf the same symbol is used for a \nUnitful.Units\n object defined in different modules, then the symbol found in the most recently registered module will be used.\n\n\nNote that what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".\n\n\nExamples:\n\n\njulia\n \n1.0\nu\nm/s\n\n\n1.0 m s^-1\n\n\n\njulia\n \n1.0\nu\nN*m\n\n\n1.0 m N\n\n\n\njulia\n \nu\nm,kg,s\n\n\n(m, kg, s)\n\n\n\njulia\n \ntypeof\n(\n1.0\nu\nm/s\n)\n\n\nQuantity{Float64, Dimensions:{\ud835\udc0b \ud835\udc13^-1}, Units:{m s^-1}}\n\n\n\njulia\n \nu\n\u0127\n\n\n1.0545718001391127e-34 J s\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.register\n \n \nFunction\n.\n\n\nfunction\n \nregister\n(\nunit_module\n::\nModule\n)\n\n\n\n\n\n\nMakes the \n@u_str\n macro aware of units defined in new unit modules. By default, Unitful is itself a registered module. Note that Main is not, so if you define new units at the REPL, you will probably want to do \nUnitful.register(Main)\n.\n\n\nExample:\n\n\n# somewhere in a custom units package...\n\n\nmodule\n \nMyUnitsPackage\n\n\nusing\n \nUnitful\n\n\n\nfunction\n \n__init__\n()\n\n    \n...\n\n    \nUnitful\n.\nregister\n(\nMyUnitsPackage\n)\n\n\nend\n\n\nend\n \n#module\n\n\n\n\n\n\nsource\n\n\n\n\nDimension and unit inspection\n\n\nWe define a function \ndimension\n that turns, for example, \nacre^2\n or \n1*acre^2\n into \n\ud835\udc0b^4\n. We can usually add quantities with the same dimension, regardless of specific units (\nFixedUnits\n cannot be automatically converted, however). Note that dimensions cannot be determined by powers of the units: \nft^2\n is an area, but so is \nac^1\n (an acre).\n\n\nThere is also a function \nunit\n that turns, for example, \n1*acre^2\n into \nacre^2\n. You can then query whether the units are \nFreeUnits\n, \nFixedUnits\n, etc.\n\n\n#\n\n\nUnitful.unit\n \n \nFunction\n.\n\n\nunit{T,D,U}(x::Quantity{T,D,U})\n\n\n\n\n\nReturns the units associated with a quantity.\n\n\nExamples:\n\n\njulia\n \nunit\n(\n1.0\nu\nm\n)\n \n==\n \nu\nm\n\n\ntrue\n\n\n\njulia\n \ntypeof\n(\nu\nm\n)\n\n\nUnitful.FreeUnits{(Unitful.Unit{:Meter,Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}(0, 1//1),),Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}\n\n\n\n\n\n\nsource\n\n\nunit{T,D,U}(x::Type{Quantity{T,D,U}})\n\n\n\n\n\nReturns the units associated with a quantity type, \nContextUnits(U(),P())\n.\n\n\nExamples:\n\n\njulia\n \nunit\n(\ntypeof\n(\n1.0\nu\nm\n))\n \n==\n \nu\nm\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\nunit(x::Number)\n\n\n\n\n\nReturns a \nUnitful.Units{(), Dimensions{()}}\n object to indicate that ordinary numbers have no units. This is a singleton, which we export as \nNoUnits\n. The unit is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n \ntypeof\n(\nunit\n(\n1.0\n))\n\n\nUnitful.FreeUnits{(),Unitful.Dimensions{()}}\n\n\njulia\n \ntypeof\n(\nunit\n(\nFloat64\n))\n\n\nUnitful.FreeUnits{(),Unitful.Dimensions{()}}\n\n\njulia\n \nunit\n(\n1.0\n)\n \n==\n \nNoUnits\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(x::Number)\ndimension{T\n:Number}(x::Type{T})\n\n\n\n\n\nReturns a \nUnitful.Dimensions{()}\n object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as \nNoDims\n. The dimension is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n \ntypeof\n(\ndimension\n(\n1.0\n))\n\n\nUnitful.Dimensions{()}\n\n\njulia\n \ntypeof\n(\ndimension\n(\nFloat64\n))\n\n\nUnitful.Dimensions{()}\n\n\njulia\n \ndimension\n(\n1.0\n)\n \n==\n \nNoDims\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{U,D}(u::Units{U,D})\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n \ndimension\n(\nu\nm\n)\n\n\n\ud835\udc0b\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\nu\nm\n))\n\n\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\nu\nm/km\n))\n\n\nUnitful.Dimensions{()}\n\n\n\n\n\n\nsource\n\n\ndimension{T,D}(x::Quantity{T,D})\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n \ndimension\n(\n1.0\nu\nm\n)\n\n\n\ud835\udc0b\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\n1.0\nu\nm/\u03bcm\n))\n\n\nUnitful.Dimensions{()}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{U,D}(u::Units{U,D})\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n \ndimension\n(\nu\nm\n)\n\n\n\ud835\udc0b\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\nu\nm\n))\n\n\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\nu\nm/km\n))\n\n\nUnitful.Dimensions{()}\n\n\n\n\n\n\nsource\n\n\ndimension{T,D}(x::Quantity{T,D})\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n \ndimension\n(\n1.0\nu\nm\n)\n\n\n\ud835\udc0b\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\n1.0\nu\nm/\u03bcm\n))\n\n\nUnitful.Dimensions{()}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{T\n:Units}(x::AbstractArray{T})\n\n\n\n\n\nJust calls \nmap(dimension, x)\n.\n\n\nsource\n\n\n\n\nUnit stripping\n\n\n#\n\n\nUnitful.ustrip\n \n \nFunction\n.\n\n\nustrip(x::Number)\n\n\n\n\n\nReturns the number out in front of any units. This may be different from the value in the case of dimensionless quantities. See \nuconvert\n and the example below. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is just calling \nx/unit(x)\n, which is as fast as directly accessing the \nval\n field of \nx::Quantity\n, but also works for any other kind of number.\n\n\nThis function is mainly intended for compatibility with packages that don't know how to handle quantities. This function may be deprecated in the future.\n\n\njulia\n \nustrip\n(\n2\nu\n\u03bcm/m\n)\n \n==\n \n2\n\n\ntrue\n\n\n\njulia\n \nuconvert\n(\nNoUnits\n,\n \n2\nu\n\u03bcm/m\n)\n \n==\n \n2\n//\n1000000\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\nustrip{Q\n:Quantity}(x::Array{Q})\n\n\n\n\n\nStrip units from an \nArray\n by reinterpreting to type \nT\n. The resulting \nArray\n is a \"unit free view\" into array \nx\n. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.\n\n\njulia\n \na\n \n=\n \n[\n1\nu\nm\n,\n \n2\nu\nm\n]\n\n\n2-element Array{Quantity{Int64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n\n\n 1 m\n\n\n 2 m\n\n\n\njulia\n \nb\n \n=\n \nustrip\n(\na\n)\n\n\n2-element Array{Int64,1}:\n\n\n 1\n\n\n 2\n\n\n\njulia\n \na\n[\n1\n]\n \n=\n \n3\nu\nm\n;\n \nb\n\n\n2-element Array{Int64,1}:\n\n\n 3\n\n\n 2\n\n\n\n\n\n\nsource\n\n\nustrip{Q\n:Quantity}(A::AbstractArray{Q})\n\n\n\n\n\nStrip units from an \nAbstractArray\n by making a new array without units using array comprehensions.\n\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.\n\n\nsource\n\n\nustrip{T\n:Number}(x::AbstractArray{T})\n\n\n\n\n\nFall-back that returns \nx\n.\n\n\nsource\n\n\n\n\nUnit multiplication\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Units, a::Units...)\n\n\n\n\n\nGiven however many units, multiply them together. This is actually handled by a few different methods, since we have \nFreeUnits\n, \nContextUnits\n, and \nFixedUnits\n.\n\n\nCollect \nUnitful.Unit\n objects from the type parameter of the \nUnitful.Units\n objects. For identical units including SI prefixes (i.e. cm \u2260 m), collect powers and sort uniquely by the name of the \nUnit\n. The unique sorting permits easy unit comparisons.\n\n\nExamples:\n\n\njulia\n \nu\nkg*m/s^2\n\n\nkg m s^-2\n\n\n\njulia\n \nu\nm/s*kg/s\n\n\nkg m s^-2\n\n\n\njulia\n \ntypeof\n(\nu\nm/s*kg/s\n)\n \n==\n \ntypeof\n(\nu\nkg*m/s^2\n)\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Dimensions, a::Dimensions...)\n\n\n\n\n\nGiven however many dimensions, multiply them together.\n\n\nCollect \nUnitful.Dimension\n objects from the type parameter of the \nUnitful.Dimensions\n objects. For identical dimensions, collect powers and sort uniquely by the name of the \nDimension\n.\n\n\nExamples:\n\n\njulia\n \nu\n\ud835\udc0c*\ud835\udc0b/\ud835\udc13^2\n\n\n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\n\n\njulia\n \nu\n\ud835\udc0b*\ud835\udc0c/\ud835\udc13^2\n\n\n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\n\n\njulia\n \ntypeof\n(\nu\n\ud835\udc0b*\ud835\udc0c/\ud835\udc13^2\n)\n \n==\n \ntypeof\n(\nu\n\ud835\udc0c*\ud835\udc0b/\ud835\udc13^2\n)\n\n\ntrue\n\n\n\n\n\n\nsource", 
            "title": "Manipulating units"
        }, 
        {
            "location": "/manipulations/#unitful-string-macro", 
            "text": "#  Unitful.@u_str     Macro .  macro u_str(unit)  String macro to easily recall units, dimensions, or quantities defined in unit modules that have been registered with  Unitful.register .  If the same symbol is used for a  Unitful.Units  object defined in different modules, then the symbol found in the most recently registered module will be used.  Note that what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".  Examples:  julia   1.0 u m/s  1.0 m s^-1  julia   1.0 u N*m  1.0 m N  julia   u m,kg,s  (m, kg, s)  julia   typeof ( 1.0 u m/s )  Quantity{Float64, Dimensions:{\ud835\udc0b \ud835\udc13^-1}, Units:{m s^-1}}  julia   u \u0127  1.0545718001391127e-34 J s   source  #  Unitful.register     Function .  function   register ( unit_module :: Module )   Makes the  @u_str  macro aware of units defined in new unit modules. By default, Unitful is itself a registered module. Note that Main is not, so if you define new units at the REPL, you will probably want to do  Unitful.register(Main) .  Example:  # somewhere in a custom units package...  module   MyUnitsPackage  using   Unitful  function   __init__ () \n     ... \n     Unitful . register ( MyUnitsPackage )  end  end   #module   source", 
            "title": "Unitful string macro"
        }, 
        {
            "location": "/manipulations/#dimension-and-unit-inspection", 
            "text": "We define a function  dimension  that turns, for example,  acre^2  or  1*acre^2  into  \ud835\udc0b^4 . We can usually add quantities with the same dimension, regardless of specific units ( FixedUnits  cannot be automatically converted, however). Note that dimensions cannot be determined by powers of the units:  ft^2  is an area, but so is  ac^1  (an acre).  There is also a function  unit  that turns, for example,  1*acre^2  into  acre^2 . You can then query whether the units are  FreeUnits ,  FixedUnits , etc.  #  Unitful.unit     Function .  unit{T,D,U}(x::Quantity{T,D,U})  Returns the units associated with a quantity.  Examples:  julia   unit ( 1.0 u m )   ==   u m  true  julia   typeof ( u m )  Unitful.FreeUnits{(Unitful.Unit{:Meter,Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}(0, 1//1),),Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}   source  unit{T,D,U}(x::Type{Quantity{T,D,U}})  Returns the units associated with a quantity type,  ContextUnits(U(),P()) .  Examples:  julia   unit ( typeof ( 1.0 u m ))   ==   u m  true   source  unit(x::Number)  Returns a  Unitful.Units{(), Dimensions{()}}  object to indicate that ordinary numbers have no units. This is a singleton, which we export as  NoUnits . The unit is displayed as an empty string.  Examples:  julia   typeof ( unit ( 1.0 ))  Unitful.FreeUnits{(),Unitful.Dimensions{()}}  julia   typeof ( unit ( Float64 ))  Unitful.FreeUnits{(),Unitful.Dimensions{()}}  julia   unit ( 1.0 )   ==   NoUnits  true   source  #  Unitful.dimension     Method .  dimension(x::Number)\ndimension{T :Number}(x::Type{T})  Returns a  Unitful.Dimensions{()}  object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as  NoDims . The dimension is displayed as an empty string.  Examples:  julia   typeof ( dimension ( 1.0 ))  Unitful.Dimensions{()}  julia   typeof ( dimension ( Float64 ))  Unitful.Dimensions{()}  julia   dimension ( 1.0 )   ==   NoDims  true   source  #  Unitful.dimension     Method .  dimension{U,D}(u::Units{U,D})  Returns a  Unitful.Dimensions  object corresponding to the dimensions of the units,  D() . For a dimensionless combination of units, a  Unitful.Dimensions{()}  object is returned.  Examples:  julia   dimension ( u m )  \ud835\udc0b  julia   typeof ( dimension ( u m ))  Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}  julia   typeof ( dimension ( u m/km ))  Unitful.Dimensions{()}   source  dimension{T,D}(x::Quantity{T,D})  Returns a  Unitful.Dimensions  object  D()  corresponding to the dimensions of quantity  x . For a dimensionless  Unitful.Quantity , a  Unitful.Dimensions{()}  object is returned.  Examples:  julia   dimension ( 1.0 u m )  \ud835\udc0b  julia   typeof ( dimension ( 1.0 u m/\u03bcm ))  Unitful.Dimensions{()}   source  #  Unitful.dimension     Method .  dimension{U,D}(u::Units{U,D})  Returns a  Unitful.Dimensions  object corresponding to the dimensions of the units,  D() . For a dimensionless combination of units, a  Unitful.Dimensions{()}  object is returned.  Examples:  julia   dimension ( u m )  \ud835\udc0b  julia   typeof ( dimension ( u m ))  Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}  julia   typeof ( dimension ( u m/km ))  Unitful.Dimensions{()}   source  dimension{T,D}(x::Quantity{T,D})  Returns a  Unitful.Dimensions  object  D()  corresponding to the dimensions of quantity  x . For a dimensionless  Unitful.Quantity , a  Unitful.Dimensions{()}  object is returned.  Examples:  julia   dimension ( 1.0 u m )  \ud835\udc0b  julia   typeof ( dimension ( 1.0 u m/\u03bcm ))  Unitful.Dimensions{()}   source  #  Unitful.dimension     Method .  dimension{T :Units}(x::AbstractArray{T})  Just calls  map(dimension, x) .  source", 
            "title": "Dimension and unit inspection"
        }, 
        {
            "location": "/manipulations/#unit-stripping", 
            "text": "#  Unitful.ustrip     Function .  ustrip(x::Number)  Returns the number out in front of any units. This may be different from the value in the case of dimensionless quantities. See  uconvert  and the example below. Because the units are removed, information may be lost and this should be used with some care.  This function is just calling  x/unit(x) , which is as fast as directly accessing the  val  field of  x::Quantity , but also works for any other kind of number.  This function is mainly intended for compatibility with packages that don't know how to handle quantities. This function may be deprecated in the future.  julia   ustrip ( 2 u \u03bcm/m )   ==   2  true  julia   uconvert ( NoUnits ,   2 u \u03bcm/m )   ==   2 // 1000000  true   source  ustrip{Q :Quantity}(x::Array{Q})  Strip units from an  Array  by reinterpreting to type  T . The resulting  Array  is a \"unit free view\" into array  x . Because the units are removed, information may be lost and this should be used with some care.  This function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.  julia   a   =   [ 1 u m ,   2 u m ]  2-element Array{Quantity{Int64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:   1 m   2 m  julia   b   =   ustrip ( a )  2-element Array{Int64,1}:   1   2  julia   a [ 1 ]   =   3 u m ;   b  2-element Array{Int64,1}:   3   2   source  ustrip{Q :Quantity}(A::AbstractArray{Q})  Strip units from an  AbstractArray  by making a new array without units using array comprehensions.  This function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.  source  ustrip{T :Number}(x::AbstractArray{T})  Fall-back that returns  x .  source", 
            "title": "Unit stripping"
        }, 
        {
            "location": "/manipulations/#unit-multiplication", 
            "text": "#  Base.:*     Method .  *(a0::Units, a::Units...)  Given however many units, multiply them together. This is actually handled by a few different methods, since we have  FreeUnits ,  ContextUnits , and  FixedUnits .  Collect  Unitful.Unit  objects from the type parameter of the  Unitful.Units  objects. For identical units including SI prefixes (i.e. cm \u2260 m), collect powers and sort uniquely by the name of the  Unit . The unique sorting permits easy unit comparisons.  Examples:  julia   u kg*m/s^2  kg m s^-2  julia   u m/s*kg/s  kg m s^-2  julia   typeof ( u m/s*kg/s )   ==   typeof ( u kg*m/s^2 )  true   source  #  Base.:*     Method .  *(a0::Dimensions, a::Dimensions...)  Given however many dimensions, multiply them together.  Collect  Unitful.Dimension  objects from the type parameter of the  Unitful.Dimensions  objects. For identical dimensions, collect powers and sort uniquely by the name of the  Dimension .  Examples:  julia   u \ud835\udc0c*\ud835\udc0b/\ud835\udc13^2  \ud835\udc0b \ud835\udc0c \ud835\udc13^-2  julia   u \ud835\udc0b*\ud835\udc0c/\ud835\udc13^2  \ud835\udc0b \ud835\udc0c \ud835\udc13^-2  julia   typeof ( u \ud835\udc0b*\ud835\udc0c/\ud835\udc13^2 )   ==   typeof ( u \ud835\udc0c*\ud835\udc0b/\ud835\udc13^2 )  true   source", 
            "title": "Unit multiplication"
        }, 
        {
            "location": "/display/", 
            "text": "#\n\n\nUnitful.abbr\n \n \nFunction\n.\n\n\nabbr(x)\n provides abbreviations for units or dimensions. Since a method should always be defined for each unit and dimension type, absence of a method for a specific unit or dimension type is likely an error. Consequently, we return \u2753 for generic arguments to flag unexpected behavior.\n\n\nsource\n\n\n#\n\n\nUnitful.prefix\n \n \nFunction\n.\n\n\nprefix(x::Unit)\n\n\n\n\n\nReturns a string representing the SI prefix for the power-of-ten held by this particular unit.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO, x::Quantity)\n\n\n\n\n\nShow a unitful quantity by calling \nshow\n on the numeric value, appending a space, and then calling \nshow\n on a units object \nU()\n.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow{T,D,U}(io::IO, ::Type{Quantity{T,D,U}})\n\n\n\n\n\nShow the type of a unitful quantity in a succinct way. Otherwise, array summaries are nearly unreadable.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO, x::Unitlike)\n\n\n\n\n\nCall \nUnitful.showrep\n on each object in the tuple that is the type variable of a \nUnitful.Units\n or \nUnitful.Dimensions\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Unit)\n\n\n\n\n\nShow the unit, prefixing with any decimal prefix and appending the exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Dimension)\n\n\n\n\n\nShow the dimension, appending any exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.superscript\n \n \nFunction\n.\n\n\nsuperscript(i::Rational)\n\n\n\n\n\nPrints exponents.\n\n\nsource", 
            "title": "How units are displayed"
        }, 
        {
            "location": "/extending/", 
            "text": "Extending Unitful\n\n\n\n\nMaking your own units package\n\n\nNew units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in \nUnitfulUS.jl\n, which defines U.S. customary units. It's actually very easy! Just make sure you read all of the cautionary notes on this page. If you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!\n\n\n\n\nSome limitations\n\n\n\n\nPrecompilation\n\n\nWhen creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following or something very similar make it into your code:\n\n\nconst\n \nlocalunits\n \n=\n \nUnitful\n.\nbasefactors\n\n\nconst\n \nlocalpromotion\n \n=\n \nUnitful\n.\npromotion\n \n# only if you\nve used @dimension\n\n\nfunction\n \n__init__\n()\n\n    \nmerge!\n(\nUnitful\n.\nbasefactors\n,\n \nlocalunits\n)\n\n    \nmerge!\n(\nUnitful\n.\npromotion\n,\n \nlocalpromotion\n)\n \n# only if you\nve used @dimension\n\n\nend\n\n\n\n\n\n\nThe definition of \nlocalunits\n (\nlocalpromotion\n) must happen \nafter all new units (dimensions) have been defined\n.\n\n\nThe problem is that the \n@unit\n macro needs to add some information to a dictionary defined in Unitful, regardless of where the macro is executed (the use of this dictionary does not lead to run-time penalties, if you were wondering). However, because Unitful is precompiled, changes made to it from another module at compile-time will not persist.\n\n\nThe \nconst localunits = Unitful.basefactors\n line makes a copy of the compile-time-modified dictionary, which can be precompiled into the module where this code appears, and then the dictionary is merged into Unitful's dictionary at runtime.\n\n\nIf you'd like, you can also consider adding a call to \nUnitful.register\n in your \n__init__\n function, which will make your units accessible using Unitful's \n@u_str\n macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the \n@u_str\n macro will still work, but it will use the unit found in whichever package was registered most recently, and it will omit a warning every time.\n\n\n\n\nType uniqueness\n\n\nCurrently, when the \n@dimension\n, \n@derived_dimension\n, \n@refunit\n, or \n@unit\n macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g. \nLength\n, \nMeter\n, etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.\n\n\nI don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of \nBase.gensym()\n if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.\n\n\n\n\nArchaic or fictitious unit systems\n\n\nIn the rare event that you want to define physical units which are not convertible to SI units, you need to do a bit of extra work. To be clear, such a conversion should always exist, in principle. One can imagine, however, archaic or fictitious unit systems for which a precise conversion to SI units is unknown. For example, a \ncullishigay\n is one-third of a mudi, but only \napproximately\n 1.25 imperial bushels. There may be cases where you don't even have an approximate conversion to imperial bushels. At such a time, you may feel uncomfortable specifying the \"base unit\" of this hypothetical unit system in terms of an SI quantity, and may want to explicitly forbid any attempt to convert to SI units.\n\n\nOne can achieve this by defining new dimensions with the \n@dimension\n or \n@derived_dimension\n macros. The trick is to define dimensions that display suggestively like physical dimensions, like \ud835\udc0b\n, \ud835\udc13\n etc., but are distinct as far as Julia's type system is concerned. Then, you can use \n@refunit\n to base units for these new dimensions without reference to SI. The result will be that attempted conversion between the hypothetical unit system and SI will fail with a \nDimensionError\n, so be sure you provide some hints in how your new dimensions are displayed to avoid confusing users. It would be confusing to throw a \nDimensionError\n when attempting to convert between lengths which are incompatible in the sense of the previous paragraph, when both lengths display their dimension as \ud835\udc0b.", 
            "title": "Extending Unitful"
        }, 
        {
            "location": "/extending/#extending-unitful", 
            "text": "", 
            "title": "Extending Unitful"
        }, 
        {
            "location": "/extending/#making-your-own-units-package", 
            "text": "New units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in  UnitfulUS.jl , which defines U.S. customary units. It's actually very easy! Just make sure you read all of the cautionary notes on this page. If you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!", 
            "title": "Making your own units package"
        }, 
        {
            "location": "/extending/#some-limitations", 
            "text": "", 
            "title": "Some limitations"
        }, 
        {
            "location": "/extending/#precompilation", 
            "text": "When creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following or something very similar make it into your code:  const   localunits   =   Unitful . basefactors  const   localpromotion   =   Unitful . promotion   # only if you ve used @dimension  function   __init__ () \n     merge! ( Unitful . basefactors ,   localunits ) \n     merge! ( Unitful . promotion ,   localpromotion )   # only if you ve used @dimension  end   The definition of  localunits  ( localpromotion ) must happen  after all new units (dimensions) have been defined .  The problem is that the  @unit  macro needs to add some information to a dictionary defined in Unitful, regardless of where the macro is executed (the use of this dictionary does not lead to run-time penalties, if you were wondering). However, because Unitful is precompiled, changes made to it from another module at compile-time will not persist.  The  const localunits = Unitful.basefactors  line makes a copy of the compile-time-modified dictionary, which can be precompiled into the module where this code appears, and then the dictionary is merged into Unitful's dictionary at runtime.  If you'd like, you can also consider adding a call to  Unitful.register  in your  __init__  function, which will make your units accessible using Unitful's  @u_str  macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the  @u_str  macro will still work, but it will use the unit found in whichever package was registered most recently, and it will omit a warning every time.", 
            "title": "Precompilation"
        }, 
        {
            "location": "/extending/#type-uniqueness", 
            "text": "Currently, when the  @dimension ,  @derived_dimension ,  @refunit , or  @unit  macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g.  Length ,  Meter , etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.  I don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of  Base.gensym()  if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.", 
            "title": "Type uniqueness"
        }, 
        {
            "location": "/extending/#archaic-or-fictitious-unit-systems", 
            "text": "In the rare event that you want to define physical units which are not convertible to SI units, you need to do a bit of extra work. To be clear, such a conversion should always exist, in principle. One can imagine, however, archaic or fictitious unit systems for which a precise conversion to SI units is unknown. For example, a  cullishigay  is one-third of a mudi, but only  approximately  1.25 imperial bushels. There may be cases where you don't even have an approximate conversion to imperial bushels. At such a time, you may feel uncomfortable specifying the \"base unit\" of this hypothetical unit system in terms of an SI quantity, and may want to explicitly forbid any attempt to convert to SI units.  One can achieve this by defining new dimensions with the  @dimension  or  @derived_dimension  macros. The trick is to define dimensions that display suggestively like physical dimensions, like \ud835\udc0b , \ud835\udc13  etc., but are distinct as far as Julia's type system is concerned. Then, you can use  @refunit  to base units for these new dimensions without reference to SI. The result will be that attempted conversion between the hypothetical unit system and SI will fail with a  DimensionError , so be sure you provide some hints in how your new dimensions are displayed to avoid confusing users. It would be confusing to throw a  DimensionError  when attempting to convert between lengths which are incompatible in the sense of the previous paragraph, when both lengths display their dimension as \ud835\udc0b.", 
            "title": "Archaic or fictitious unit systems"
        }, 
        {
            "location": "/trouble/", 
            "text": "Why do unit conversions yield rational numbers sometimes?\n\n\nWe use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point \n2.54\n is not equal to \n254//100\n. As a consequence, \n1inch != 2.54cm\n, because Unitful respects exact conversions. To test for equivalence, instead use \n\u2248\n (\n\\approx\n tab-completion).\n\n\n\n\nBut I want a floating point number...\n\n\nfloat(x)\n is defined for \nUnitful.Quantity\n types, and is forwarded to the underlying numeric type (units are not affected).\n\n\nWe may consider adding an option in the defaults to turn on/off use of \nRational\n numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that \ninv(2) === 0.5\n, not \n1//2\n).\n\n\n\n\nExponentiation\n\n\nMost operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a \nUnitful.Quantity\n object, raising a \nQuantity\n to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance:\n\n\njulia\n \nsquare\n(\nx\n)\n \n=\n \n(\np\n \n=\n \n2\n;\n \nx\n^\np\n)\n\n\nsquare (generic function with 1 method)\n\n\n\njulia\n \n@code_warntype\n \nsquare\n(\n1.0\nu\nm\n)\n\n\nVariables:\n\n\n  #self#::#square\n\n\n  x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}\n\n\n  p::Int64\n\n\n\nBody:\n\n\n  begin\n\n\n      return $(Expr(:invoke, MethodInstance for ^(::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, ::Int64), :(^), :(x), 2))\n\n\n  end::Any\n\n\n\n\n\n\nIn Julia 0.6, constant literal integers are lowered specially for exponentiation. (See Julia PR \n#20530\n for details.) In this case, type stability can be maintained:\n\n\njulia\n \nsquare\n(\nx\n)\n \n=\n \nx\n^\n2\n\n\nsquare (generic function with 1 method)\n\n\n\njulia\n \n@code_warntype\n \nsquare\n(\n1.0\nu\nm\n)\n\n\nVariables:\n\n\n  #self#::#square\n\n\n  x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}\n\n\n\nBody:\n\n\n  begin\n\n\n      $(Expr(:inbounds, false))\n\n\n      # meta: location /Users/ajkeller/.julia/v0.6/Unitful/src/Unitful.jl literal_pow 1080\n\n\n      SSAValue(0) = (Core.getfield)(x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, :val)::Float64\n\n\n      # meta: pop location\n\n\n      $(Expr(:inbounds, :pop))\n\n\n      return $(Expr(:new, Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}, :((Base.mul_float)(SSAValue(0), SSAValue(0))::Float64)))\n\n\n  end::Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}\n\n\n\n\n\n\nBecause the functions \ninv\n and \nsqrt\n are raising a \nQuantity\n to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a \nQuantity\n can be type-stable in either Julia 0.5 or 0.6 if done as \nx*x\n.\n\n\n\n\nPromotion with dimensionless numbers\n\n\nMost of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that \n\u03bcm/m\n and \nrad\n are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.\n\n\nThe result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles, \n1 rad\n is essentially just \n1\n, giving sane behavior:\n\n\njulia\n \n\u03c0\n/\n2\n*\nu\nrad\n+\n90\nu\n\u00b0\n\n\n3.141592653589793\n\n\n\n\n\n\n\n\nOther random problems\n\n\nIf using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:\n\n\njulia\n \nusing\n \nUnitful\n:\n \nm\n,\ncm\n\n\n\njulia\n \nuconvert\n(\nm\n,\n0x01c\nm\n)\n   \n# the user means cm, not 0x01c*m\n\n\n0x001c m\n\n\n\n\n\n\nThis behavior is a consequence of \na Julia issue\n.\n\n\n\n\nI have a different problem\n\n\nPlease raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/trouble/#why-do-unit-conversions-yield-rational-numbers-sometimes", 
            "text": "We use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point  2.54  is not equal to  254//100 . As a consequence,  1inch != 2.54cm , because Unitful respects exact conversions. To test for equivalence, instead use  \u2248  ( \\approx  tab-completion).", 
            "title": "Why do unit conversions yield rational numbers sometimes?"
        }, 
        {
            "location": "/trouble/#but-i-want-a-floating-point-number", 
            "text": "float(x)  is defined for  Unitful.Quantity  types, and is forwarded to the underlying numeric type (units are not affected).  We may consider adding an option in the defaults to turn on/off use of  Rational  numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that  inv(2) === 0.5 , not  1//2 ).", 
            "title": "But I want a floating point number..."
        }, 
        {
            "location": "/trouble/#exponentiation", 
            "text": "Most operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a  Unitful.Quantity  object, raising a  Quantity  to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance:  julia   square ( x )   =   ( p   =   2 ;   x ^ p )  square (generic function with 1 method)  julia   @code_warntype   square ( 1.0 u m )  Variables:    #self#::#square    x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}    p::Int64  Body:    begin        return $(Expr(:invoke, MethodInstance for ^(::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, ::Int64), :(^), :(x), 2))    end::Any   In Julia 0.6, constant literal integers are lowered specially for exponentiation. (See Julia PR  #20530  for details.) In this case, type stability can be maintained:  julia   square ( x )   =   x ^ 2  square (generic function with 1 method)  julia   @code_warntype   square ( 1.0 u m )  Variables:    #self#::#square    x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}  Body:    begin        $(Expr(:inbounds, false))        # meta: location /Users/ajkeller/.julia/v0.6/Unitful/src/Unitful.jl literal_pow 1080        SSAValue(0) = (Core.getfield)(x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, :val)::Float64        # meta: pop location        $(Expr(:inbounds, :pop))        return $(Expr(:new, Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}, :((Base.mul_float)(SSAValue(0), SSAValue(0))::Float64)))    end::Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}   Because the functions  inv  and  sqrt  are raising a  Quantity  to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a  Quantity  can be type-stable in either Julia 0.5 or 0.6 if done as  x*x .", 
            "title": "Exponentiation"
        }, 
        {
            "location": "/trouble/#promotion-with-dimensionless-numbers", 
            "text": "Most of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that  \u03bcm/m  and  rad  are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.  The result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles,  1 rad  is essentially just  1 , giving sane behavior:  julia   \u03c0 / 2 * u rad + 90 u \u00b0  3.141592653589793", 
            "title": "Promotion with dimensionless numbers"
        }, 
        {
            "location": "/trouble/#other-random-problems", 
            "text": "If using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:  julia   using   Unitful :   m , cm  julia   uconvert ( m , 0x01c m )     # the user means cm, not 0x01c*m  0x001c m   This behavior is a consequence of  a Julia issue .", 
            "title": "Other random problems"
        }, 
        {
            "location": "/trouble/#i-have-a-different-problem", 
            "text": "Please raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "I have a different problem"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nThe Unitful.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "The Unitful.jl package is licensed under the MIT \"Expat\" License:   Copyright (c) 2016: Andrew Keller.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}