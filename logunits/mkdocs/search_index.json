{
    "docs": [
        {
            "location": "/", 
            "text": "Unitful.jl\n\n\nA Julia package for physical units. Available \nhere\n. Inspired by:\n\n\n\n\nSIUnits.jl\n\n\nEngUnits.jl\n\n\nUnits.jl\n\n\n\n\nWe want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are defined in Julia.\n\n\n\n\nQuick start\n\n\n\n\nThis package requires Julia 0.6. Older versions will not be supported.\n\n\nPkg.add(\"Unitful\")\n\n\nusing Unitful\n\n\n\n\nUnitful aims for generality, but has some useful functionality out of the box.\n\n\n\n\nBase dimensions like length, mass, time, etc. are defined.\n\n\nDerived dimensions like volume, energy, momentum, etc. are defined.\n\n\nBase and derived SI units with their power-of-ten prefixes are defined.\n\n\nSome other common units are defined, without power-of-ten prefixes.\n\n\nSensible default promotion behavior is specified.\n\n\n\n\nTake a look at \nsrc/pkgdefaults.jl\n for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:\n\n\n\n\ninch\n is used instead of \nin\n, since \nin\n conflicts with Julia syntax\n\n\nminute\n is used instead of \nmin\n, since \nmin\n is a commonly used function\n\n\nhr\n is used instead of \nh\n, since \nh\n is revered as the Planck constant\n\n\n\n\n\n\nImportant note on namespaces\n\n\nUnits, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:\n\n\n\n\nUse the \n@u_str\n string macro.\n\n\nExplicitly import from the \nUnitful\n package to bring specific symbols into the calling namespace.\n\n\n\n\nusing Unitful.DefaultSymbols\n will bring the following symbols into the calling namespace:\n\n\n\n\nDimensions \n\ud835\udc0b,\ud835\udc0c,\ud835\udc13,\ud835\udc08,\ud835\udeaf,\ud835\udc09,\ud835\udc0d\n for length, mass, time, current, temperature,\n\n\n\n\nluminosity, and amount, respectively.\n\n\n\n\nBase and derived SI units, with SI prefixes.\n\n\n\u00b0\n (degrees)\n\n\n\n\n\n\n\n\nIf you have been using the \nSIUnits.jl\n   package, this is not unlike typing \nusing SIUnits.ShortUnits\n with that package.\n\n\n\n\nUsage examples\n\n\njulia\n 1u\nkg\n == 1000u\ng\n             # Equivalence implies unit conversion\ntrue\n\njulia\n !(1u\nkg\n === 1000u\ng\n)         # ...and yet we can distinguish these...\ntrue\n\njulia\n 1u\nkg\n === 1u\nkg\n              # ...and these are indistinguishable.\ntrue\n\n\n\n\n\nIn the next examples we assume we have brought some units into our namespace, e.g. using \nm = u\"m\"\n, etc.\n\n\njulia\n uconvert(\u00b0C, 212\u00b0F)\n100//1 \u00b0C\n\njulia\n uconvert(\u03bcm/(m*\u00b0F), 9\u03bcm/(m*\u00b0C))\n5//1 \u00b0F^-1 \u03bcm m^-1\n\njulia\n mod(1hr+3minute+5s, 24s)\n17//1 s\n\n\n\n\n\nSee \ntest/runtests.jl\n for more usage examples.", 
            "title": "Home"
        }, 
        {
            "location": "/#unitfuljl", 
            "text": "A Julia package for physical units. Available  here . Inspired by:   SIUnits.jl  EngUnits.jl  Units.jl   We want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are defined in Julia.", 
            "title": "Unitful.jl"
        }, 
        {
            "location": "/#quick-start", 
            "text": "This package requires Julia 0.6. Older versions will not be supported.  Pkg.add(\"Unitful\")  using Unitful   Unitful aims for generality, but has some useful functionality out of the box.   Base dimensions like length, mass, time, etc. are defined.  Derived dimensions like volume, energy, momentum, etc. are defined.  Base and derived SI units with their power-of-ten prefixes are defined.  Some other common units are defined, without power-of-ten prefixes.  Sensible default promotion behavior is specified.   Take a look at  src/pkgdefaults.jl  for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:   inch  is used instead of  in , since  in  conflicts with Julia syntax  minute  is used instead of  min , since  min  is a commonly used function  hr  is used instead of  h , since  h  is revered as the Planck constant", 
            "title": "Quick start"
        }, 
        {
            "location": "/#important-note-on-namespaces", 
            "text": "Units, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:   Use the  @u_str  string macro.  Explicitly import from the  Unitful  package to bring specific symbols into the calling namespace.   using Unitful.DefaultSymbols  will bring the following symbols into the calling namespace:   Dimensions  \ud835\udc0b,\ud835\udc0c,\ud835\udc13,\ud835\udc08,\ud835\udeaf,\ud835\udc09,\ud835\udc0d  for length, mass, time, current, temperature,   luminosity, and amount, respectively.   Base and derived SI units, with SI prefixes.  \u00b0  (degrees)     If you have been using the  SIUnits.jl    package, this is not unlike typing  using SIUnits.ShortUnits  with that package.", 
            "title": "Important note on namespaces"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "julia  1u kg  == 1000u g              # Equivalence implies unit conversion\ntrue\n\njulia  !(1u kg  === 1000u g )         # ...and yet we can distinguish these...\ntrue\n\njulia  1u kg  === 1u kg               # ...and these are indistinguishable.\ntrue  In the next examples we assume we have brought some units into our namespace, e.g. using  m = u\"m\" , etc.  julia  uconvert(\u00b0C, 212\u00b0F)\n100//1 \u00b0C\n\njulia  uconvert(\u03bcm/(m*\u00b0F), 9\u03bcm/(m*\u00b0C))\n5//1 \u00b0F^-1 \u03bcm m^-1\n\njulia  mod(1hr+3minute+5s, 24s)\n17//1 s  See  test/runtests.jl  for more usage examples.", 
            "title": "Usage examples"
        }, 
        {
            "location": "/highlights/", 
            "text": "Dispatch on dimensions\n\n\nConsider the following toy example, converting from voltage or power ratios to decibels:\n\n\njulia\n whatsit(x::Unitful.Voltage) = \nvoltage!\n\n whatsit (generic function with 1 method)\n\njulia\n whatsit(x::Unitful.Length) = \nlength!\n\n whatsit (generic function with 2 methods)\n\njulia\n whatsit(1u\nmm\n)\n\nlength!\n\n\njulia\n whatsit(1u\nkV\n)\n\nvoltage!\n\n\njulia\n whatsit(1u\nA\n * 2.5u\n\u03a9\n)\n\nvoltage!\n\n\n\n\n\n\n\n\nDimensions in a type definition\n\n\nIt may be tempting to specify the dimensions of a quantity in a type definition, e.g.\n\n\ntype Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend\n\n\n\n\n\nHowever, these are abstract types. If performance is important, it may be better just to pick a concrete \nQuantity\n type:\n\n\ntype Person\n    height::typeof(1.0u\nm\n)\n    mass::typeof(1.0u\nkg\n)\nend\n\n\n\n\n\nYou can still create a \nPerson\n as \nPerson(5u\"ft\"+10u\"inch\", 75u\"kg\")\n; the unit conversion happens automatically.\n\n\n\n\nMaking new units and dimensions\n\n\nYou can make new units using the \n@unit\n macro on the fly:\n\n\njulia\n @unit yd5 \nyd5\n FiveYards 5u\nyd\n false\nyd5\n\n\n\n\n\n\n\nArrays\n\n\nPromotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from \n[1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"]\n). However, it could be useful in toy calculations for \ngeneral relativity\n where some conventions yield matrices with mixed dimensions:\n\n\njulia\n Diagonal([-1.0u\nc^2\n, 1.0, 1.0, 1.0])\n4\u00d74 Diagonal{Unitful.Quantity{Float64,D,U}}:\n -1.0 c^2   \u22c5    \u22c5    \u22c5\n       \u22c5   1.0   \u22c5    \u22c5\n       \u22c5    \u22c5   1.0   \u22c5\n       \u22c5    \u22c5    \u22c5   1.0\n\n\n\n\n\n\n\nLogarithmic units\n\n\njulia\n uconvert(u\nmW*s\n, 20u\ndBm/Hz\n)\n100.0 s mW\n\n\n\n\n\n\n\nUnits with rational exponents\n\n\njulia\n 1.0u\nV/sqrt(Hz)\n\n1.0 Hz^-1/2 V\n\n\n\n\n\n\n\nExact conversions respected\n\n\njulia\n uconvert(u\nft\n,1u\ninch\n)\n1//12 ft", 
            "title": "Highlighted features"
        }, 
        {
            "location": "/highlights/#dispatch-on-dimensions", 
            "text": "Consider the following toy example, converting from voltage or power ratios to decibels:  julia  whatsit(x::Unitful.Voltage) =  voltage! \n whatsit (generic function with 1 method)\n\njulia  whatsit(x::Unitful.Length) =  length! \n whatsit (generic function with 2 methods)\n\njulia  whatsit(1u mm ) length! \n\njulia  whatsit(1u kV ) voltage! \n\njulia  whatsit(1u A  * 2.5u \u03a9 ) voltage!", 
            "title": "Dispatch on dimensions"
        }, 
        {
            "location": "/highlights/#dimensions-in-a-type-definition", 
            "text": "It may be tempting to specify the dimensions of a quantity in a type definition, e.g.  type Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend  However, these are abstract types. If performance is important, it may be better just to pick a concrete  Quantity  type:  type Person\n    height::typeof(1.0u m )\n    mass::typeof(1.0u kg )\nend  You can still create a  Person  as  Person(5u\"ft\"+10u\"inch\", 75u\"kg\") ; the unit conversion happens automatically.", 
            "title": "Dimensions in a type definition"
        }, 
        {
            "location": "/highlights/#making-new-units-and-dimensions", 
            "text": "You can make new units using the  @unit  macro on the fly:  julia  @unit yd5  yd5  FiveYards 5u yd  false\nyd5", 
            "title": "Making new units and dimensions"
        }, 
        {
            "location": "/highlights/#arrays", 
            "text": "Promotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from  [1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"] ). However, it could be useful in toy calculations for  general relativity  where some conventions yield matrices with mixed dimensions:  julia  Diagonal([-1.0u c^2 , 1.0, 1.0, 1.0])\n4\u00d74 Diagonal{Unitful.Quantity{Float64,D,U}}:\n -1.0 c^2   \u22c5    \u22c5    \u22c5\n       \u22c5   1.0   \u22c5    \u22c5\n       \u22c5    \u22c5   1.0   \u22c5\n       \u22c5    \u22c5    \u22c5   1.0", 
            "title": "Arrays"
        }, 
        {
            "location": "/highlights/#logarithmic-units", 
            "text": "julia  uconvert(u mW*s , 20u dBm/Hz )\n100.0 s mW", 
            "title": "Logarithmic units"
        }, 
        {
            "location": "/highlights/#units-with-rational-exponents", 
            "text": "julia  1.0u V/sqrt(Hz) \n1.0 Hz^-1/2 V", 
            "title": "Units with rational exponents"
        }, 
        {
            "location": "/highlights/#exact-conversions-respected", 
            "text": "julia  uconvert(u ft ,1u inch )\n1//12 ft", 
            "title": "Exact conversions respected"
        }, 
        {
            "location": "/types/", 
            "text": "Overview\n\n\nWe define a \nUnitful.Unit{U,D}\n type to represent a unit (\nU\n is a symbol, like \n:Meter\n, and \nD\n keeps track of dimensional information). Fields of a \nUnit\n object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g. \nnm\n or \nkm\n) may help to avoid overflow issues and general ugliness.\n\n\nUsually, the user interacts only with \nUnits\n objects, not \nUnit\n objects. This is because generically, more than one unit is needed to describe a quantity. An abstract type \nUnitful.Units{N,D}\n is defined, where \nN\n is always a tuple of \nUnit\n objects, and \nD\n is some type, like \ntypeof(Unitful.\ud835\udc0b)\n, where \n\ud835\udc0b\n is the object representing the length dimension (see \nUnitful.Dimensions{N}\n).\n\n\nSubtypes of \nUnitful.Units{N,D}\n are used to implement different behaviors for how to promote dimensioned quantities. The concrete subtypes have no fields and are therefore immutable singletons. Currently implemented subtypes of \nUnitful.Units{N,D}\n include \nUnitful.FreeUnits{N,D}\n, \nUnitful.ContextUnits{N,D,P}\n, and \nUnitful.FixedUnits{N,D}\n. Units defined in the Unitful.jl package itself are all \nUnitful.FreeUnits{N,D}\n objects.\n\n\nFinally, we define physical quantity types as \nQuantity{T\n:Number, D, U}\n, where \nD \n: Dimensions\n and \nU \n: Units\n. By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions: \nisa(1m, Length) == true\n. This works because \nLength\n is a type alias for some subset of \nUnitful.Quantity\n subtypes.\n\n\n\n\nAPI\n\n\n\n\nQuantities\n\n\n#\n\n\nUnitful.Quantity\n \n \nType\n.\n\n\n\"     struct Quantity{T,D,U} \n: Number A quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.\n\n\nThe type parameter \nT\n represents the numeric backing type. The type parameters \nD \n:\n \nUnitful.Dimensions\n and \nU \n:\n \nUnitful.Units\n. Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.\n\n\nsource\n\n\n#\n\n\nUnitful.DimensionlessQuantity\n \n \nType\n.\n\n\nDimensionlessQuantity{T,U} = Quantity{T, Dimensions{()}, U}\n\n\n\n\n\nUseful for dispatching on \nUnitful.Quantity\n types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)\n\n\nExample:\n\n\njulia\n isa(1.0u\nmV/V\n, DimensionlessQuantity)\ntrue\n\n\n\n\n\nsource\n\n\n\n\nUnits and dimensions\n\n\n#\n\n\nUnitful.Unitlike\n \n \nType\n.\n\n\nabstract type Unitlike end\n\n\n\n\n\nRepresents units or dimensions. Dimensions are unit-like in the sense that they are not numbers but you can multiply or divide them and exponentiate by rationals.\n\n\nsource\n\n\n#\n\n\nUnitful.Units\n \n \nType\n.\n\n\nabstract type Units{N,D} \n: Unitlike end\n\n\n\n\n\nAbstract supertype of all units objects, which can differ in their implementation details.\n\n\nsource\n\n\n#\n\n\nUnitful.FreeUnits\n \n \nType\n.\n\n\nstruct FreeUnits{N,D} \n: Units{N,D}\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. These behave like units have behaved in previous versions of Unitful, and provide a basic level of functionality that should be acceptable to most users. See \nBasic promotion mechanisms\n in the docs for details.\n\n\nExample: the unit \nm\n is actually a singleton of type \nUnitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),),typeof(\ud835\udc0b)\n. After dividing by \ns\n, a singleton of type \nUnitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1), Unitful.Unit{:Second,typeof(\ud835\udc13)}(0,-1//1,1.0,1//1)),typeof(\ud835\udc0b/\ud835\udc13)}\n is returned.\n\n\nsource\n\n\n#\n\n\nUnitful.ContextUnits\n \n \nType\n.\n\n\nstruct ContextUnits{N,D,P} \n: Units{N,D}\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. It is in most respects like \nFreeUnits{N,D}\n, except that the type parameter \nP\n is again a \nFreeUnits{M,D}\n type that specifies a preferred unit for promotion. See \nAdvanced promotion mechanisms\n in the docs for details.\n\n\nsource\n\n\n#\n\n\nUnitful.FixedUnits\n \n \nType\n.\n\n\nstruct FixedUnits{N,D} \n: Units{N,D} end\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. These are primarily intended for use when you would like to disable automatic unit conversions. See \nAdvanced promotion mechanisms\n in the docs for details.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimensions\n \n \nType\n.\n\n\nstruct Dimensions{N} \n: Unitlike\n\n\n\n\n\nInstances of this object represent dimensions, possibly combinations thereof.\n\n\nsource\n\n\n#\n\n\nUnitful.Unit\n \n \nType\n.\n\n\nstruct Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend\n\n\n\n\n\nDescription of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter \nU\n as a symbol, e.g. \n:Meter\n, \n:Second\n, \n:Gram\n, etc. The type parameter \nD\n contains dimension information, for instance \nUnit{:Meter, typeof(\ud835\udc0b)}\n or \nUnit{:Liter, typeof(\ud835\udc0b^3)}\n. Note that the dimension information refers to the unit, not powers of the unit.\n\n\nUnit{U,D}\n objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter \nN\n of a \nUnits{N,D}\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimension\n \n \nType\n.\n\n\nstruct Dimension{D}\n    power::Rational{Int}\nend\n\n\n\n\n\nDescription of a dimension. The name of the dimension \nD\n is a symbol, e.g. \n:Length\n, \n:Time\n, \n:Mass\n, etc.\n\n\nDimension{D}\n objects are collected in a tuple, which is used for the type parameter \nN\n of a \nDimensions{N}\n object.\n\n\nsource", 
            "title": "Types"
        }, 
        {
            "location": "/types/#overview", 
            "text": "We define a  Unitful.Unit{U,D}  type to represent a unit ( U  is a symbol, like  :Meter , and  D  keeps track of dimensional information). Fields of a  Unit  object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g.  nm  or  km ) may help to avoid overflow issues and general ugliness.  Usually, the user interacts only with  Units  objects, not  Unit  objects. This is because generically, more than one unit is needed to describe a quantity. An abstract type  Unitful.Units{N,D}  is defined, where  N  is always a tuple of  Unit  objects, and  D  is some type, like  typeof(Unitful.\ud835\udc0b) , where  \ud835\udc0b  is the object representing the length dimension (see  Unitful.Dimensions{N} ).  Subtypes of  Unitful.Units{N,D}  are used to implement different behaviors for how to promote dimensioned quantities. The concrete subtypes have no fields and are therefore immutable singletons. Currently implemented subtypes of  Unitful.Units{N,D}  include  Unitful.FreeUnits{N,D} ,  Unitful.ContextUnits{N,D,P} , and  Unitful.FixedUnits{N,D} . Units defined in the Unitful.jl package itself are all  Unitful.FreeUnits{N,D}  objects.  Finally, we define physical quantity types as  Quantity{T :Number, D, U} , where  D  : Dimensions  and  U  : Units . By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions:  isa(1m, Length) == true . This works because  Length  is a type alias for some subset of  Unitful.Quantity  subtypes.", 
            "title": "Overview"
        }, 
        {
            "location": "/types/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/types/#quantities", 
            "text": "#  Unitful.Quantity     Type .  \"     struct Quantity{T,D,U}  : Number A quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.  The type parameter  T  represents the numeric backing type. The type parameters  D  :   Unitful.Dimensions  and  U  :   Unitful.Units . Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.  source  #  Unitful.DimensionlessQuantity     Type .  DimensionlessQuantity{T,U} = Quantity{T, Dimensions{()}, U}  Useful for dispatching on  Unitful.Quantity  types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)  Example:  julia  isa(1.0u mV/V , DimensionlessQuantity)\ntrue  source", 
            "title": "Quantities"
        }, 
        {
            "location": "/types/#units-and-dimensions", 
            "text": "#  Unitful.Unitlike     Type .  abstract type Unitlike end  Represents units or dimensions. Dimensions are unit-like in the sense that they are not numbers but you can multiply or divide them and exponentiate by rationals.  source  #  Unitful.Units     Type .  abstract type Units{N,D}  : Unitlike end  Abstract supertype of all units objects, which can differ in their implementation details.  source  #  Unitful.FreeUnits     Type .  struct FreeUnits{N,D}  : Units{N,D}  Instances of this object represent units, possibly combinations thereof. These behave like units have behaved in previous versions of Unitful, and provide a basic level of functionality that should be acceptable to most users. See  Basic promotion mechanisms  in the docs for details.  Example: the unit  m  is actually a singleton of type  Unitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1),),typeof(\ud835\udc0b) . After dividing by  s , a singleton of type  Unitful.FreeUnits{(Unitful.Unit{:Meter,typeof(\ud835\udc0b)}(0,1//1,1.0,1//1), Unitful.Unit{:Second,typeof(\ud835\udc13)}(0,-1//1,1.0,1//1)),typeof(\ud835\udc0b/\ud835\udc13)}  is returned.  source  #  Unitful.ContextUnits     Type .  struct ContextUnits{N,D,P}  : Units{N,D}  Instances of this object represent units, possibly combinations thereof. It is in most respects like  FreeUnits{N,D} , except that the type parameter  P  is again a  FreeUnits{M,D}  type that specifies a preferred unit for promotion. See  Advanced promotion mechanisms  in the docs for details.  source  #  Unitful.FixedUnits     Type .  struct FixedUnits{N,D}  : Units{N,D} end  Instances of this object represent units, possibly combinations thereof. These are primarily intended for use when you would like to disable automatic unit conversions. See  Advanced promotion mechanisms  in the docs for details.  source  #  Unitful.Dimensions     Type .  struct Dimensions{N}  : Unitlike  Instances of this object represent dimensions, possibly combinations thereof.  source  #  Unitful.Unit     Type .  struct Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend  Description of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter  U  as a symbol, e.g.  :Meter ,  :Second ,  :Gram , etc. The type parameter  D  contains dimension information, for instance  Unit{:Meter, typeof(\ud835\udc0b)}  or  Unit{:Liter, typeof(\ud835\udc0b^3)} . Note that the dimension information refers to the unit, not powers of the unit.  Unit{U,D}  objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter  N  of a  Units{N,D}  object.  source  #  Unitful.Dimension     Type .  struct Dimension{D}\n    power::Rational{Int}\nend  Description of a dimension. The name of the dimension  D  is a symbol, e.g.  :Length ,  :Time ,  :Mass , etc.  Dimension{D}  objects are collected in a tuple, which is used for the type parameter  N  of a  Dimensions{N}  object.  source", 
            "title": "Units and dimensions"
        }, 
        {
            "location": "/newunits/", 
            "text": "Defining new units\n\n\n\n\nNote\n\n\nLogarithmic units should not be used in the \n@refunit\n or \n@unit\n macros described below. See the section on logarithmic scales for customization help.\n\n\n\n\nThe package automatically generates a useful set of units and dimensions in the \nUnitful\n module in \nsrc/pkgdefaults.jl\n.\n\n\nIf a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the \n@unit\n macro and the \nUnitful.register\n function, which makes units defined in a module available to the \n@u_str\n string macro.\n\n\nAn example of defining units in a module:\n\n\njulia\n module MyUnits; using Unitful; @unit myMeter \nm\n MyMeter 1u\nm\n false; end\nMyUnits\n\njulia\n using Unitful\n\njulia\n u\nmyMeter\n\nERROR: Symbol myMeter could not be found in registered unit modules.\n\njulia\n Unitful.register(MyUnits)\n2-element Array{Module,1}:\n Unitful\n MyUnits\n\njulia\n u\nmyMeter\n\nm\n\n\n\n\n\nYou could have also called \nUnitful.register\n inside the \nMyUnits\n module; the choice is somewhat analogous to whether or not to export symbols from a module, although the symbols are never really exported, just made available to the \n@u_str\n macro. If you want to make a precompiled units package, rather than define a module at the REPL, see \nMaking your own units package\n.\n\n\nYou can also define units directly in the \nMain\n module at the REPL:\n\n\njulia\n using Unitful\n\njulia\n Unitful.register(current_module());\n\njulia\n @unit M \nM\n Molar 1u\nmol/L\n true;\n\njulia\n 1u\nmM\n\n1 mM\n\n\n\n\n\nA note for the experts: Some care should be taken if explicitly creating \nUnitful.Units\n objects. The ordering of \nUnitful.Unit\n objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the \nUnits\n object will return a \"canonically sorted\" \nUnits\n object. Indeed, this is how we avoid ordering issues when multiplying quantities together.\n\n\n\n\nUseful functions and macros\n\n\n#\n\n\nUnitful.@dimension\n \n \nMacro\n.\n\n\n@dimension(symb, abbr, name)\n\n\n\n\n\nCreates new dimensions. \nname\n will be used like an identifier in the type parameter for a \nUnitful.Dimension\n object. \nsymb\n will be a symbol defined in the namespace from which this macro is called that is bound to a \nUnitful.Dimensions\n object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.\n\n\nThis macro extends \nUnitful.abbr\n to display the new dimension in an abbreviated format using the string \nabbr\n.\n\n\nType aliases are created that allow the user to dispatch on \nUnitful.Quantity\n, \nUnitful.Level\n and \nUnitful.Units\n objects of the newly defined dimension. The type alias for quantities or levels is simply given by \nname\n, and the type alias for units is given by \nname*\"Units\"\n, e.g. \nLengthUnits\n. Note that there is also \nLengthFreeUnits\n, for example, which is an alias for dispatching on \nFreeUnits\n with length dimensions. The aliases are not exported.\n\n\nFinally, if you define new dimensions with \n@dimension\n you will need to specify a preferred unit for that dimension with \nUnitful.preferunits\n, otherwise promotion will not work with that dimension. This is done automatically in the \n@refunit\n macro.\n\n\nReturns the \nDimensions\n object to which \nsymb\n is bound.\n\n\nUsage example from \nsrc/pkgdefaults.jl\n: \n@dimension \ud835\udc0b \"\ud835\udc0b\" Length\n\n\nsource\n\n\n#\n\n\nUnitful.@derived_dimension\n \n \nMacro\n.\n\n\n@derived_dimension(name, dims)\n\n\n\n\n\nCreates type aliases to allow dispatch on \nUnitful.Quantity\n, \nUnitful.Level\n, and \nUnitful.Units\n objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.\n\n\ndims\n is a \nUnitful.Dimensions\n object.\n\n\nReturns \nnothing\n.\n\n\nUsage examples:\n\n\n\n\n@derived_dimension Area \ud835\udc0b^2\n gives \nArea\n and \nAreaUnit\n type aliases\n\n\n@derived_dimension Speed \ud835\udc0b/\ud835\udc13\n gives \nSpeed\n and \nSpeedUnit\n type aliases\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.@refunit\n \n \nMacro\n.\n\n\n@refunit(symb, name, abbr, dimension, tf)\n\n\n\n\n\nDefine a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.\n\n\nThis macro extends \nUnitful.abbr\n so that the reference unit can be displayed in an abbreviated format. If \ntf == true\n, this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A \ndimension\n must be given (\nUnitful.Dimensions\n object) that specifies the dimension of the reference unit.\n\n\nIn principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using \n@dimension\n, then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.\n\n\nNote that this macro will also choose the new unit (no power-of-ten prefix) as the default unit for promotion given this dimension.\n\n\nReturns the \nUnitful.FreeUnits\n object to which \nsymb\n is bound.\n\n\nUsage example: \n@refunit m \"m\" Meter \ud835\udc0b true\n\n\nThis example, found in \nsrc/pkgdefaults.jl\n, generates \nkm\n, \nm\n, \ncm\n, ...\n\n\nsource\n\n\n#\n\n\nUnitful.@unit\n \n \nMacro\n.\n\n\n@unit(symb,abbr,name,equals,tf)\n\n\n\n\n\nDefine a unit. Rather than specifying a dimension like in \n@refunit\n, \nequals\n should be a \nUnitful.Quantity\n equal to one of the unit being defined. If \ntf == true\n, symbols will be made for each power-of-ten prefix.\n\n\nReturns the \nUnitful.FreeUnits\n object to which \nsymb\n is bound.\n\n\nUsage example: \n@unit mi \"mi\" Mile (201168//125)*m false\n\n\nThis example will \nnot\n generate \nkmi\n (kilomiles).\n\n\nsource\n\n\n#\n\n\nUnitful.offsettemp\n \n \nFunction\n.\n\n\noffsettemp(::Unit)\n\n\n\n\n\nFor temperature units, this function is used to set the scale offset.\n\n\nsource\n\n\n\n\nInternals\n\n\n#\n\n\nUnitful.@prefixed_unit_symbols\n \n \nMacro\n.\n\n\n@prefixed_unit_symbols(symb,name,dimension,basefactor)\n\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.\n\n\nExample: \n@prefixed_unit_symbols m Meter \ud835\udc0b (1.0,1)\n results in nm, cm, m, km, ... all getting defined in the calling namespace.\n\n\nsource\n\n\n#\n\n\nUnitful.@unit_symbols\n \n \nMacro\n.\n\n\n@unit_symbols(symb,name)\n\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.\n\n\nExample: \n@unit_symbols ft Foot \ud835\udc0b\n results in \nft\n getting defined but not \nkft\n.\n\n\nsource\n\n\n#\n\n\nUnitful.basefactor\n \n \nFunction\n.\n\n\nbasefactor(x::Unit)\n\n\n\n\n\nSpecifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.\n\n\nsource", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#defining-new-units", 
            "text": "Note  Logarithmic units should not be used in the  @refunit  or  @unit  macros described below. See the section on logarithmic scales for customization help.   The package automatically generates a useful set of units and dimensions in the  Unitful  module in  src/pkgdefaults.jl .  If a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the  @unit  macro and the  Unitful.register  function, which makes units defined in a module available to the  @u_str  string macro.  An example of defining units in a module:  julia  module MyUnits; using Unitful; @unit myMeter  m  MyMeter 1u m  false; end\nMyUnits\n\njulia  using Unitful\n\njulia  u myMeter \nERROR: Symbol myMeter could not be found in registered unit modules.\n\njulia  Unitful.register(MyUnits)\n2-element Array{Module,1}:\n Unitful\n MyUnits\n\njulia  u myMeter \nm  You could have also called  Unitful.register  inside the  MyUnits  module; the choice is somewhat analogous to whether or not to export symbols from a module, although the symbols are never really exported, just made available to the  @u_str  macro. If you want to make a precompiled units package, rather than define a module at the REPL, see  Making your own units package .  You can also define units directly in the  Main  module at the REPL:  julia  using Unitful\n\njulia  Unitful.register(current_module());\n\njulia  @unit M  M  Molar 1u mol/L  true;\n\njulia  1u mM \n1 mM  A note for the experts: Some care should be taken if explicitly creating  Unitful.Units  objects. The ordering of  Unitful.Unit  objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the  Units  object will return a \"canonically sorted\"  Units  object. Indeed, this is how we avoid ordering issues when multiplying quantities together.", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#useful-functions-and-macros", 
            "text": "#  Unitful.@dimension     Macro .  @dimension(symb, abbr, name)  Creates new dimensions.  name  will be used like an identifier in the type parameter for a  Unitful.Dimension  object.  symb  will be a symbol defined in the namespace from which this macro is called that is bound to a  Unitful.Dimensions  object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.  This macro extends  Unitful.abbr  to display the new dimension in an abbreviated format using the string  abbr .  Type aliases are created that allow the user to dispatch on  Unitful.Quantity ,  Unitful.Level  and  Unitful.Units  objects of the newly defined dimension. The type alias for quantities or levels is simply given by  name , and the type alias for units is given by  name*\"Units\" , e.g.  LengthUnits . Note that there is also  LengthFreeUnits , for example, which is an alias for dispatching on  FreeUnits  with length dimensions. The aliases are not exported.  Finally, if you define new dimensions with  @dimension  you will need to specify a preferred unit for that dimension with  Unitful.preferunits , otherwise promotion will not work with that dimension. This is done automatically in the  @refunit  macro.  Returns the  Dimensions  object to which  symb  is bound.  Usage example from  src/pkgdefaults.jl :  @dimension \ud835\udc0b \"\ud835\udc0b\" Length  source  #  Unitful.@derived_dimension     Macro .  @derived_dimension(name, dims)  Creates type aliases to allow dispatch on  Unitful.Quantity ,  Unitful.Level , and  Unitful.Units  objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.  dims  is a  Unitful.Dimensions  object.  Returns  nothing .  Usage examples:   @derived_dimension Area \ud835\udc0b^2  gives  Area  and  AreaUnit  type aliases  @derived_dimension Speed \ud835\udc0b/\ud835\udc13  gives  Speed  and  SpeedUnit  type aliases   source  #  Unitful.@refunit     Macro .  @refunit(symb, name, abbr, dimension, tf)  Define a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.  This macro extends  Unitful.abbr  so that the reference unit can be displayed in an abbreviated format. If  tf == true , this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A  dimension  must be given ( Unitful.Dimensions  object) that specifies the dimension of the reference unit.  In principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using  @dimension , then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.  Note that this macro will also choose the new unit (no power-of-ten prefix) as the default unit for promotion given this dimension.  Returns the  Unitful.FreeUnits  object to which  symb  is bound.  Usage example:  @refunit m \"m\" Meter \ud835\udc0b true  This example, found in  src/pkgdefaults.jl , generates  km ,  m ,  cm , ...  source  #  Unitful.@unit     Macro .  @unit(symb,abbr,name,equals,tf)  Define a unit. Rather than specifying a dimension like in  @refunit ,  equals  should be a  Unitful.Quantity  equal to one of the unit being defined. If  tf == true , symbols will be made for each power-of-ten prefix.  Returns the  Unitful.FreeUnits  object to which  symb  is bound.  Usage example:  @unit mi \"mi\" Mile (201168//125)*m false  This example will  not  generate  kmi  (kilomiles).  source  #  Unitful.offsettemp     Function .  offsettemp(::Unit)  For temperature units, this function is used to set the scale offset.  source", 
            "title": "Useful functions and macros"
        }, 
        {
            "location": "/newunits/#internals", 
            "text": "#  Unitful.@prefixed_unit_symbols     Macro .  @prefixed_unit_symbols(symb,name,dimension,basefactor)  Not called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.  Example:  @prefixed_unit_symbols m Meter \ud835\udc0b (1.0,1)  results in nm, cm, m, km, ... all getting defined in the calling namespace.  source  #  Unitful.@unit_symbols     Macro .  @unit_symbols(symb,name)  Not called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.  Example:  @unit_symbols ft Foot \ud835\udc0b  results in  ft  getting defined but not  kft .  source  #  Unitful.basefactor     Function .  basefactor(x::Unit)  Specifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.  source", 
            "title": "Internals"
        }, 
        {
            "location": "/conversion/", 
            "text": "Converting between units\n\n\nSince \nconvert\n in Julia already means something specific (conversion between Julia types), we define \nuconvert\n for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.\n\n\nExact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.\n\n\n#\n\n\nUnitful.uconvert\n \n \nFunction\n.\n\n\nuconvert{T,D,U}(a::Units, x::Quantity{T,D,U})\n\n\n\n\n\nConvert a \nUnitful.Quantity\n to different units. The conversion will fail if the target units \na\n have a different dimension than the dimension of the quantity \nx\n. You can use this method to switch between equivalent representations of the same unit, like \nN m\n and \nJ\n.\n\n\nExample:\n\n\njulia\n uconvert(u\nhr\n,3602u\ns\n)\n1801//1800 hr\njulia\n uconvert(u\nJ\n,1.0u\nN*m\n)\n1.0 J\n\n\n\n\n\nsource\n\n\nuconvert{T,D,U}(a::Units, x::Quantity{T,typeof(\ud835\udeaf),\n:TemperatureUnits})\n\n\n\n\n\nIn this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions.\n\n\nsource\n\n\nSince objects are callable, we can also make \nUnitful.Units\n callable with a \nNumber\n as an argument, for a unit conversion shorthand:\n\n\njulia\n u\ncm\n(1u\nm\n)\n100//1 cm\n\n\n\n\n\nThis syntax is a little confusing, but becomes appealing with the function chaining operator \n|\n:\n\n\njulia\n 1u\nm\n |\n u\ncm\n\n100//1 cm\n\n\n\n\n\nNote that since \nUnitful.Units\n objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling \nuconvert\n.\n\n\n\n\nDimensionless quantities\n\n\nFor dimensionless quantities, \nuconvert\n can be used to strip the units without losing power-of-ten information:\n\n\njulia\n uconvert(Unitful.NoUnits, 1.0u\n\u03bcm/m\n)\n1.0e-6\n\njulia\n uconvert(Unitful.NoUnits, 1.0u\nm\n)\nERROR: DimensionError:  and m are not dimensionally compatible.\n\n\n\n\n\nYou can also directly convert to a subtype of \nReal\n or \nComplex\n:\n\n\njulia\n Float64(1.0u\n\u03bcm/m\n)\n1.0e-6\n\n\n\n\n\n\n\nTemperature conversion\n\n\nIf the dimension of a \nQuantity\n is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature \nintervals\n.\n\n\njulia\n uconvert(u\nK\n, 21.0u\n\u00b0C\n)\n294.15 K\n\n\n\n\n\n\n\nBasic promotion mechanisms\n\n\nWe decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance.\n\n\nIf two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.\n\n\n\n\nPromotion rules for specific dimensions\n\n\nYou can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session, specifically \nbefore\n \nupreferred\n \nhas been called or quantities have been promoted\n. For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in \ng*cm^2/s^2\n. This is accomplished by defining a \nUnitful.promote_unit\n method for the units themselves. Here's an example.\n\n\njulia\n using Unitful\n\njulia\n Unitful.promote_unit{S\n:Unitful.EnergyUnits, T\n:Unitful.EnergyUnits}(::S, ::T) = u\ng*cm^2/s^2\n\n\njulia\n promote(2.0u\nJ\n, 1.0u\nkg*m^2/s^2\n)\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)\n\njulia\n Unitful.promote_unit{S\n:Unitful.EnergyUnits, T\n:Unitful.EnergyUnits}(::S, ::T) = u\nJ\n\n\njulia\n promote(2.0u\nJ\n, 1.0u\nkg*m^2/s^2\n)\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)\n\n\n\n\n\nNotice how the first definition of \nBase.promote_rule\n had a permanent effect. This is true of promotion rules for types defined in Base too; try defining a new promotion rule for \nInt\n and \nFloat64\n and you'll see it has no effect.\n\n\nIf you're wondering where \nUnitful.EnergyUnit\n comes from, it is defined in \nsrc/pkgdefaults.jl\n by the \n@derived_dimension\n macro. Similarly, the calls to the \n@dimension\n macro define \nUnitful.LengthUnit\n, \nUnitful.MassUnit\n, etc. None of these are exported.\n\n\nExisting users of Unitful may want to call \nUnitful.promote_to_derived\n after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default.\n\n\n#\n\n\nUnitful.promote_to_derived\n \n \nFunction\n.\n\n\nUnitful.promote_to_derived()\n\n\n\n\n\nDefines promotion rules to use derived SI units in promotion for common dimensions of quantities:\n\n\n\n\nJ\n (joule) for energy\n\n\nN\n (newton) for force\n\n\nW\n (watt) for power\n\n\nPa\n (pascal) for pressure\n\n\nC\n (coulomb) for charge\n\n\nV\n (volt) for voltage\n\n\n\u03a9\n (ohm) for resistance\n\n\nF\n (farad) for capacitance\n\n\nH\n (henry) for inductance\n\n\nWb\n (weber) for magnetic flux\n\n\nT\n (tesla) for B-field\n\n\nJ*s\n (joule-second) for action\n\n\n\n\nIf you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your \n.juliarc.jl\n file which is loaded when you open Julia. This function is not exported.\n\n\nsource\n\n\n\n\nFallback promotion rules\n\n\nThe \nUnitful.preferunits\n function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.\n\n\nThe default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension \n\ud835\udc0c*\ud835\udc0b^2/(\ud835\udc13^2*\ud835\udeaf)\n would be converted to \nkg*m^2/(s^2*K)\n:\n\n\njulia\n promote(1.0u\nJ/K\n, 1.0u\ng*cm^2/s^2/K\n)\n(1.0 kg K^-1 m^2 s^-2, 1.0e-7 kg K^-1 m^2 s^-2)\n\n\n\n\n\nYou can however override this behavior by calling \nUnitful.preferunits\n at the start of a Julia session, specifically \nbefore\n \nupreferred\n \nhas been called or quantities have been promoted\n.\n\n\n#\n\n\nUnitful.preferunits\n \n \nFunction\n.\n\n\npreferunits(u0::Units, u::Units...)\n\n\n\n\n\nThis function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like \ud835\udc0b or \ud835\udc13 but not \ud835\udc0b/\ud835\udc13 or \ud835\udc0b^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user.\n\n\nOnce \nUnitful.upreferred\n has been called or quantities have been promoted, this function will appear to have no effect.\n\n\nUsage example: \npreferunits(u\"m,s,A,K,cd,kg,mol\"...)\n\n\nsource\n\n\n\n\nArray promotion\n\n\nArrays are typed with as much specificity as possible upon creation. consider the following three cases:\n\n\njulia\n [1.0u\nm\n, 2.0u\nm\n]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1.0 m\n 2.0 m\n\njulia\n [1.0u\nm\n, 2.0u\ncm\n]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n  1.0 m\n 0.02 m\n\njulia\n [1.0u\nm\n, 2.0]\n2-element Array{Unitful.Quantity{Float64,D,U} where U where D,1}:\n 1.0 m\n   2.0\n\n\n\n\n\nIn the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:\n\n\njulia\n f{T\n:Unitful.Length}(x::AbstractArray{T}) = sum(x)\nf (generic function with 1 method)\n\njulia\n f([1.0u\nm\n, 2.0u\ncm\n])\n1.02 m\n\njulia\n f([1.0u\ng\n, 2.0u\ncm\n])\nERROR: MethodError: no method matching f(::Array{Unitful.Quantity{Float64,D,U} where U where D,1})\n\n\n\n\n\n\n\nAdvanced promotion mechanisms\n\n\nThere are some new types as of Unitful.jl v0.2.0 that enable some fairly sophisticated promotion logic. Three concrete subtypes of \nUnitful.Units{N,D}\n are defined: \nUnitful.FreeUnits{N,D}\n, \nUnitful.ContextUnits{N,D,P}\n, and \nUnitful.FixedUnits{N,D}\n.\n\n\nUnits defined in the Unitful.jl package itself are all \nUnitful.FreeUnits{N,D}\n objects. The \"free\" in \nFreeUnits\n indicates that the object carries no information on its own about how it should respond during promotion. Other code in Unitful dictates that by default, quantities should promote to SI units. \nFreeUnits\n use the promotion mechanisms described in the above section, \nBasic promotion mechanisms\n. They used to be called \nUnits\n in prior versions of Unitful.\n\n\n\n\nContextUnits\n\n\nSometimes, a package may want to default to a particular behavior for promotion, in the presence of other packages that may require differing default behaviors. An example would be a CAD package for nanoscale device design: it makes more sense to promote to nanometers or microns than to meters. For this purpose we define \nUnitful.ContextUnits{N,D,P}\n. The \nP\n in this type signature should be some type \nUnitful.FreeUnits{M,D}\n (the dimensions must be the same). We refer to this as the \"context.\" \nContextUnits\n may be easily instantiated by e.g. \nContextUnits(nm, \u03bcm)\n for a \nnm\n unit that will promote to \n\u03bcm\n. Here's an example:\n\n\njulia\n \u03bcm = Unitful.ContextUnits(u\n\u03bcm\n, u\n\u03bcm\n)\n\u03bcm\n\njulia\n nm = Unitful.ContextUnits(u\nnm\n, u\n\u03bcm\n)\nnm\n\njulia\n 1.0\u03bcm + 1.0nm\n1.001 \u03bcm\n\n\n\n\n\nIf the context does not agree, then we fall back to \nFreeUnits\n:\n\n\njulia\n \u03bcm = Unitful.ContextUnits(u\n\u03bcm\n, u\n\u03bcm\n)\n\u03bcm\n\njulia\n nm = Unitful.ContextUnits(u\nnm\n, u\ncm\n)\nnm\n\njulia\n 1.0\u03bcm + 1.0nm\n1.001e-6 m\n\n\n\n\n\nMultiplying a \nContextUnits\n by a \nFreeUnits\n yields a \nContextUnits\n object, with the preferred units for the additional dimensions being determined by calling \nupreferred\n on the \nFreeUnits\n object:\n\n\njulia\n mm = Unitful.ContextUnits(u\nmm\n, u\n\u03bcm\n)\nmm\n\njulia\n isa(u\ng\n, Unitful.FreeUnits)\ntrue\n\njulia\n upreferred(u\ng\n)\nkg\n\njulia\n mm*u\ng\n\ng mm\n\njulia\n isa(mm*u\ng\n, Unitful.ContextUnits)\ntrue\n\njulia\n upreferred(mm*u\ng\n)\nkg \u03bcm\n\n\n\n\n\n\n\nFixedUnits\n\n\nSometimes, there may be times where it is required to disable automatic conversion between quantities with different units. For this purpose there are \nUnitful.FixedUnits{N,D}\n. Trying to add or compare two quantities with \nFixedUnits\n will throw an error, provided the units are not the same. Note that you can still add/compare a quantity with \nFixedUnits\n to a quantity with another kind of units; in that case, the result units (if applicable) are determined by the \nFixedUnits\n, overriding the preferred units from \nContextUnits\n or \nFreeUnits\n. Multiplying \nFixedUnits\n with any other kind of units returns \nFixedUnits\n:\n\n\njulia\n mm_fix = Unitful.FixedUnits(u\nmm\n)\nmm\n\njulia\n cm_fix = Unitful.FixedUnits(u\ncm\n)\ncm\n\njulia\n 1mm_fix+2mm_fix\n3 mm\n\njulia\n 1mm_fix+2u\ncm\n  # u\ncm\n is a FreeUnits object.\n21//1 mm\n\njulia\n 1mm_fix+2*Unitful.ContextUnits(u\ncm\n, u\ncm\n)\n21//1 mm\n\njulia\n isa(mm_fix*u\ncm\n, Unitful.FixedUnits)\ntrue\n\njulia\n 1mm_fix+2cm_fix\nERROR: automatic conversion prohibited.\n[...]\n\njulia\n 1mm_fix == 1mm_fix\ntrue\n\njulia\n 1mm_fix == 0.1u\ncm\n\ntrue\n\njulia\n 1mm_fix == 0.1cm_fix\nERROR: automatic conversion prohibited.\n[...]\n\n\n\n\n\nMuch of this functionality is enabled by \npromote_unit\n definitions. These are not readily extensible by the user at this point.\n\n\n#\n\n\nUnitful.promote_unit\n \n \nFunction\n.\n\n\npromote_unit(::Units, ::Units...)\n\n\n\n\n\nGiven \nUnits\n objects as arguments, this function returns a \nUnits\n object appropriate for the result of promoting quantities which have these units. This function is kind of like \npromote_rule\n, except that it doesn't take types. It also does not return a tuple, but rather just a \nUnitful.Units\n object (or it throws an error).\n\n\nAlthough we had used \npromote_rule\n for \nUnits\n objects in prior versions of Unitful, this was always kind of a hack; it doesn't make sense to promote units directly for a variety of reasons.\n\n\nsource\n\n\n\n\nUnit cancellation\n\n\nFor multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance, \nmV/V\n is not simplified, although \nV/V\n is. Also, \nN*m/J\n is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Conversion / promotion"
        }, 
        {
            "location": "/conversion/#converting-between-units", 
            "text": "Since  convert  in Julia already means something specific (conversion between Julia types), we define  uconvert  for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.  Exact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.  #  Unitful.uconvert     Function .  uconvert{T,D,U}(a::Units, x::Quantity{T,D,U})  Convert a  Unitful.Quantity  to different units. The conversion will fail if the target units  a  have a different dimension than the dimension of the quantity  x . You can use this method to switch between equivalent representations of the same unit, like  N m  and  J .  Example:  julia  uconvert(u hr ,3602u s )\n1801//1800 hr\njulia  uconvert(u J ,1.0u N*m )\n1.0 J  source  uconvert{T,D,U}(a::Units, x::Quantity{T,typeof(\ud835\udeaf), :TemperatureUnits})  In this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions.  source  Since objects are callable, we can also make  Unitful.Units  callable with a  Number  as an argument, for a unit conversion shorthand:  julia  u cm (1u m )\n100//1 cm  This syntax is a little confusing, but becomes appealing with the function chaining operator  | :  julia  1u m  |  u cm \n100//1 cm  Note that since  Unitful.Units  objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling  uconvert .", 
            "title": "Converting between units"
        }, 
        {
            "location": "/conversion/#dimensionless-quantities", 
            "text": "For dimensionless quantities,  uconvert  can be used to strip the units without losing power-of-ten information:  julia  uconvert(Unitful.NoUnits, 1.0u \u03bcm/m )\n1.0e-6\n\njulia  uconvert(Unitful.NoUnits, 1.0u m )\nERROR: DimensionError:  and m are not dimensionally compatible.  You can also directly convert to a subtype of  Real  or  Complex :  julia  Float64(1.0u \u03bcm/m )\n1.0e-6", 
            "title": "Dimensionless quantities"
        }, 
        {
            "location": "/conversion/#temperature-conversion", 
            "text": "If the dimension of a  Quantity  is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature  intervals .  julia  uconvert(u K , 21.0u \u00b0C )\n294.15 K", 
            "title": "Temperature conversion"
        }, 
        {
            "location": "/conversion/#basic-promotion-mechanisms", 
            "text": "We decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance.  If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.", 
            "title": "Basic promotion mechanisms"
        }, 
        {
            "location": "/conversion/#promotion-rules-for-specific-dimensions", 
            "text": "You can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session, specifically  before   upreferred   has been called or quantities have been promoted . For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in  g*cm^2/s^2 . This is accomplished by defining a  Unitful.promote_unit  method for the units themselves. Here's an example.  julia  using Unitful\n\njulia  Unitful.promote_unit{S :Unitful.EnergyUnits, T :Unitful.EnergyUnits}(::S, ::T) = u g*cm^2/s^2 \n\njulia  promote(2.0u J , 1.0u kg*m^2/s^2 )\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)\n\njulia  Unitful.promote_unit{S :Unitful.EnergyUnits, T :Unitful.EnergyUnits}(::S, ::T) = u J \n\njulia  promote(2.0u J , 1.0u kg*m^2/s^2 )\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)  Notice how the first definition of  Base.promote_rule  had a permanent effect. This is true of promotion rules for types defined in Base too; try defining a new promotion rule for  Int  and  Float64  and you'll see it has no effect.  If you're wondering where  Unitful.EnergyUnit  comes from, it is defined in  src/pkgdefaults.jl  by the  @derived_dimension  macro. Similarly, the calls to the  @dimension  macro define  Unitful.LengthUnit ,  Unitful.MassUnit , etc. None of these are exported.  Existing users of Unitful may want to call  Unitful.promote_to_derived  after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default.  #  Unitful.promote_to_derived     Function .  Unitful.promote_to_derived()  Defines promotion rules to use derived SI units in promotion for common dimensions of quantities:   J  (joule) for energy  N  (newton) for force  W  (watt) for power  Pa  (pascal) for pressure  C  (coulomb) for charge  V  (volt) for voltage  \u03a9  (ohm) for resistance  F  (farad) for capacitance  H  (henry) for inductance  Wb  (weber) for magnetic flux  T  (tesla) for B-field  J*s  (joule-second) for action   If you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your  .juliarc.jl  file which is loaded when you open Julia. This function is not exported.  source", 
            "title": "Promotion rules for specific dimensions"
        }, 
        {
            "location": "/conversion/#fallback-promotion-rules", 
            "text": "The  Unitful.preferunits  function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.  The default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension  \ud835\udc0c*\ud835\udc0b^2/(\ud835\udc13^2*\ud835\udeaf)  would be converted to  kg*m^2/(s^2*K) :  julia  promote(1.0u J/K , 1.0u g*cm^2/s^2/K )\n(1.0 kg K^-1 m^2 s^-2, 1.0e-7 kg K^-1 m^2 s^-2)  You can however override this behavior by calling  Unitful.preferunits  at the start of a Julia session, specifically  before   upreferred   has been called or quantities have been promoted .  #  Unitful.preferunits     Function .  preferunits(u0::Units, u::Units...)  This function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like \ud835\udc0b or \ud835\udc13 but not \ud835\udc0b/\ud835\udc13 or \ud835\udc0b^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user.  Once  Unitful.upreferred  has been called or quantities have been promoted, this function will appear to have no effect.  Usage example:  preferunits(u\"m,s,A,K,cd,kg,mol\"...)  source", 
            "title": "Fallback promotion rules"
        }, 
        {
            "location": "/conversion/#array-promotion", 
            "text": "Arrays are typed with as much specificity as possible upon creation. consider the following three cases:  julia  [1.0u m , 2.0u m ]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1.0 m\n 2.0 m\n\njulia  [1.0u m , 2.0u cm ]\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n  1.0 m\n 0.02 m\n\njulia  [1.0u m , 2.0]\n2-element Array{Unitful.Quantity{Float64,D,U} where U where D,1}:\n 1.0 m\n   2.0  In the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:  julia  f{T :Unitful.Length}(x::AbstractArray{T}) = sum(x)\nf (generic function with 1 method)\n\njulia  f([1.0u m , 2.0u cm ])\n1.02 m\n\njulia  f([1.0u g , 2.0u cm ])\nERROR: MethodError: no method matching f(::Array{Unitful.Quantity{Float64,D,U} where U where D,1})", 
            "title": "Array promotion"
        }, 
        {
            "location": "/conversion/#advanced-promotion-mechanisms", 
            "text": "There are some new types as of Unitful.jl v0.2.0 that enable some fairly sophisticated promotion logic. Three concrete subtypes of  Unitful.Units{N,D}  are defined:  Unitful.FreeUnits{N,D} ,  Unitful.ContextUnits{N,D,P} , and  Unitful.FixedUnits{N,D} .  Units defined in the Unitful.jl package itself are all  Unitful.FreeUnits{N,D}  objects. The \"free\" in  FreeUnits  indicates that the object carries no information on its own about how it should respond during promotion. Other code in Unitful dictates that by default, quantities should promote to SI units.  FreeUnits  use the promotion mechanisms described in the above section,  Basic promotion mechanisms . They used to be called  Units  in prior versions of Unitful.", 
            "title": "Advanced promotion mechanisms"
        }, 
        {
            "location": "/conversion/#contextunits", 
            "text": "Sometimes, a package may want to default to a particular behavior for promotion, in the presence of other packages that may require differing default behaviors. An example would be a CAD package for nanoscale device design: it makes more sense to promote to nanometers or microns than to meters. For this purpose we define  Unitful.ContextUnits{N,D,P} . The  P  in this type signature should be some type  Unitful.FreeUnits{M,D}  (the dimensions must be the same). We refer to this as the \"context.\"  ContextUnits  may be easily instantiated by e.g.  ContextUnits(nm, \u03bcm)  for a  nm  unit that will promote to  \u03bcm . Here's an example:  julia  \u03bcm = Unitful.ContextUnits(u \u03bcm , u \u03bcm )\n\u03bcm\n\njulia  nm = Unitful.ContextUnits(u nm , u \u03bcm )\nnm\n\njulia  1.0\u03bcm + 1.0nm\n1.001 \u03bcm  If the context does not agree, then we fall back to  FreeUnits :  julia  \u03bcm = Unitful.ContextUnits(u \u03bcm , u \u03bcm )\n\u03bcm\n\njulia  nm = Unitful.ContextUnits(u nm , u cm )\nnm\n\njulia  1.0\u03bcm + 1.0nm\n1.001e-6 m  Multiplying a  ContextUnits  by a  FreeUnits  yields a  ContextUnits  object, with the preferred units for the additional dimensions being determined by calling  upreferred  on the  FreeUnits  object:  julia  mm = Unitful.ContextUnits(u mm , u \u03bcm )\nmm\n\njulia  isa(u g , Unitful.FreeUnits)\ntrue\n\njulia  upreferred(u g )\nkg\n\njulia  mm*u g \ng mm\n\njulia  isa(mm*u g , Unitful.ContextUnits)\ntrue\n\njulia  upreferred(mm*u g )\nkg \u03bcm", 
            "title": "ContextUnits"
        }, 
        {
            "location": "/conversion/#fixedunits", 
            "text": "Sometimes, there may be times where it is required to disable automatic conversion between quantities with different units. For this purpose there are  Unitful.FixedUnits{N,D} . Trying to add or compare two quantities with  FixedUnits  will throw an error, provided the units are not the same. Note that you can still add/compare a quantity with  FixedUnits  to a quantity with another kind of units; in that case, the result units (if applicable) are determined by the  FixedUnits , overriding the preferred units from  ContextUnits  or  FreeUnits . Multiplying  FixedUnits  with any other kind of units returns  FixedUnits :  julia  mm_fix = Unitful.FixedUnits(u mm )\nmm\n\njulia  cm_fix = Unitful.FixedUnits(u cm )\ncm\n\njulia  1mm_fix+2mm_fix\n3 mm\n\njulia  1mm_fix+2u cm   # u cm  is a FreeUnits object.\n21//1 mm\n\njulia  1mm_fix+2*Unitful.ContextUnits(u cm , u cm )\n21//1 mm\n\njulia  isa(mm_fix*u cm , Unitful.FixedUnits)\ntrue\n\njulia  1mm_fix+2cm_fix\nERROR: automatic conversion prohibited.\n[...]\n\njulia  1mm_fix == 1mm_fix\ntrue\n\njulia  1mm_fix == 0.1u cm \ntrue\n\njulia  1mm_fix == 0.1cm_fix\nERROR: automatic conversion prohibited.\n[...]  Much of this functionality is enabled by  promote_unit  definitions. These are not readily extensible by the user at this point.  #  Unitful.promote_unit     Function .  promote_unit(::Units, ::Units...)  Given  Units  objects as arguments, this function returns a  Units  object appropriate for the result of promoting quantities which have these units. This function is kind of like  promote_rule , except that it doesn't take types. It also does not return a tuple, but rather just a  Unitful.Units  object (or it throws an error).  Although we had used  promote_rule  for  Units  objects in prior versions of Unitful, this was always kind of a hack; it doesn't make sense to promote units directly for a variety of reasons.  source", 
            "title": "FixedUnits"
        }, 
        {
            "location": "/conversion/#unit-cancellation", 
            "text": "For multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance,  mV/V  is not simplified, although  V/V  is. Also,  N*m/J  is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Unit cancellation"
        }, 
        {
            "location": "/manipulations/", 
            "text": "Unitful string macro\n\n\n#\n\n\nUnitful.@u_str\n \n \nMacro\n.\n\n\n@u_str(unit)\n\n\n\n\n\nString macro to easily recall units, dimensions, or quantities defined in unit modules that have been registered with \nUnitful.register\n.\n\n\nIf the same symbol is used for a \nUnitful.Units\n object defined in different modules, then the symbol found in the most recently registered module will be used.\n\n\nNote that what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".\n\n\nExamples:\n\n\njulia\n 1.0u\nm/s\n\n1.0 m s^-1\n\njulia\n 1.0u\nN*m\n\n1.0 m N\n\njulia\n u\nm,kg,s\n\n(m, kg, s)\n\njulia\n typeof(1.0u\nm/s\n)\nQuantity{Float64, Dimensions:{\ud835\udc0b \ud835\udc13^-1}, Units:{m s^-1}}\n\njulia\n u\n\u0127\n\n1.0545718001391127e-34 J s\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.register\n \n \nFunction\n.\n\n\nregister(unit_module::Module)\n\n\n\n\n\nMakes the \n@u_str\n macro aware of units defined in new unit modules. By default, Unitful is itself a registered module. Note that Main is not, so if you define new units at the REPL, you will probably want to do \nUnitful.register(Main)\n.\n\n\nExample:\n\n\n# somewhere in a custom units package...\n\n\nmodule\n \nMyUnitsPackage\n\n\nusing\n \nUnitful\n\n\n\nfunction\n \n__init__\n()\n\n    \n...\n\n    \nUnitful\n.\nregister\n(\nMyUnitsPackage\n)\n\n\nend\n\n\nend\n \n#module\n\n\n\n\n\n\nsource\n\n\n\n\nDimension and unit inspection\n\n\nWe define a function \ndimension\n that turns, for example, \nacre^2\n or \n1*acre^2\n into \n\ud835\udc0b^4\n. We can usually add quantities with the same dimension, regardless of specific units (\nFixedUnits\n cannot be automatically converted, however). Note that dimensions cannot be determined by powers of the units: \nft^2\n is an area, but so is \nac^1\n (an acre).\n\n\nThere is also a function \nunit\n that turns, for example, \n1*acre^2\n into \nacre^2\n. You can then query whether the units are \nFreeUnits\n, \nFixedUnits\n, etc.\n\n\n#\n\n\nUnitful.unit\n \n \nFunction\n.\n\n\nunit(x::Quantity{T,D,U}) where {T,D,U}\nunit(x::Type{Quantity{T,D,U}}) where {T,D,U}\n\n\n\n\n\nReturns the units associated with a \nQuantity\n or \nQuantity\n type.\n\n\nExamples:\n\n\njulia\n unit(1.0u\nm\n) == u\nm\n\ntrue\n\njulia\n unit(typeof(1.0u\nm\n)) == u\nm\n\ntrue\n\n\n\n\n\nsource\n\n\nunit(x::Number)\n\n\n\n\n\nReturns a \nUnitful.Units{(), Dimensions{()}}\n object to indicate that ordinary numbers have no units. This is a singleton, which we export as \nNoUnits\n. The unit is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n typeof(unit(1.0))\nUnitful.FreeUnits{(),Unitful.Dimensions{()}}\n\njulia\n typeof(unit(Float64))\nUnitful.FreeUnits{(),Unitful.Dimensions{()}}\n\njulia\n unit(1.0) == NoUnits\ntrue\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(x::Number)\ndimension(x::Type{T}) where {T\n:Number}\n\n\n\n\n\nReturns a \nUnitful.Dimensions{()}\n object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as \nNoDims\n. The dimension is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n typeof(dimension(1.0))\nUnitful.Dimensions{()}\njulia\n typeof(dimension(Float64))\nUnitful.Dimensions{()}\njulia\n dimension(1.0) == NoDims\ntrue\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(u::Units{U,D}) where {U,D}\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(u\nm\n))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia\n typeof(dimension(u\nm/km\n))\nUnitful.Dimensions{()}\n\n\n\n\n\nsource\n\n\ndimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(1.0u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(1.0u\nm/\u03bcm\n))\nUnitful.Dimensions{()}\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(u::Units{U,D}) where {U,D}\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(u\nm\n))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia\n typeof(dimension(u\nm/km\n))\nUnitful.Dimensions{()}\n\n\n\n\n\nsource\n\n\ndimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(1.0u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(1.0u\nm/\u03bcm\n))\nUnitful.Dimensions{()}\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(u::Units{U,D}) where {U,D}\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(u\nm\n))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia\n typeof(dimension(u\nm/km\n))\nUnitful.Dimensions{()}\n\n\n\n\n\nsource\n\n\ndimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n dimension(1.0u\nm\n)\n\ud835\udc0b\n\njulia\n typeof(dimension(1.0u\nm/\u03bcm\n))\nUnitful.Dimensions{()}\n\n\n\n\n\nsource\n\n\n\n\nUnit stripping\n\n\n#\n\n\nUnitful.ustrip\n \n \nFunction\n.\n\n\nustrip(x::Number)\nustrip(x::Quantity)\n\n\n\n\n\nReturns the number out in front of any units. The value of \nx\n may differ from the number out front of the units in the case of dimensionless quantities, e.g. \n1m/mm != 1\n. See \nuconvert\n and the example below. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is mainly intended for compatibility with packages that don't know how to handle quantities.\n\n\njulia\n ustrip(2u\n\u03bcm/m\n) == 2\ntrue\n\njulia\n uconvert(NoUnits, 2u\n\u03bcm/m\n) == 2//1000000\ntrue\n\n\n\n\n\nsource\n\n\nustrip(x::Array{Q}) where {Q \n: Quantity}\n\n\n\n\n\nStrip units from an \nArray\n by reinterpreting to type \nT\n. The resulting \nArray\n is a not a copy, but rather a unit-stripped view into array \nx\n. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example.\n\n\njulia\n a = [1u\nm\n, 2u\nm\n]\n2-element Array{Quantity{Int64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1 m\n 2 m\n\njulia\n b = ustrip(a)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia\n a[1] = 3u\nm\n; b\n2-element Array{Int64,1}:\n 3\n 2\n\n\n\n\n\nsource\n\n\nustrip(A::Diagonal)\nustrip(A::Bidiagonal)\nustrip(A::Tridiagonal)\nustrip(A::SymTridiagonal)\n\n\n\n\n\nStrip units from various kinds of matrices by calling \nustrip\n on the underlying vectors.\n\n\nsource\n\n\n\n\nUnit multiplication\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Units, a::Units...)\n\n\n\n\n\nGiven however many units, multiply them together. This is actually handled by a few different methods, since we have \nFreeUnits\n, \nContextUnits\n, and \nFixedUnits\n.\n\n\nCollect \nUnitful.Unit\n objects from the type parameter of the \nUnitful.Units\n objects. For identical units including SI prefixes (i.e. cm \u2260 m), collect powers and sort uniquely by the name of the \nUnit\n. The unique sorting permits easy unit comparisons.\n\n\nExamples:\n\n\njulia\n u\nkg*m/s^2\n\nkg m s^-2\n\njulia\n u\nm/s*kg/s\n\nkg m s^-2\n\njulia\n typeof(u\nm/s*kg/s\n) == typeof(u\nkg*m/s^2\n)\ntrue\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Dimensions, a::Dimensions...)\n\n\n\n\n\nGiven however many dimensions, multiply them together.\n\n\nCollect \nUnitful.Dimension\n objects from the type parameter of the \nUnitful.Dimensions\n objects. For identical dimensions, collect powers and sort uniquely by the name of the \nDimension\n.\n\n\nExamples:\n\n\njulia\n u\n\ud835\udc0c*\ud835\udc0b/\ud835\udc13^2\n\n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\njulia\n u\n\ud835\udc0b*\ud835\udc0c/\ud835\udc13^2\n\n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\njulia\n typeof(u\n\ud835\udc0b*\ud835\udc0c/\ud835\udc13^2\n) == typeof(u\n\ud835\udc0c*\ud835\udc0b/\ud835\udc13^2\n)\ntrue\n\n\n\n\n\nsource", 
            "title": "Manipulating units"
        }, 
        {
            "location": "/manipulations/#unitful-string-macro", 
            "text": "#  Unitful.@u_str     Macro .  @u_str(unit)  String macro to easily recall units, dimensions, or quantities defined in unit modules that have been registered with  Unitful.register .  If the same symbol is used for a  Unitful.Units  object defined in different modules, then the symbol found in the most recently registered module will be used.  Note that what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".  Examples:  julia  1.0u m/s \n1.0 m s^-1\n\njulia  1.0u N*m \n1.0 m N\n\njulia  u m,kg,s \n(m, kg, s)\n\njulia  typeof(1.0u m/s )\nQuantity{Float64, Dimensions:{\ud835\udc0b \ud835\udc13^-1}, Units:{m s^-1}}\n\njulia  u \u0127 \n1.0545718001391127e-34 J s  source  #  Unitful.register     Function .  register(unit_module::Module)  Makes the  @u_str  macro aware of units defined in new unit modules. By default, Unitful is itself a registered module. Note that Main is not, so if you define new units at the REPL, you will probably want to do  Unitful.register(Main) .  Example:  # somewhere in a custom units package...  module   MyUnitsPackage  using   Unitful  function   __init__ () \n     ... \n     Unitful . register ( MyUnitsPackage )  end  end   #module   source", 
            "title": "Unitful string macro"
        }, 
        {
            "location": "/manipulations/#dimension-and-unit-inspection", 
            "text": "We define a function  dimension  that turns, for example,  acre^2  or  1*acre^2  into  \ud835\udc0b^4 . We can usually add quantities with the same dimension, regardless of specific units ( FixedUnits  cannot be automatically converted, however). Note that dimensions cannot be determined by powers of the units:  ft^2  is an area, but so is  ac^1  (an acre).  There is also a function  unit  that turns, for example,  1*acre^2  into  acre^2 . You can then query whether the units are  FreeUnits ,  FixedUnits , etc.  #  Unitful.unit     Function .  unit(x::Quantity{T,D,U}) where {T,D,U}\nunit(x::Type{Quantity{T,D,U}}) where {T,D,U}  Returns the units associated with a  Quantity  or  Quantity  type.  Examples:  julia  unit(1.0u m ) == u m \ntrue\n\njulia  unit(typeof(1.0u m )) == u m \ntrue  source  unit(x::Number)  Returns a  Unitful.Units{(), Dimensions{()}}  object to indicate that ordinary numbers have no units. This is a singleton, which we export as  NoUnits . The unit is displayed as an empty string.  Examples:  julia  typeof(unit(1.0))\nUnitful.FreeUnits{(),Unitful.Dimensions{()}}\n\njulia  typeof(unit(Float64))\nUnitful.FreeUnits{(),Unitful.Dimensions{()}}\n\njulia  unit(1.0) == NoUnits\ntrue  source  #  Unitful.dimension     Method .  dimension(x::Number)\ndimension(x::Type{T}) where {T :Number}  Returns a  Unitful.Dimensions{()}  object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as  NoDims . The dimension is displayed as an empty string.  Examples:  julia  typeof(dimension(1.0))\nUnitful.Dimensions{()}\njulia  typeof(dimension(Float64))\nUnitful.Dimensions{()}\njulia  dimension(1.0) == NoDims\ntrue  source  #  Unitful.dimension     Method .  dimension(u::Units{U,D}) where {U,D}  Returns a  Unitful.Dimensions  object corresponding to the dimensions of the units,  D() . For a dimensionless combination of units, a  Unitful.Dimensions{()}  object is returned.  Examples:  julia  dimension(u m )\n\ud835\udc0b\n\njulia  typeof(dimension(u m ))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia  typeof(dimension(u m/km ))\nUnitful.Dimensions{()}  source  dimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}  Returns a  Unitful.Dimensions  object  D()  corresponding to the dimensions of quantity  x . For a dimensionless  Unitful.Quantity , a  Unitful.Dimensions{()}  object is returned.  Examples:  julia  dimension(1.0u m )\n\ud835\udc0b\n\njulia  typeof(dimension(1.0u m/\u03bcm ))\nUnitful.Dimensions{()}  source  #  Unitful.dimension     Method .  dimension(u::Units{U,D}) where {U,D}  Returns a  Unitful.Dimensions  object corresponding to the dimensions of the units,  D() . For a dimensionless combination of units, a  Unitful.Dimensions{()}  object is returned.  Examples:  julia  dimension(u m )\n\ud835\udc0b\n\njulia  typeof(dimension(u m ))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia  typeof(dimension(u m/km ))\nUnitful.Dimensions{()}  source  dimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}  Returns a  Unitful.Dimensions  object  D()  corresponding to the dimensions of quantity  x . For a dimensionless  Unitful.Quantity , a  Unitful.Dimensions{()}  object is returned.  Examples:  julia  dimension(1.0u m )\n\ud835\udc0b\n\njulia  typeof(dimension(1.0u m/\u03bcm ))\nUnitful.Dimensions{()}  source  #  Unitful.dimension     Method .  dimension(u::Units{U,D}) where {U,D}  Returns a  Unitful.Dimensions  object corresponding to the dimensions of the units,  D() . For a dimensionless combination of units, a  Unitful.Dimensions{()}  object is returned.  Examples:  julia  dimension(u m )\n\ud835\udc0b\n\njulia  typeof(dimension(u m ))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia  typeof(dimension(u m/km ))\nUnitful.Dimensions{()}  source  dimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}  Returns a  Unitful.Dimensions  object  D()  corresponding to the dimensions of quantity  x . For a dimensionless  Unitful.Quantity , a  Unitful.Dimensions{()}  object is returned.  Examples:  julia  dimension(1.0u m )\n\ud835\udc0b\n\njulia  typeof(dimension(1.0u m/\u03bcm ))\nUnitful.Dimensions{()}  source", 
            "title": "Dimension and unit inspection"
        }, 
        {
            "location": "/manipulations/#unit-stripping", 
            "text": "#  Unitful.ustrip     Function .  ustrip(x::Number)\nustrip(x::Quantity)  Returns the number out in front of any units. The value of  x  may differ from the number out front of the units in the case of dimensionless quantities, e.g.  1m/mm != 1 . See  uconvert  and the example below. Because the units are removed, information may be lost and this should be used with some care.  This function is mainly intended for compatibility with packages that don't know how to handle quantities.  julia  ustrip(2u \u03bcm/m ) == 2\ntrue\n\njulia  uconvert(NoUnits, 2u \u03bcm/m ) == 2//1000000\ntrue  source  ustrip(x::Array{Q}) where {Q  : Quantity}  Strip units from an  Array  by reinterpreting to type  T . The resulting  Array  is a not a copy, but rather a unit-stripped view into array  x . Because the units are removed, information may be lost and this should be used with some care.  This function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example.  julia  a = [1u m , 2u m ]\n2-element Array{Quantity{Int64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n 1 m\n 2 m\n\njulia  b = ustrip(a)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia  a[1] = 3u m ; b\n2-element Array{Int64,1}:\n 3\n 2  source  ustrip(A::Diagonal)\nustrip(A::Bidiagonal)\nustrip(A::Tridiagonal)\nustrip(A::SymTridiagonal)  Strip units from various kinds of matrices by calling  ustrip  on the underlying vectors.  source", 
            "title": "Unit stripping"
        }, 
        {
            "location": "/manipulations/#unit-multiplication", 
            "text": "#  Base.:*     Method .  *(a0::Units, a::Units...)  Given however many units, multiply them together. This is actually handled by a few different methods, since we have  FreeUnits ,  ContextUnits , and  FixedUnits .  Collect  Unitful.Unit  objects from the type parameter of the  Unitful.Units  objects. For identical units including SI prefixes (i.e. cm \u2260 m), collect powers and sort uniquely by the name of the  Unit . The unique sorting permits easy unit comparisons.  Examples:  julia  u kg*m/s^2 \nkg m s^-2\n\njulia  u m/s*kg/s \nkg m s^-2\n\njulia  typeof(u m/s*kg/s ) == typeof(u kg*m/s^2 )\ntrue  source  #  Base.:*     Method .  *(a0::Dimensions, a::Dimensions...)  Given however many dimensions, multiply them together.  Collect  Unitful.Dimension  objects from the type parameter of the  Unitful.Dimensions  objects. For identical dimensions, collect powers and sort uniquely by the name of the  Dimension .  Examples:  julia  u \ud835\udc0c*\ud835\udc0b/\ud835\udc13^2 \n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\njulia  u \ud835\udc0b*\ud835\udc0c/\ud835\udc13^2 \n\ud835\udc0b \ud835\udc0c \ud835\udc13^-2\n\njulia  typeof(u \ud835\udc0b*\ud835\udc0c/\ud835\udc13^2 ) == typeof(u \ud835\udc0c*\ud835\udc0b/\ud835\udc13^2 )\ntrue  source", 
            "title": "Unit multiplication"
        }, 
        {
            "location": "/display/", 
            "text": "#\n\n\nUnitful.abbr\n \n \nFunction\n.\n\n\nabbr(x)\n provides abbreviations for units or dimensions. Since a method should always be defined for each unit and dimension type, absence of a method for a specific unit or dimension type is likely an error. Consequently, we return \u2753 for generic arguments to flag unexpected behavior.\n\n\nsource\n\n\n#\n\n\nUnitful.prefix\n \n \nFunction\n.\n\n\nprefix(x::Unit)\n\n\n\n\n\nReturns a string representing the SI prefix for the power-of-ten held by this particular unit.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO, x::Quantity)\n\n\n\n\n\nShow a unitful quantity by calling \nshow\n on the numeric value, appending a space, and then calling \nshow\n on a units object \nU()\n.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow{T,D,U}(io::IO, ::Type{Quantity{T,D,U}})\n\n\n\n\n\nShow the type of a unitful quantity in a succinct way. Otherwise, array summaries are nearly unreadable.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO, x::Unitlike)\n\n\n\n\n\nCall \nUnitful.showrep\n on each object in the tuple that is the type variable of a \nUnitful.Units\n or \nUnitful.Dimensions\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Unit)\n\n\n\n\n\nShow the unit, prefixing with any decimal prefix and appending the exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Dimension)\n\n\n\n\n\nShow the dimension, appending any exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.superscript\n \n \nFunction\n.\n\n\nsuperscript(i::Rational)\n\n\n\n\n\nPrints exponents.\n\n\nsource", 
            "title": "How units are displayed"
        }, 
        {
            "location": "/logarithm/", 
            "text": "Unitful provides a way to use logarithmically-scaled quantities as of v0.4.0. Some compromises have been made in striving for logarithmic quantities to be both usable and consistent. In the following discussion, for pedagogical purposes, we will assume prior familiarity with the definitions of \ndB\n and \ndBm\n.\n\n\n\n\nConstructing logarithmic quantities\n\n\nLeft- or right-multiplying a pure number by a logarithmic \"unit\", whether dimensionful or dimensionless, is short-hand for constructing a logarithmic quantity.\n\n\njulia\n 3u\ndB\n\n3 dB\n\njulia\n 3u\ndBm\n\n3.0 dBm\n\njulia\n u\ndB\n*3 === 3u\ndB\n\ntrue\n\n\n\n\n\nCurrently implemented are \ndB\n, \nB\n, \ndBm\n, \ndBV\n, \ndBu\n, \ndB\u03bcV\n, \ndBSPL\n, \ndBFS\n, \ncNp\n, \nNp\n.\n\n\nOne can also construct logarithmic quantities using the \n@dB\n, \n@B\n, \n@cNp\n, \n@Np\n macros to use an arbitrary reference level:\n\n\njulia\n using Unitful: mW, V\n\njulia\n @dB 10mW/mW\n10.0 dBm\n\njulia\n @dB 10V/V\n20.0 dBV\n\njulia\n @dB 3V/4V\n-2.498774732165999 dB (4 V)\n\njulia\n @Np e*V/V    # e = 2.71828...\n1.0 Np (1 V)\n\n\n\n\n\nThese macros are exported by default since empirically macros are defined less often than variables and generic functions. When using the macros, the levels are constructed at parse time. The scales themselves are callable as functions if you need to construct a level that way (they are not exported):\n\n\njulia\n using Unitful: dB, mW, V\n\njulia\n dB(10mW,mW)\n10.0 dBm\n\n\n\n\n\nIn calculating the logarithms, the log function appropriate to the scale in question is used (\nlog10\n for decibels, \nlog\n for nepers).\n\n\nThere is an important difference in these two approaches to constructing logarithmic quantities. When we construct \n0dBm\n, the power in \nmW\n is calculated and stored, resulting in a lossy floating-point conversion. This can be avoided by constructing \n0 dBm\n as \n@dB 1mW/mW\n.\n\n\nIt is important to keep in mind that the reference level is just used to calculate the logarithms, and nothing more. When there is ambiguity about what to do, we fall back to the underlying linear quantities, paying no mind to the reference levels:\n\n\njulia\n using Unitful: mW\n\njulia\n (@dB 10mW/1mW) + (@dB 10mW/2mW)\n20 mW\n\n\n\n\n\nAddition will be discussed more later.\n\n\nNote that logarithmic \"units\" can only multiply or be multiplied by pure numbers, not other units or quantities. This is done to avoid issues with commutativity and associativity, e.g. \n3*dB*m^-1 == (3dB)/m\n, but \n3*m^-1*dB == (3m^-1)*dB\n does not make much sense. This is because \ndB\n acts more like a constructor than a proper unit. In this package and in the documentation, we take some pains to avoid using the term \"logarithmic units\" where possible, and the usage and design of this package reflects that.\n\n\nThe \n@dB\n and \n@Np\n macros will fail if either a dimensionless number or a ratio of dimensionless numbers is used. This is because the ratio could be of power quantities or of root-power quantities, leading to ambiguities. After all, usually it is the ratio that is dimensionless, not the numerator and denominator that make up the ratio. In some cases it may nonetheless be convenient to have a dimensionless reference level. By providing an extra \nBool\n argument to these macros, you can explicitly choose whether the resulting ratio should be considered a \"root-power\" or \"power\" ratio. You can only do this for dimensionless numbers:\n\n\njulia\n @dB 10/1 true   # is a root-power (amplitude) ratio\n20.0 dBFS\n\njulia\n @dB 10/1 false  # is not a root-power ratio; is a power ratio\n10.0 dB (power ratio with reference 1)\n\n\n\n\n\nNote that \ndBFS\n is defined to represent amplitudes relative to 1 in \ndB\n, hence the custom display logic.\n\n\nAlso, you can of course use functions instead of macros:\n\n\njulia\n using Unitful: dB, mW\n\njulia\n dB(10,1,true)\n20.0 dBFS\n\njulia\n dB(10mW,mW,true)\nERROR: ArgumentError: when passing a final Bool argument, this can only be used with dimensionless numbers.\n[...]\n\n\n\n\n\n\n\nLogarithmic quantities with no reference level specified\n\n\nLogarithmic quantities with no reference level specified typically represent some amount of gain or attenuation, i.e. a ratio which is dimensionless. These can be constructed as, for example, \n10*dB\n, which displays similarly (\n10 dB\n). The type of this kind of logarithmic quantity is:\n\n\n#\n\n\nUnitful.Gain\n \n \nType\n.\n\n\nstruct Gain{L, T\n:Real} \n: LogScaled{L}\n\n\n\n\n\nA logarithmic scale-based gain or attenuation factor. This type has one field, \nval::T\n. For example, given a gain of \n20dB\n, we have \nval===20\n. This type differs from \nUnitful.Level\n in that \nval\n is stored after computing the logarithm.\n\n\nsource\n\n\nOne might expect that any dimensionless quantity should be convertible to a pure number, that is, to \nx\n if you had \n10*log10(x)\n dB. However, it turns out that in dB, a ratio of powers is defined as \n10*log10(x)\n, but a ratio of voltages or other root-power quantities is defined as \n20*log10(x)\n. Clearly, converting back from decibels to a real number is ambiguous, and so we have not implemented automatic promotion to avoid incorrect results. You can use \nUnitful.powerratio\n to interpret a \nGain\n as a ratio of power quantities, or \nUnitful.rootpowerratio\n (equivalently \nfieldratio\n) to interpret as a ratio of field quantities.\n\n\n\n\n\"Dimensionful\" logarithmic quantities?\n\n\nIn this package, quantities with units like \ndBm\n are considered to have the dimension of power, even though the expression \nP(dBm) = 10*log10(P/1mW)\n is dimensionless and formed from a dimensionless ratio. Practically speaking, these kinds of logarithmic quantities are fungible whenever they share the same dimensions, so it is more convenient to adopt this convention (people refer to \ndBm/Hz\n as a power spectral density, etc.) Presumably, one would like to have \n10dBm isa Unitful.Power\n for dispatch too. Therefore, in the following discussion, we will shamelessly (okay, with some shame) speak of dimensionful logarithmic quantities, or \nLevel\ns for short:\n\n\n#\n\n\nUnitful.Level\n \n \nType\n.\n\n\nstruct Level{L, S, T\n:Number} \n: LogScaled{L}\n\n\n\n\n\nA logarithmic scale-based level. Details about the logarithmic scale are encoded in \nL \n: LogInfo\n. \nS\n is a reference quantity for the level, not a type. This type has one field, \nval::T\n, and the log of the ratio \nval/S\n is taken. This type differs from \nUnitful.Gain\n in that \nval\n is a linear quantity.\n\n\nsource\n\n\nActually, the defining characteristic of a \nLevel\n is that it has a reference level, which may or may not be dimensionful. It usually is, but is not in the case of e.g. \ndBFS\n.\n\n\nFinally, for completeness we note that both \nLevel\n and \nGain\n are subtypes of \nLogScaled\n:\n\n\n#\n\n\nUnitful.LogScaled\n \n \nType\n.\n\n\nabstract type LogScaled{L\n:LogInfo} \n: Number end\n\n\n\n\n\nAbstract supertype of \nUnitful.Level\n and \nUnitful.Gain\n. It is only used in promotion to put levels and gains onto a common log scale.\n\n\nsource\n\n\n\n\nMultiplication rules\n\n\nMultiplying a dimensionless logarithmic quantity by a pure number acts as like it does for linear quantities:\n\n\njulia\n 3u\ndB\n * 2\n6 dB\n\njulia\n 2 * 0u\ndB\n\n0 dB\n\n\n\n\n\nJustification by example: consider the example of the exponential attenuation of a signal on a lossy transmission line. If the attenuation goes like $10^{-kx}$, then the (power) attenuation in dB is $-10kx$. We see that the attenuation in dB is linear in length. For an attenuation constant of 3dB/m, we better calculate 6dB for a length of 2m.\n\n\nMultiplying a dimensionful logarithmic quantity by a pure number acts differently than multiplying a gain/attenuation by a pure number. Since \n0dBm == 1mW\n, we better have that \n0dBm * 2 == 2mW\n, implying:\n\n\njulia\n 0u\ndBm\n * 2\n3.010299956639812 dBm\n\n\n\n\n\nLogarithmic quantities can only be multiplied by pure numbers, linear units, or quantities, but not logarithmic \"units\" or quantities.  When a logarithmic quantity is multiplied by a linear quantity, the logarithmic quantity is linearized and multiplication proceeds as usual:\n\n\njulia\n (0u\ndBm\n) * (1u\nW\n)\n1.0 mW W\n\n\n\n\n\nThe previous example returns a floating point value because in constructing the level \n0 dBm\n, the power in \nmW\n is calculated and stored, entailing a floating point conversion. This can be avoided by constructing \n0 dBm\n as \n@dB 1mW/mW\n:\n\n\njulia\n (@dB 1u\nmW\n/u\nmW\n) * (1u\nW\n)\n1 mW W\n\n\n\n\n\nWe refer to a quantity with both logarithmic \"units\" and linear units as a mixed quantity. For mixed quantities, the numeric value associates with the logarithmic unit, and the quantity is displayed in a way that makes this explicit:\n\n\njulia\n (0u\ndBm\n)/u\nHz\n\n[0.0 dBm] Hz^-1\n\njulia\n (0u\ndB\n)/u\nHz\n\n[0 dB] Hz^-1\n\njulia\n 0u\ndB/Hz\n\n[0 dB] Hz^-1\n\n\n\n\n\nMathematical operations are forwarded to the logarithmic part, so that for example, \n100*((0dBm)/s) == (20dBm)/s\n. We allow linear units to commute with logarithmic quantities for convenience, though the association is understood (e.g. \ns^-1*(3dBm) == (3dBm)/s\n).\n\n\nThe behavior of multiplication is summarized in the following table, with entries marked by \u2020 indicate prohibited operations. This table is populated automatically whenever the docs are built.\n\n\n \n \n \n*\n \n10\n \nHz^-1\n \ndB\n \ndBm\n \n1/Hz\n \n1mW\n \n3dB\n \n3dBm\n \n \n \n \n \n10\n \n\n\n100\n\n\n\n \n\n\n\n10 Hz^-1\n\n\n\n \n\n\n\n10 dB\n\n\n\n \n\n\n\n10.0 dBm\n\n\n\n \n\n\n\n10 Hz^-1\n\n\n\n \n\n\n\n10 mW\n\n\n\n \n\n\n\n30 dB\n\n\n\n \n\n\n\n13.0 dBm\n\n\n\n \n \n \nHz^-1\n \n \n\n\n\nHz^-2\n\n\n\n \n\n\n\ndB Hz^-1\n\n\n\n \n\n\n\ndBm Hz^-1\n\n\n\n \n\n\n\n1 Hz^-2\n\n\n\n \n\n\n\n1 Hz^-1 mW\n\n\n\n \n\n\n\n[3 dB] Hz^-1\n\n\n\n \n\n\n\n[3.0 dBm] Hz^-1\n\n\n\n \n \n \ndB\n \n \n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \ndBm\n \n \n \n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \n1/Hz\n \n \n \n \n \n\n\n\n1 Hz^-2\n\n\n\n \n\n\n\n1 Hz^-1 mW\n\n\n\n \n\n\n\n\u2020\n\n\n\u2021 \n \n\n\n\n1.9952623149688795 Hz^-1 mW\n\n\n\n \n \n \n1mW\n \n \n \n \n \n \n\n\n\n1 mW^2\n\n\n\n \n\n\n\n1.9952623149688795 mW\n\n\n\n \n\n\n\n1.9952623149688795 mW^2\n\n\n\n \n \n \n3dB\n \n \n \n \n \n \n \n\n\n\n6 dB\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \n3dBm\n \n \n \n \n \n \n \n \n\n\n\n3.9810717055349722 mW^2\n\n\n\n \n \n \n\n\n\n\u2021: \n1/Hz * 3dB\n could be allowed, technically, but we throw an error its unclear if a quantity is a root-power or power quantity:\n\n\njulia\n u\n1/Hz\n * u\n3dB\n\nERROR: undefined behavior. Please file an issue with the code needed to reproduce.\n\n\n\n\n\nOn the other hand, if it can be determined that a power quantity or root-power quantity is being multiplied by a gain, then the gain is interpreted as a power ratio or root-power ratio, respectively:\n\n\njulia\n 1u\nmW\n * 20u\ndB\n\n100.0 mW\n\njulia\n 1u\nV\n * 20u\ndB\n\n10.0 V\n\n\n\n\n\n\n\nAddition rules\n\n\nWe can add logarithmic quantities without reference levels specified (\nGain\ns):\n\n\njulia\n 20u\ndB\n + 20u\ndB\n\n40 dB\n\n\n\n\n\nThe numbers out front of the \ndB\n just add: when we talk about gain or attenuation, we work in logarithmic units so that we can add rather than multiply gain factors. The same behavior holds when we add a \nGain\n to a \nLevel\n or vice versa:\n\n\njulia\n 20u\ndBm\n + 20u\ndB\n\n40.0 dBm\n\n\n\n\n\nIn the case where you have differing logarithmic scales for the \nLevel\n and the \nGain\n, the logarithmic scale of the \nLevel\n is used for the result:\n\n\njulia\n 10u\ndBm\n - 1u\nNp\n\n1.3141103619349632 dBm\n\n\n\n\n\nFor logarithmic quantities with the same reference levels, the numbers out in front do not simply add:\n\n\njulia\n 20u\ndBm\n + 20u\ndBm\n\n23.010299956639813 dBm\n\njulia\n 2 * 20u\ndBm\n\n23.010299956639813 dBm\n\n\n\n\n\nThis is because \ndBm\n represents a power, ultimately. If we have some amount of power and we double it, we'd better get roughly \n3 dB\n more power. Note that the juxtaposition \n20dBm\n will ensure that 20 dBm is constructed before multiplication by 2 in the above example. If you were to type \n2*20*dBm\n, you'd get 40 dBm.\n\n\nIf the reference levels differ but both levels represent a power, we fall back to linear quantities:\n\n\njulia\n 20u\ndBm\n + @dB 1u\nW\n/u\nW\n\n1.1 kg m^2 s^-3\n\n\n\n\n\ni.e. \n1.1 W\n.\n\n\nRules for addition are summarized in the following table, with entries marked by \u2020 indicating prohibited operations. This table is populated automatically whenever the docs are built.\n\n\n \n \n \n+\n \n100\n \n20dB\n \n1Np\n \n10.0dBm\n \n10.0dBv\n \n1mW\n \n \n \n \n \n100\n \n\n\n200\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \n20dB\n \n \n\n\n\n40 dB\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n30.0 dBm\n\n\n\n \n\n\n\n30.0 dBV\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \n1Np\n \n \n \n\n\n\n2 Np\n\n\n\n \n\n\n\n18.685889638065035 dBm\n\n\n\n \n\n\n\n18.685889638065035 dBV\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \n10.0dBm\n \n \n \n \n\n\n\n13.010299956639813 dBm\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n\n\n\n11.0 mW\n\n\n\n \n \n \n10.0dBV\n \n \n \n \n \n\n\n\n16.020599913279625 dBV\n\n\n\n \n\n\n\n\u2020\n\n\n\n \n \n \n1mW\n \n \n \n \n \n \n\n\n\n2 mW\n\n\n\n \n \n \n\n\n\nNotice that we disallow implicit conversions between dimensionless logarithmic quantities and real numbers. This is because the results can depend on promotion rules in addition to being ambiguous because of the root-power vs. power ratio issue. If \n100 + 10dB\n were evaluated as \n20dB + 10dB == 30dB\n, then we'd get \n1000\n, but if it were evaluated as \n100+10\n, we'd get \n110\n.\n\n\nAlso, although it is possible in principle to add e.g. \n20dB + 1Np\n, notice that we have not implemented that because it is unclear whether the result should be in nepers or decibels, and it is also unclear how to handle that question more generally as other logarithmic scales are introduced.\n\n\n\n\nConversion\n\n\nAs alluded to earlier, conversions can be tricky because so-called logarithmic units are not units in the conventional sense.\n\n\nYou may use \nlinear\n to convert to a linear scale when you have a \nLevel\n or \nQuantity{\n:Level}\n type. There is a fallback for \nNumber\n, which just returns the number.\n\n\njulia\n linear(@dB 10u\nmW\n/u\nmW\n)\n10 mW\n\njulia\n linear(20u\ndBm/Hz\n)\n100.0 Hz^-1 mW\n\njulia\n linear(30u\nW\n)\n30 W\n\njulia\n linear(12)\n12\n\n\n\n\n\nLinearizing a \nQuantity{\n:Gain}\n or a \nGain\n to a real number is ambiguous, because the real number may represent a ratio of powers or a ratio of root-power (field) quantities. We implement \nUnitful.powerratio\n and \nUnitful.rootpowerratio\n which may be thought of as disambiguated \nuconvert\n functions. There is a one argument version that assumes you are converting to a unitless number. These functions can take either a \nGain\n or a \nReal\n so that they may be used somewhat generically.\n\n\njulia\n fieldratio(NoUnits, 20u\ndB\n)    # the first argument is optional when it is `NoUnits`\n10.0\n\njulia\n fieldratio(20u\ndB\n)\n10.0\n\njulia\n powerratio(NoUnits, 20u\ndB\n)  \n100.0\n\njulia\n powerratio(u\ndB\n, 100)\n20.0 dB\n\njulia\n powerratio(u\nNp\n, e^2)\n1.0 Np\n\njulia\n fieldratio(u\nNp\n, e)\n1//1 Np\n\n\n\n\n\nTo save typing you can use \nfieldratio\n instead of \nrootpowerratio\n, although according to the infallible source \nWikipedia\n:\n\n\n\n\nThe term root-power quantity is introduced by ISO Standard 80000-1:2009 as a substitute of field quantity. The term field quantity is deprecated by that standard.\n\n\n\n\nI would check the primary source but I'm too cheap to pay for the ISO standard. Sorry!\n\n\n\n\nNotation\n\n\nThis package displays logarithmic quantities using shorthand like \ndBm\n where available. This should probably not be done in polite company. To quote \"Guide for the Use of the International System of Units (SI),\" NIST Special Pub. 811 (2008):\n\n\n\n\nThe rules of Ref. [5: IEC 60027-3] preclude, for example, the use of the symbol dBm to indicate a reference level of power of 1 mW. This restriction is based on the rule of Sec. 7.4, which does not permit attachments to unit symbols.\n\n\n\n\nThe authorities say the reference level should always specified. In practice, this hasn't stopped the use of \ndBm\n and the like on commercially available test equipment. Dealing with these units is unavoidable in practice. When no shorthand exists, we follow NIST's advice in displaying logarithmic quantities:\n\n\n\n\nWhen such data are presented in a table or in a figure, the following condensed notation may be used instead: -0.58 Np (1 \u03bcV/m); 25 dB (20 \u03bcPa).\n\n\n\n\n\n\nCustom logarithmic scales\n\n\n#\n\n\nUnitful.@logscale\n \n \nMacro\n.\n\n\n@logscale(symb,abbr,name,base,prefactor,irp)\n\n\n\n\n\nDefine a logarithmic scale. Unlike with units, there is no special treatment for power-of-ten prefixes (decibels and bels are defined separately). However, arbitrary bases are possible, and computationally appropriate \nlog\n and \nexp\n functions are used in calculations when available (e.g. \nlog2\n, \nlog10\n for base 2 and base 10, respectively).\n\n\nThis macro defines a \nMixedUnits\n object identified by symbol \nsymb\n. This can be used to\n\n\nThis macro also defines another macro available as \n@symb\n. For example, \n@dB\n in the case of decibels. This can be used to construct \nLevel\n objects at parse time. Usage is like \n@dB 3V/1V\n.\n\n\nprefactor\n is the prefactor out in front of the logarithm for this log scale. In all cases it is defined with respect to taking ratios of power quantities. Just divide by two if you want to refer to root-power / field quantities instead.\n\n\nirp\n (short for \"is root power?\") specifies whether the logarithmic scale is defined with respect to ratios of power or root-power quantities. In short: use \nfalse\n if your scale is decibel-like, or \ntrue\n if your scale is neper-like.\n\n\nExamples:\n\n\njulia\n using Unitful: V, W\n\njulia\n @logscale d\u03a0 \nd\u03a0\n Decipies \u03c0 10 false\nd\u03a0\n\njulia\n @d\u03a0 \u03c0*V/1V\n20.0 d\u03a0 (1 V)\n\njulia\n d\u03a0(\u03c0*V, 1V)\n20.0 d\u03a0 (1 V)\n\njulia\n @d\u03a0 \u03c0^2*V/1V\n40.0 d\u03a0 (1 V)\n\njulia\n @d\u03a0 \u03c0*W/1W\n10.0 d\u03a0 (1 W)\n\n\n\n\n\nsource\n\n\n\n\nAPI\n\n\n#\n\n\nUnitful.linear\n \n \nFunction\n.\n\n\nlinear(x::Quantity)\nlinear(x::Level)\nlinear(x::Number) = x\n\n\n\n\n\nReturns a quantity equivalent to \nx\n but without any logarithmic scales.\n\n\nIt is important to note that this operation will error for \nQuantity{\n:Gain}\n types. This is for two reasons:\n\n\n\n\n20dB\n could be interpreted as either a power or root-power ratio.\n\n\nEven if \n-20dB/m\n were interpreted as, say, \n0.01/m\n, this means something fundamentally different than \n-20dB/m\n. \n0.01/m\n cannot be used to calculate exponential attenuation.\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.reflevel\n \n \nFunction\n.\n\n\nreflevel(x::Level{L,S})\nreflevel(::Type{Level{L,S}})\nreflevel(::Type{Level{L,S,T}})\n\n\n\n\n\nReturns the reference level, e.g.\n\n\njulia\n reflevel(3u\ndBm\n)\n1 mW\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.powerratio\n \n \nFunction\n.\n\n\npowerratio(x)\n\n\n\n\n\nTreat \nx\n as a ratio of power quantities (field quantities) and unit-convert to no units.\n\n\npowerratio(u::Units{()}, x::Gain)\npowerratio(u::MixedUnits{\n:Gain}, x::Gain)\n\n\n\n\n\nTreat \nx\n as a ratio of power quantities (field quantities) and unit-convert to \nu\n.\n\n\npowerratio(u::Units{()}, x::Real)\npowerratio(u::MixedUnits{\n:Gain, \n:Units{()})}, x::Real)\n\n\n\n\n\nFall-back methods so that \npowerratio\n may be used with real numbers.\n\n\nIt is important to note that this function is undefined for \nQuantity{\n:Gain}\n types. It is tempting to make this function transform \n-20dB/m\n into \n0.1/m\n, however this means something fundamentally different than \n-20dB/m\n: \n0.1/m\n cannot be used to calculate exponential attenuation.\n\n\nsource\n\n\n#\n\n\nUnitful.rootpowerratio\n \n \nFunction\n.\n\n\nrootpowerratio(x)\n\n\n\n\n\nTreat \nx\n as a ratio of root-power quantities (field quantities) and unit-convert to no units.\n\n\nrootpowerratio(u::Units{()}, x::Gain)\nrootpowerratio(u::MixedUnits{\n:Gain}, x::Gain)\n\n\n\n\n\nTreat \nx\n as a ratio of root-power quantities (field quantities) and unit-convert to \nu\n.\n\n\nrootpowerratio(u::Units{()}, x::Real)\nrootpowerratio(u::MixedUnits{\n:Gain, \n:Units{()})}, x::Real)\n\n\n\n\n\nFall-back methods so that \nrootpowerratio\n may be used with real numbers.\n\n\nIt is important to note that this function is undefined for \nQuantity{\n:Gain}\n types. It is tempting to make this function transform \n-20dB/m\n into \n0.1/m\n, however this means something fundamentally different than \n-20dB/m\n: \n0.1/m\n cannot be used to calculate exponential attenuation.\n\n\nfieldratio\n and \nrootpowerratio\n are synonymous, so you can save some typing if you like.\n\n\nsource", 
            "title": "Logarithmic scales"
        }, 
        {
            "location": "/logarithm/#constructing-logarithmic-quantities", 
            "text": "Left- or right-multiplying a pure number by a logarithmic \"unit\", whether dimensionful or dimensionless, is short-hand for constructing a logarithmic quantity.  julia  3u dB \n3 dB\n\njulia  3u dBm \n3.0 dBm\n\njulia  u dB *3 === 3u dB \ntrue  Currently implemented are  dB ,  B ,  dBm ,  dBV ,  dBu ,  dB\u03bcV ,  dBSPL ,  dBFS ,  cNp ,  Np .  One can also construct logarithmic quantities using the  @dB ,  @B ,  @cNp ,  @Np  macros to use an arbitrary reference level:  julia  using Unitful: mW, V\n\njulia  @dB 10mW/mW\n10.0 dBm\n\njulia  @dB 10V/V\n20.0 dBV\n\njulia  @dB 3V/4V\n-2.498774732165999 dB (4 V)\n\njulia  @Np e*V/V    # e = 2.71828...\n1.0 Np (1 V)  These macros are exported by default since empirically macros are defined less often than variables and generic functions. When using the macros, the levels are constructed at parse time. The scales themselves are callable as functions if you need to construct a level that way (they are not exported):  julia  using Unitful: dB, mW, V\n\njulia  dB(10mW,mW)\n10.0 dBm  In calculating the logarithms, the log function appropriate to the scale in question is used ( log10  for decibels,  log  for nepers).  There is an important difference in these two approaches to constructing logarithmic quantities. When we construct  0dBm , the power in  mW  is calculated and stored, resulting in a lossy floating-point conversion. This can be avoided by constructing  0 dBm  as  @dB 1mW/mW .  It is important to keep in mind that the reference level is just used to calculate the logarithms, and nothing more. When there is ambiguity about what to do, we fall back to the underlying linear quantities, paying no mind to the reference levels:  julia  using Unitful: mW\n\njulia  (@dB 10mW/1mW) + (@dB 10mW/2mW)\n20 mW  Addition will be discussed more later.  Note that logarithmic \"units\" can only multiply or be multiplied by pure numbers, not other units or quantities. This is done to avoid issues with commutativity and associativity, e.g.  3*dB*m^-1 == (3dB)/m , but  3*m^-1*dB == (3m^-1)*dB  does not make much sense. This is because  dB  acts more like a constructor than a proper unit. In this package and in the documentation, we take some pains to avoid using the term \"logarithmic units\" where possible, and the usage and design of this package reflects that.  The  @dB  and  @Np  macros will fail if either a dimensionless number or a ratio of dimensionless numbers is used. This is because the ratio could be of power quantities or of root-power quantities, leading to ambiguities. After all, usually it is the ratio that is dimensionless, not the numerator and denominator that make up the ratio. In some cases it may nonetheless be convenient to have a dimensionless reference level. By providing an extra  Bool  argument to these macros, you can explicitly choose whether the resulting ratio should be considered a \"root-power\" or \"power\" ratio. You can only do this for dimensionless numbers:  julia  @dB 10/1 true   # is a root-power (amplitude) ratio\n20.0 dBFS\n\njulia  @dB 10/1 false  # is not a root-power ratio; is a power ratio\n10.0 dB (power ratio with reference 1)  Note that  dBFS  is defined to represent amplitudes relative to 1 in  dB , hence the custom display logic.  Also, you can of course use functions instead of macros:  julia  using Unitful: dB, mW\n\njulia  dB(10,1,true)\n20.0 dBFS\n\njulia  dB(10mW,mW,true)\nERROR: ArgumentError: when passing a final Bool argument, this can only be used with dimensionless numbers.\n[...]", 
            "title": "Constructing logarithmic quantities"
        }, 
        {
            "location": "/logarithm/#logarithmic-quantities-with-no-reference-level-specified", 
            "text": "Logarithmic quantities with no reference level specified typically represent some amount of gain or attenuation, i.e. a ratio which is dimensionless. These can be constructed as, for example,  10*dB , which displays similarly ( 10 dB ). The type of this kind of logarithmic quantity is:  #  Unitful.Gain     Type .  struct Gain{L, T :Real}  : LogScaled{L}  A logarithmic scale-based gain or attenuation factor. This type has one field,  val::T . For example, given a gain of  20dB , we have  val===20 . This type differs from  Unitful.Level  in that  val  is stored after computing the logarithm.  source  One might expect that any dimensionless quantity should be convertible to a pure number, that is, to  x  if you had  10*log10(x)  dB. However, it turns out that in dB, a ratio of powers is defined as  10*log10(x) , but a ratio of voltages or other root-power quantities is defined as  20*log10(x) . Clearly, converting back from decibels to a real number is ambiguous, and so we have not implemented automatic promotion to avoid incorrect results. You can use  Unitful.powerratio  to interpret a  Gain  as a ratio of power quantities, or  Unitful.rootpowerratio  (equivalently  fieldratio ) to interpret as a ratio of field quantities.", 
            "title": "Logarithmic quantities with no reference level specified"
        }, 
        {
            "location": "/logarithm/#dimensionful-logarithmic-quantities", 
            "text": "In this package, quantities with units like  dBm  are considered to have the dimension of power, even though the expression  P(dBm) = 10*log10(P/1mW)  is dimensionless and formed from a dimensionless ratio. Practically speaking, these kinds of logarithmic quantities are fungible whenever they share the same dimensions, so it is more convenient to adopt this convention (people refer to  dBm/Hz  as a power spectral density, etc.) Presumably, one would like to have  10dBm isa Unitful.Power  for dispatch too. Therefore, in the following discussion, we will shamelessly (okay, with some shame) speak of dimensionful logarithmic quantities, or  Level s for short:  #  Unitful.Level     Type .  struct Level{L, S, T :Number}  : LogScaled{L}  A logarithmic scale-based level. Details about the logarithmic scale are encoded in  L  : LogInfo .  S  is a reference quantity for the level, not a type. This type has one field,  val::T , and the log of the ratio  val/S  is taken. This type differs from  Unitful.Gain  in that  val  is a linear quantity.  source  Actually, the defining characteristic of a  Level  is that it has a reference level, which may or may not be dimensionful. It usually is, but is not in the case of e.g.  dBFS .  Finally, for completeness we note that both  Level  and  Gain  are subtypes of  LogScaled :  #  Unitful.LogScaled     Type .  abstract type LogScaled{L :LogInfo}  : Number end  Abstract supertype of  Unitful.Level  and  Unitful.Gain . It is only used in promotion to put levels and gains onto a common log scale.  source", 
            "title": "\"Dimensionful\" logarithmic quantities?"
        }, 
        {
            "location": "/logarithm/#multiplication-rules", 
            "text": "Multiplying a dimensionless logarithmic quantity by a pure number acts as like it does for linear quantities:  julia  3u dB  * 2\n6 dB\n\njulia  2 * 0u dB \n0 dB  Justification by example: consider the example of the exponential attenuation of a signal on a lossy transmission line. If the attenuation goes like $10^{-kx}$, then the (power) attenuation in dB is $-10kx$. We see that the attenuation in dB is linear in length. For an attenuation constant of 3dB/m, we better calculate 6dB for a length of 2m.  Multiplying a dimensionful logarithmic quantity by a pure number acts differently than multiplying a gain/attenuation by a pure number. Since  0dBm == 1mW , we better have that  0dBm * 2 == 2mW , implying:  julia  0u dBm  * 2\n3.010299956639812 dBm  Logarithmic quantities can only be multiplied by pure numbers, linear units, or quantities, but not logarithmic \"units\" or quantities.  When a logarithmic quantity is multiplied by a linear quantity, the logarithmic quantity is linearized and multiplication proceeds as usual:  julia  (0u dBm ) * (1u W )\n1.0 mW W  The previous example returns a floating point value because in constructing the level  0 dBm , the power in  mW  is calculated and stored, entailing a floating point conversion. This can be avoided by constructing  0 dBm  as  @dB 1mW/mW :  julia  (@dB 1u mW /u mW ) * (1u W )\n1 mW W  We refer to a quantity with both logarithmic \"units\" and linear units as a mixed quantity. For mixed quantities, the numeric value associates with the logarithmic unit, and the quantity is displayed in a way that makes this explicit:  julia  (0u dBm )/u Hz \n[0.0 dBm] Hz^-1\n\njulia  (0u dB )/u Hz \n[0 dB] Hz^-1\n\njulia  0u dB/Hz \n[0 dB] Hz^-1  Mathematical operations are forwarded to the logarithmic part, so that for example,  100*((0dBm)/s) == (20dBm)/s . We allow linear units to commute with logarithmic quantities for convenience, though the association is understood (e.g.  s^-1*(3dBm) == (3dBm)/s ).  The behavior of multiplication is summarized in the following table, with entries marked by \u2020 indicate prohibited operations. This table is populated automatically whenever the docs are built.        *   10   Hz^-1   dB   dBm   1/Hz   1mW   3dB   3dBm           10   \n\n100   \n\n\n10 Hz^-1   \n\n\n10 dB   \n\n\n10.0 dBm   \n\n\n10 Hz^-1   \n\n\n10 mW   \n\n\n30 dB   \n\n\n13.0 dBm       Hz^-1     \n\n\nHz^-2   \n\n\ndB Hz^-1   \n\n\ndBm Hz^-1   \n\n\n1 Hz^-2   \n\n\n1 Hz^-1 mW   \n\n\n[3 dB] Hz^-1   \n\n\n[3.0 dBm] Hz^-1       dB       \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020       dBm         \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020       1/Hz           \n\n\n1 Hz^-2   \n\n\n1 Hz^-1 mW   \n\n\n\u2020\n\n\n\u2021    \n\n\n1.9952623149688795 Hz^-1 mW       1mW             \n\n\n1 mW^2   \n\n\n1.9952623149688795 mW   \n\n\n1.9952623149688795 mW^2       3dB               \n\n\n6 dB   \n\n\n\u2020       3dBm                 \n\n\n3.9810717055349722 mW^2        \u2021:  1/Hz * 3dB  could be allowed, technically, but we throw an error its unclear if a quantity is a root-power or power quantity:  julia  u 1/Hz  * u 3dB \nERROR: undefined behavior. Please file an issue with the code needed to reproduce.  On the other hand, if it can be determined that a power quantity or root-power quantity is being multiplied by a gain, then the gain is interpreted as a power ratio or root-power ratio, respectively:  julia  1u mW  * 20u dB \n100.0 mW\n\njulia  1u V  * 20u dB \n10.0 V", 
            "title": "Multiplication rules"
        }, 
        {
            "location": "/logarithm/#addition-rules", 
            "text": "We can add logarithmic quantities without reference levels specified ( Gain s):  julia  20u dB  + 20u dB \n40 dB  The numbers out front of the  dB  just add: when we talk about gain or attenuation, we work in logarithmic units so that we can add rather than multiply gain factors. The same behavior holds when we add a  Gain  to a  Level  or vice versa:  julia  20u dBm  + 20u dB \n40.0 dBm  In the case where you have differing logarithmic scales for the  Level  and the  Gain , the logarithmic scale of the  Level  is used for the result:  julia  10u dBm  - 1u Np \n1.3141103619349632 dBm  For logarithmic quantities with the same reference levels, the numbers out in front do not simply add:  julia  20u dBm  + 20u dBm \n23.010299956639813 dBm\n\njulia  2 * 20u dBm \n23.010299956639813 dBm  This is because  dBm  represents a power, ultimately. If we have some amount of power and we double it, we'd better get roughly  3 dB  more power. Note that the juxtaposition  20dBm  will ensure that 20 dBm is constructed before multiplication by 2 in the above example. If you were to type  2*20*dBm , you'd get 40 dBm.  If the reference levels differ but both levels represent a power, we fall back to linear quantities:  julia  20u dBm  + @dB 1u W /u W \n1.1 kg m^2 s^-3  i.e.  1.1 W .  Rules for addition are summarized in the following table, with entries marked by \u2020 indicating prohibited operations. This table is populated automatically whenever the docs are built.        +   100   20dB   1Np   10.0dBm   10.0dBv   1mW           100   \n\n200   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020   \n\n\n\u2020       20dB     \n\n\n40 dB   \n\n\n\u2020   \n\n\n30.0 dBm   \n\n\n30.0 dBV   \n\n\n\u2020       1Np       \n\n\n2 Np   \n\n\n18.685889638065035 dBm   \n\n\n18.685889638065035 dBV   \n\n\n\u2020       10.0dBm         \n\n\n13.010299956639813 dBm   \n\n\n\u2020   \n\n\n11.0 mW       10.0dBV           \n\n\n16.020599913279625 dBV   \n\n\n\u2020       1mW             \n\n\n2 mW        Notice that we disallow implicit conversions between dimensionless logarithmic quantities and real numbers. This is because the results can depend on promotion rules in addition to being ambiguous because of the root-power vs. power ratio issue. If  100 + 10dB  were evaluated as  20dB + 10dB == 30dB , then we'd get  1000 , but if it were evaluated as  100+10 , we'd get  110 .  Also, although it is possible in principle to add e.g.  20dB + 1Np , notice that we have not implemented that because it is unclear whether the result should be in nepers or decibels, and it is also unclear how to handle that question more generally as other logarithmic scales are introduced.", 
            "title": "Addition rules"
        }, 
        {
            "location": "/logarithm/#conversion", 
            "text": "As alluded to earlier, conversions can be tricky because so-called logarithmic units are not units in the conventional sense.  You may use  linear  to convert to a linear scale when you have a  Level  or  Quantity{ :Level}  type. There is a fallback for  Number , which just returns the number.  julia  linear(@dB 10u mW /u mW )\n10 mW\n\njulia  linear(20u dBm/Hz )\n100.0 Hz^-1 mW\n\njulia  linear(30u W )\n30 W\n\njulia  linear(12)\n12  Linearizing a  Quantity{ :Gain}  or a  Gain  to a real number is ambiguous, because the real number may represent a ratio of powers or a ratio of root-power (field) quantities. We implement  Unitful.powerratio  and  Unitful.rootpowerratio  which may be thought of as disambiguated  uconvert  functions. There is a one argument version that assumes you are converting to a unitless number. These functions can take either a  Gain  or a  Real  so that they may be used somewhat generically.  julia  fieldratio(NoUnits, 20u dB )    # the first argument is optional when it is `NoUnits`\n10.0\n\njulia  fieldratio(20u dB )\n10.0\n\njulia  powerratio(NoUnits, 20u dB )  \n100.0\n\njulia  powerratio(u dB , 100)\n20.0 dB\n\njulia  powerratio(u Np , e^2)\n1.0 Np\n\njulia  fieldratio(u Np , e)\n1//1 Np  To save typing you can use  fieldratio  instead of  rootpowerratio , although according to the infallible source  Wikipedia :   The term root-power quantity is introduced by ISO Standard 80000-1:2009 as a substitute of field quantity. The term field quantity is deprecated by that standard.   I would check the primary source but I'm too cheap to pay for the ISO standard. Sorry!", 
            "title": "Conversion"
        }, 
        {
            "location": "/logarithm/#notation", 
            "text": "This package displays logarithmic quantities using shorthand like  dBm  where available. This should probably not be done in polite company. To quote \"Guide for the Use of the International System of Units (SI),\" NIST Special Pub. 811 (2008):   The rules of Ref. [5: IEC 60027-3] preclude, for example, the use of the symbol dBm to indicate a reference level of power of 1 mW. This restriction is based on the rule of Sec. 7.4, which does not permit attachments to unit symbols.   The authorities say the reference level should always specified. In practice, this hasn't stopped the use of  dBm  and the like on commercially available test equipment. Dealing with these units is unavoidable in practice. When no shorthand exists, we follow NIST's advice in displaying logarithmic quantities:   When such data are presented in a table or in a figure, the following condensed notation may be used instead: -0.58 Np (1 \u03bcV/m); 25 dB (20 \u03bcPa).", 
            "title": "Notation"
        }, 
        {
            "location": "/logarithm/#custom-logarithmic-scales", 
            "text": "#  Unitful.@logscale     Macro .  @logscale(symb,abbr,name,base,prefactor,irp)  Define a logarithmic scale. Unlike with units, there is no special treatment for power-of-ten prefixes (decibels and bels are defined separately). However, arbitrary bases are possible, and computationally appropriate  log  and  exp  functions are used in calculations when available (e.g.  log2 ,  log10  for base 2 and base 10, respectively).  This macro defines a  MixedUnits  object identified by symbol  symb . This can be used to  This macro also defines another macro available as  @symb . For example,  @dB  in the case of decibels. This can be used to construct  Level  objects at parse time. Usage is like  @dB 3V/1V .  prefactor  is the prefactor out in front of the logarithm for this log scale. In all cases it is defined with respect to taking ratios of power quantities. Just divide by two if you want to refer to root-power / field quantities instead.  irp  (short for \"is root power?\") specifies whether the logarithmic scale is defined with respect to ratios of power or root-power quantities. In short: use  false  if your scale is decibel-like, or  true  if your scale is neper-like.  Examples:  julia  using Unitful: V, W\n\njulia  @logscale d\u03a0  d\u03a0  Decipies \u03c0 10 false\nd\u03a0\n\njulia  @d\u03a0 \u03c0*V/1V\n20.0 d\u03a0 (1 V)\n\njulia  d\u03a0(\u03c0*V, 1V)\n20.0 d\u03a0 (1 V)\n\njulia  @d\u03a0 \u03c0^2*V/1V\n40.0 d\u03a0 (1 V)\n\njulia  @d\u03a0 \u03c0*W/1W\n10.0 d\u03a0 (1 W)  source", 
            "title": "Custom logarithmic scales"
        }, 
        {
            "location": "/logarithm/#api", 
            "text": "#  Unitful.linear     Function .  linear(x::Quantity)\nlinear(x::Level)\nlinear(x::Number) = x  Returns a quantity equivalent to  x  but without any logarithmic scales.  It is important to note that this operation will error for  Quantity{ :Gain}  types. This is for two reasons:   20dB  could be interpreted as either a power or root-power ratio.  Even if  -20dB/m  were interpreted as, say,  0.01/m , this means something fundamentally different than  -20dB/m .  0.01/m  cannot be used to calculate exponential attenuation.   source  #  Unitful.reflevel     Function .  reflevel(x::Level{L,S})\nreflevel(::Type{Level{L,S}})\nreflevel(::Type{Level{L,S,T}})  Returns the reference level, e.g.  julia  reflevel(3u dBm )\n1 mW  source  #  Unitful.powerratio     Function .  powerratio(x)  Treat  x  as a ratio of power quantities (field quantities) and unit-convert to no units.  powerratio(u::Units{()}, x::Gain)\npowerratio(u::MixedUnits{ :Gain}, x::Gain)  Treat  x  as a ratio of power quantities (field quantities) and unit-convert to  u .  powerratio(u::Units{()}, x::Real)\npowerratio(u::MixedUnits{ :Gain,  :Units{()})}, x::Real)  Fall-back methods so that  powerratio  may be used with real numbers.  It is important to note that this function is undefined for  Quantity{ :Gain}  types. It is tempting to make this function transform  -20dB/m  into  0.1/m , however this means something fundamentally different than  -20dB/m :  0.1/m  cannot be used to calculate exponential attenuation.  source  #  Unitful.rootpowerratio     Function .  rootpowerratio(x)  Treat  x  as a ratio of root-power quantities (field quantities) and unit-convert to no units.  rootpowerratio(u::Units{()}, x::Gain)\nrootpowerratio(u::MixedUnits{ :Gain}, x::Gain)  Treat  x  as a ratio of root-power quantities (field quantities) and unit-convert to  u .  rootpowerratio(u::Units{()}, x::Real)\nrootpowerratio(u::MixedUnits{ :Gain,  :Units{()})}, x::Real)  Fall-back methods so that  rootpowerratio  may be used with real numbers.  It is important to note that this function is undefined for  Quantity{ :Gain}  types. It is tempting to make this function transform  -20dB/m  into  0.1/m , however this means something fundamentally different than  -20dB/m :  0.1/m  cannot be used to calculate exponential attenuation.  fieldratio  and  rootpowerratio  are synonymous, so you can save some typing if you like.  source", 
            "title": "API"
        }, 
        {
            "location": "/extending/", 
            "text": "Extending Unitful\n\n\n\n\nMaking your own units package\n\n\nNew units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in \nUnitfulUS.jl\n, which defines U.S. customary units. It's actually very easy! Just make sure you read all of the cautionary notes on this page. If you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!\n\n\n\n\nSome limitations\n\n\n\n\nPrecompilation\n\n\nWhen creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following or something very similar make it into your code:\n\n\nconst\n \nlocalunits\n \n=\n \nUnitful\n.\nbasefactors\n\n\nconst\n \nlocalpromotion\n \n=\n \nUnitful\n.\npromotion\n \n# only if you\nve used @dimension\n\n\nfunction\n \n__init__\n()\n\n    \nmerge!\n(\nUnitful\n.\nbasefactors\n,\n \nlocalunits\n)\n\n    \nmerge!\n(\nUnitful\n.\npromotion\n,\n \nlocalpromotion\n)\n \n# only if you\nve used @dimension\n\n\nend\n\n\n\n\n\n\nThe definition of \nlocalunits\n (\nlocalpromotion\n) must happen \nafter all new units (dimensions) have been defined\n.\n\n\nThe problem is that the \n@unit\n macro needs to add some information to a dictionary defined in Unitful, regardless of where the macro is executed (the use of this dictionary does not lead to run-time penalties, if you were wondering). However, because Unitful is precompiled, changes made to it from another module at compile-time will not persist.\n\n\nThe \nconst localunits = Unitful.basefactors\n line makes a copy of the compile-time-modified dictionary, which can be precompiled into the module where this code appears, and then the dictionary is merged into Unitful's dictionary at runtime.\n\n\nIf you'd like, you can also consider adding a call to \nUnitful.register\n in your \n__init__\n function, which will make your units accessible using Unitful's \n@u_str\n macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the \n@u_str\n macro will still work, but it will use the unit found in whichever package was registered most recently, and it will omit a warning every time.\n\n\n\n\nType uniqueness\n\n\nCurrently, when the \n@dimension\n, \n@derived_dimension\n, \n@refunit\n, or \n@unit\n macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g. \nLength\n, \nMeter\n, etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.\n\n\nI don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of \nBase.gensym()\n if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.\n\n\n\n\nArchaic or fictitious unit systems\n\n\nIn the rare event that you want to define physical units which are not convertible to SI units, you need to do a bit of extra work. To be clear, such a conversion should always exist, in principle. One can imagine, however, archaic or fictitious unit systems for which a precise conversion to SI units is unknown. For example, a \ncullishigay\n is one-third of a mudi, but only \napproximately\n 1.25 imperial bushels. There may be cases where you don't even have an approximate conversion to imperial bushels. At such a time, you may feel uncomfortable specifying the \"base unit\" of this hypothetical unit system in terms of an SI quantity, and may want to explicitly forbid any attempt to convert to SI units.\n\n\nOne can achieve this by defining new dimensions with the \n@dimension\n or \n@derived_dimension\n macros. The trick is to define dimensions that display suggestively like physical dimensions, like \ud835\udc0b\n, \ud835\udc13\n etc., but are distinct as far as Julia's type system is concerned. Then, you can use \n@refunit\n to base units for these new dimensions without reference to SI. The result will be that attempted conversion between the hypothetical unit system and SI will fail with a \nDimensionError\n, so be sure you provide some hints in how your new dimensions are displayed to avoid confusing users. It would be confusing to throw a \nDimensionError\n when attempting to convert between lengths which are incompatible in the sense of the previous paragraph, when both lengths display their dimension as \ud835\udc0b.", 
            "title": "Extending Unitful"
        }, 
        {
            "location": "/extending/#extending-unitful", 
            "text": "", 
            "title": "Extending Unitful"
        }, 
        {
            "location": "/extending/#making-your-own-units-package", 
            "text": "New units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in  UnitfulUS.jl , which defines U.S. customary units. It's actually very easy! Just make sure you read all of the cautionary notes on this page. If you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!", 
            "title": "Making your own units package"
        }, 
        {
            "location": "/extending/#some-limitations", 
            "text": "", 
            "title": "Some limitations"
        }, 
        {
            "location": "/extending/#precompilation", 
            "text": "When creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following or something very similar make it into your code:  const   localunits   =   Unitful . basefactors  const   localpromotion   =   Unitful . promotion   # only if you ve used @dimension  function   __init__ () \n     merge! ( Unitful . basefactors ,   localunits ) \n     merge! ( Unitful . promotion ,   localpromotion )   # only if you ve used @dimension  end   The definition of  localunits  ( localpromotion ) must happen  after all new units (dimensions) have been defined .  The problem is that the  @unit  macro needs to add some information to a dictionary defined in Unitful, regardless of where the macro is executed (the use of this dictionary does not lead to run-time penalties, if you were wondering). However, because Unitful is precompiled, changes made to it from another module at compile-time will not persist.  The  const localunits = Unitful.basefactors  line makes a copy of the compile-time-modified dictionary, which can be precompiled into the module where this code appears, and then the dictionary is merged into Unitful's dictionary at runtime.  If you'd like, you can also consider adding a call to  Unitful.register  in your  __init__  function, which will make your units accessible using Unitful's  @u_str  macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the  @u_str  macro will still work, but it will use the unit found in whichever package was registered most recently, and it will omit a warning every time.", 
            "title": "Precompilation"
        }, 
        {
            "location": "/extending/#type-uniqueness", 
            "text": "Currently, when the  @dimension ,  @derived_dimension ,  @refunit , or  @unit  macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g.  Length ,  Meter , etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.  I don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of  Base.gensym()  if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.", 
            "title": "Type uniqueness"
        }, 
        {
            "location": "/extending/#archaic-or-fictitious-unit-systems", 
            "text": "In the rare event that you want to define physical units which are not convertible to SI units, you need to do a bit of extra work. To be clear, such a conversion should always exist, in principle. One can imagine, however, archaic or fictitious unit systems for which a precise conversion to SI units is unknown. For example, a  cullishigay  is one-third of a mudi, but only  approximately  1.25 imperial bushels. There may be cases where you don't even have an approximate conversion to imperial bushels. At such a time, you may feel uncomfortable specifying the \"base unit\" of this hypothetical unit system in terms of an SI quantity, and may want to explicitly forbid any attempt to convert to SI units.  One can achieve this by defining new dimensions with the  @dimension  or  @derived_dimension  macros. The trick is to define dimensions that display suggestively like physical dimensions, like \ud835\udc0b , \ud835\udc13  etc., but are distinct as far as Julia's type system is concerned. Then, you can use  @refunit  to base units for these new dimensions without reference to SI. The result will be that attempted conversion between the hypothetical unit system and SI will fail with a  DimensionError , so be sure you provide some hints in how your new dimensions are displayed to avoid confusing users. It would be confusing to throw a  DimensionError  when attempting to convert between lengths which are incompatible in the sense of the previous paragraph, when both lengths display their dimension as \ud835\udc0b.", 
            "title": "Archaic or fictitious unit systems"
        }, 
        {
            "location": "/trouble/", 
            "text": "Why do unit conversions yield rational numbers sometimes?\n\n\nWe use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point \n2.54\n is not equal to \n254//100\n. As a consequence, \n1inch != 2.54cm\n, because Unitful respects exact conversions. To test for equivalence, instead use \n\u2248\n (\n\\approx\n tab-completion).\n\n\n\n\nBut I want a floating point number...\n\n\nfloat(x)\n is defined for \nUnitful.Quantity\n types, and is forwarded to the underlying numeric type (units are not affected).\n\n\nWe may consider adding an option in the defaults to turn on/off use of \nRational\n numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that \ninv(2) === 0.5\n, not \n1//2\n).\n\n\n\n\nExponentiation\n\n\nMost operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a \nUnitful.Quantity\n object, raising a \nQuantity\n to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance:\n\n\njulia\n square(x) = (p = 2; x^p)\nsquare (generic function with 1 method)\n\njulia\n @code_warntype square(1.0u\nm\n)\nVariables:\n  #self#::#square\n  x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}\n  p::Int64\n\nBody:\n  begin\n      return $(Expr(:invoke, MethodInstance for ^(::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, ::Int64), :(^), :(x), 2))\n  end::Any\n\n\n\n\n\nIn Julia 0.6, constant literal integers are lowered specially for exponentiation. (See Julia PR \n#20530\n for details.) In this case, type stability can be maintained:\n\n\njulia\n square(x) = x^2\nsquare (generic function with 1 method)\n\njulia\n @code_warntype square(1.0u\nm\n)\nVariables:\n  #self#::#square\n  x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}\n\nBody:\n  begin\n      $(Expr(:inbounds, false))\n      # meta: location /Users/ajkeller/.julia/v0.6/Unitful/src/Unitful.jl literal_pow 1080\n      SSAValue(0) = (Core.getfield)(x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, :val)::Float64\n      # meta: pop location\n      $(Expr(:inbounds, :pop))\n      return $(Expr(:new, Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}, :((Base.mul_float)(SSAValue(0), SSAValue(0))::Float64)))\n  end::Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}\n\n\n\n\n\nBecause the functions \ninv\n and \nsqrt\n are raising a \nQuantity\n to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a \nQuantity\n can be type-stable in either Julia 0.5 or 0.6 if done as \nx*x\n.\n\n\n\n\nPromotion with dimensionless numbers\n\n\nMost of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that \n\u03bcm/m\n and \nrad\n are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.\n\n\nThe result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles, \n1 rad\n is essentially just \n1\n, giving sane behavior:\n\n\njulia\n \u03c0/2*u\nrad\n+90u\n\u00b0\n\n3.141592653589793\n\n\n\n\n\n\n\nOther random problems\n\n\nIf using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:\n\n\njulia\n using Unitful: m,cm\n\njulia\n uconvert(m,0x01cm)   # the user means cm, not 0x01c*m\n0x001c m\n\n\n\n\n\nThis behavior is a consequence of \na Julia issue\n that has recently been fixed and will no longer be a problem in future Julia versions.\n\n\n\n\nI have a different problem\n\n\nPlease raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/trouble/#why-do-unit-conversions-yield-rational-numbers-sometimes", 
            "text": "We use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point  2.54  is not equal to  254//100 . As a consequence,  1inch != 2.54cm , because Unitful respects exact conversions. To test for equivalence, instead use  \u2248  ( \\approx  tab-completion).", 
            "title": "Why do unit conversions yield rational numbers sometimes?"
        }, 
        {
            "location": "/trouble/#but-i-want-a-floating-point-number", 
            "text": "float(x)  is defined for  Unitful.Quantity  types, and is forwarded to the underlying numeric type (units are not affected).  We may consider adding an option in the defaults to turn on/off use of  Rational  numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that  inv(2) === 0.5 , not  1//2 ).", 
            "title": "But I want a floating point number..."
        }, 
        {
            "location": "/trouble/#exponentiation", 
            "text": "Most operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a  Unitful.Quantity  object, raising a  Quantity  to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance:  julia  square(x) = (p = 2; x^p)\nsquare (generic function with 1 method)\n\njulia  @code_warntype square(1.0u m )\nVariables:\n  #self#::#square\n  x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}\n  p::Int64\n\nBody:\n  begin\n      return $(Expr(:invoke, MethodInstance for ^(::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, ::Int64), :(^), :(x), 2))\n  end::Any  In Julia 0.6, constant literal integers are lowered specially for exponentiation. (See Julia PR  #20530  for details.) In this case, type stability can be maintained:  julia  square(x) = x^2\nsquare (generic function with 1 method)\n\njulia  @code_warntype square(1.0u m )\nVariables:\n  #self#::#square\n  x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}\n\nBody:\n  begin\n      $(Expr(:inbounds, false))\n      # meta: location /Users/ajkeller/.julia/v0.6/Unitful/src/Unitful.jl literal_pow 1080\n      SSAValue(0) = (Core.getfield)(x::Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}}, :val)::Float64\n      # meta: pop location\n      $(Expr(:inbounds, :pop))\n      return $(Expr(:new, Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}, :((Base.mul_float)(SSAValue(0), SSAValue(0))::Float64)))\n  end::Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}  Because the functions  inv  and  sqrt  are raising a  Quantity  to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a  Quantity  can be type-stable in either Julia 0.5 or 0.6 if done as  x*x .", 
            "title": "Exponentiation"
        }, 
        {
            "location": "/trouble/#promotion-with-dimensionless-numbers", 
            "text": "Most of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that  \u03bcm/m  and  rad  are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.  The result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles,  1 rad  is essentially just  1 , giving sane behavior:  julia  \u03c0/2*u rad +90u \u00b0 \n3.141592653589793", 
            "title": "Promotion with dimensionless numbers"
        }, 
        {
            "location": "/trouble/#other-random-problems", 
            "text": "If using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:  julia  using Unitful: m,cm\n\njulia  uconvert(m,0x01cm)   # the user means cm, not 0x01c*m\n0x001c m  This behavior is a consequence of  a Julia issue  that has recently been fixed and will no longer be a problem in future Julia versions.", 
            "title": "Other random problems"
        }, 
        {
            "location": "/trouble/#i-have-a-different-problem", 
            "text": "Please raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "I have a different problem"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nThe Unitful.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "The Unitful.jl package is licensed under the MIT \"Expat\" License:   Copyright (c) 2016: Andrew Keller.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}