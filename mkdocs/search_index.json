{
    "docs": [
        {
            "location": "/", 
            "text": "Unitful.jl\n\n\nA Julia package for physical units. Available \nhere\n. Inspired by:\n\n\n\n\nSIUnits.jl\n\n\nEngUnits.jl\n\n\nUnits.jl\n\n\n\n\nWe want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.\n\n\n\n\nQuick start\n\n\n\n\nThis package requires Julia 0.5. Older versions will not be supported.\n\n\nPkg.add(\"Unitful\")\n\n\nusing Unitful\n\n\n\n\nIn \ndeps/Defaults.jl\n of the package directory, you can see what is defined by default. Feel free to edit this file to suit your needs. The Unitful package will need to be reloaded for changes to take place. To recover the \"factory  defaults,\" delete \ndeps/Defaults.jl\n and run \nPkg.build(\"Unitful\")\n again.\n\n\nHere is a summary of the defaults file contents:\n\n\n\n\nBase dimensions like length, mass, time, etc. are defined.\n\n\nDerived dimensions like volume, energy, momentum, etc. are defined.\n\n\nSI units and their power-of-ten prefixes are defined.\n\n\nSome other units (imperial units) are defined, without power-of-ten prefixes.\n\n\nPromotion behavior is specified.\n\n\n\n\nSome unit abbreviations conflict with other definitions or syntax:\n\n\n\n\ninch\n is used instead of \nin\n, since \nin\n conflicts with Julia syntax\n\n\nminute\n is used instead of \nmin\n, since \nmin\n is a commonly used function\n\n\nhr\n is used instead of \nh\n, since \nh\n is revered as the Planck constant\n\n\n\n\nUnits, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them using the \n@u_str\n string macro for convenience, or import them from the \nUnitful\n package to bring them into the namespace.\n\n\n\n\nUsage examples\n\n\njulia\n \n1\nu\nkg\n \n==\n \n1000\nu\ng\n             \n# Equivalence implies unit conversion\n\n\ntrue\n\n\n\njulia\n \n!\n(\n1\nu\nkg\n \n===\n \n1000\nu\ng\n)\n         \n# ...and yet we can distinguish these...\n\n\ntrue\n\n\n\njulia\n \n1\nu\nkg\n \n===\n \n1\nu\nkg\n              \n# ...and these are indistinguishable.\n\n\ntrue\n\n\n\n\n\n\nIn the next examples we assume we have brought some units into our namespace, e.g. using \nm = u\"m\"\n, etc.\n\n\njulia\n \nuconvert\n(\n\u00b0C\n,\n \n212\n\u00b0F\n)\n\n\n100//1 \u00b0C\n\n\n\njulia\n \nuconvert\n(\n\u03bcm\n/\n(\nm\n*\n\u00b0F\n),\n \n9\n\u03bcm\n/\n(\nm\n*\n\u00b0C\n))\n\n\n5//1 \u00b0F^-1 \u03bcm m^-1\n\n\n\njulia\n \nmod\n(\n1\nhr\n+\n3\nminute\n+\n5\ns\n,\n \n24\ns\n)\n\n\n17//1 s\n\n\n\n\n\n\nSee \ntest/runtests.jl\n for more usage examples.", 
            "title": "Home"
        }, 
        {
            "location": "/#unitfuljl", 
            "text": "A Julia package for physical units. Available  here . Inspired by:   SIUnits.jl  EngUnits.jl  Units.jl   We want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.", 
            "title": "Unitful.jl"
        }, 
        {
            "location": "/#quick-start", 
            "text": "This package requires Julia 0.5. Older versions will not be supported.  Pkg.add(\"Unitful\")  using Unitful   In  deps/Defaults.jl  of the package directory, you can see what is defined by default. Feel free to edit this file to suit your needs. The Unitful package will need to be reloaded for changes to take place. To recover the \"factory  defaults,\" delete  deps/Defaults.jl  and run  Pkg.build(\"Unitful\")  again.  Here is a summary of the defaults file contents:   Base dimensions like length, mass, time, etc. are defined.  Derived dimensions like volume, energy, momentum, etc. are defined.  SI units and their power-of-ten prefixes are defined.  Some other units (imperial units) are defined, without power-of-ten prefixes.  Promotion behavior is specified.   Some unit abbreviations conflict with other definitions or syntax:   inch  is used instead of  in , since  in  conflicts with Julia syntax  minute  is used instead of  min , since  min  is a commonly used function  hr  is used instead of  h , since  h  is revered as the Planck constant   Units, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them using the  @u_str  string macro for convenience, or import them from the  Unitful  package to bring them into the namespace.", 
            "title": "Quick start"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "julia   1 u kg   ==   1000 u g               # Equivalence implies unit conversion  true  julia   ! ( 1 u kg   ===   1000 u g )           # ...and yet we can distinguish these...  true  julia   1 u kg   ===   1 u kg                # ...and these are indistinguishable.  true   In the next examples we assume we have brought some units into our namespace, e.g. using  m = u\"m\" , etc.  julia   uconvert ( \u00b0C ,   212 \u00b0F )  100//1 \u00b0C  julia   uconvert ( \u03bcm / ( m * \u00b0F ),   9 \u03bcm / ( m * \u00b0C ))  5//1 \u00b0F^-1 \u03bcm m^-1  julia   mod ( 1 hr + 3 minute + 5 s ,   24 s )  17//1 s   See  test/runtests.jl  for more usage examples.", 
            "title": "Usage examples"
        }, 
        {
            "location": "/highlights/", 
            "text": "Dispatch on dimensions\n\n\nConsider the following toy example, converting from voltage or power ratios to decibels:\n\n\njulia\n \ndB\n(\nnum\n::\nUnitful\n.\nVoltage\n,\n \nden\n::\nUnitful\n.\nVoltage\n)\n \n=\n \n20\n*\nlog10\n(\nnum\n/\nden\n)\n\n\n dB (generic function with 1 method)\n\n\n\njulia\n \ndB\n(\nnum\n::\nUnitful\n.\nPower\n,\n \nden\n::\nUnitful\n.\nPower\n)\n \n=\n \n10\n*\nlog10\n(\nnum\n/\nden\n)\n\n\n dB (generic function with 2 methods)\n\n\n\njulia\n \ndB\n(\n1\nu\nmV\n,\n \n1\nu\nV\n)\n\n\n-60.0\n\n\n\njulia\n \ndB\n(\n1\nu\nmW\n,\n \n1\nu\nW\n)\n\n\n-30.0\n\n\n\n\n\n\nWe don't currently implement dB as a unit because the log scale would require special treatment, but it is under consideration.\n\n\n\n\nDimensions in a type definition\n\n\nIt may be tempting to specify the dimensions of a quantity in a type definition, e.g.\n\n\ntype Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend\n\n\n\n\n\nHowever, these are abstract types. If performance is important, it may be better just to pick a concrete \nQuantity\n type:\n\n\ntype Person\n    height::typeof(1.0u\nm\n)\n    mass::typeof(1.0u\nkg\n)\nend\n\n\n\n\n\nYou can still create a \nPerson\n as \nPerson(5u\"ft\"+10u\"inch\", 75u\"kg\")\n; the unit conversion happens automatically.\n\n\n\n\nMaking new units and dimensions\n\n\nYou can make new units using the \n@unit\n macro on the fly:\n\n\njulia\n \n@\nunit\n \nc\n \nc\n \nSpeedOfLight\n \n299792458\nu\nm/s\n \nfalse\n\n\nc\n\n\n\n\n\n\n\n\nArrays\n\n\nPromotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from \n[1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"]\n). However, it could be useful in toy calculations for \ngeneral relativity\n where some conventions yield matrices with mixed dimensions:\n\n\njulia\n \n@\nunit c \nc\n SpeedOfLight \n299792458\nu\nm/s\n \nfalse\n\nc\n\njulia\n Diagonal\n([\n-\n1\n.\n0\nc\n^\n2\n,\n \n1\n.\n0\n,\n \n1\n.\n0\n,\n \n1\n.\n0\n])\n\n\n4\n\u00d7\n4\n Diagonal\n{\nNumber\n}:\n\n \n-\n1\n.\n0\n c\n^\n2\n   \n\u22c5\n    \n\u22c5\n    \n\u22c5\n\n       \n\u22c5\n   \n1\n.\n0\n   \n\u22c5\n    \n\u22c5\n\n       \n\u22c5\n    \n\u22c5\n   \n1\n.\n0\n   \n\u22c5\n\n       \n\u22c5\n    \n\u22c5\n    \n\u22c5\n   \n1\n.\n0\n\n\n\n\n\n\n\n\nUnits with rational exponents\n\n\njulia\n 1.0u\nV/sqrt(Hz)\n\n1.0 Hz^-1/2 V\n\n\n\n\n\n\n\nExact conversions respected\n\n\njulia\n uconvert(u\nft\n,1u\ninch\n)\n1//12 ft", 
            "title": "Highlighted features"
        }, 
        {
            "location": "/highlights/#dispatch-on-dimensions", 
            "text": "Consider the following toy example, converting from voltage or power ratios to decibels:  julia   dB ( num :: Unitful . Voltage ,   den :: Unitful . Voltage )   =   20 * log10 ( num / den )   dB (generic function with 1 method)  julia   dB ( num :: Unitful . Power ,   den :: Unitful . Power )   =   10 * log10 ( num / den )   dB (generic function with 2 methods)  julia   dB ( 1 u mV ,   1 u V )  -60.0  julia   dB ( 1 u mW ,   1 u W )  -30.0   We don't currently implement dB as a unit because the log scale would require special treatment, but it is under consideration.", 
            "title": "Dispatch on dimensions"
        }, 
        {
            "location": "/highlights/#dimensions-in-a-type-definition", 
            "text": "It may be tempting to specify the dimensions of a quantity in a type definition, e.g.  type Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend  However, these are abstract types. If performance is important, it may be better just to pick a concrete  Quantity  type:  type Person\n    height::typeof(1.0u m )\n    mass::typeof(1.0u kg )\nend  You can still create a  Person  as  Person(5u\"ft\"+10u\"inch\", 75u\"kg\") ; the unit conversion happens automatically.", 
            "title": "Dimensions in a type definition"
        }, 
        {
            "location": "/highlights/#making-new-units-and-dimensions", 
            "text": "You can make new units using the  @unit  macro on the fly:  julia   @ unit   c   c   SpeedOfLight   299792458 u m/s   false  c", 
            "title": "Making new units and dimensions"
        }, 
        {
            "location": "/highlights/#arrays", 
            "text": "Promotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from  [1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"] ). However, it could be useful in toy calculations for  general relativity  where some conventions yield matrices with mixed dimensions:  julia   @ unit c  c  SpeedOfLight  299792458 u m/s   false \nc\n\njulia  Diagonal ([ - 1 . 0 c ^ 2 ,   1 . 0 ,   1 . 0 ,   1 . 0 ])  4 \u00d7 4  Diagonal { Number }: \n  - 1 . 0  c ^ 2     \u22c5      \u22c5      \u22c5 \n        \u22c5     1 . 0     \u22c5      \u22c5 \n        \u22c5      \u22c5     1 . 0     \u22c5 \n        \u22c5      \u22c5      \u22c5     1 . 0", 
            "title": "Arrays"
        }, 
        {
            "location": "/highlights/#units-with-rational-exponents", 
            "text": "julia  1.0u V/sqrt(Hz) \n1.0 Hz^-1/2 V", 
            "title": "Units with rational exponents"
        }, 
        {
            "location": "/highlights/#exact-conversions-respected", 
            "text": "julia  uconvert(u ft ,1u inch )\n1//12 ft", 
            "title": "Exact conversions respected"
        }, 
        {
            "location": "/types/", 
            "text": "Overview\n\n\nWe define a \nUnitful.Unit{U}\n type to represent a unit (\nU\n is a symbol, like \n:Meter\n). \nUnit\ns keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g. \nnm\n or \nkm\n) may help to avoid overflow issues and general ugliness.\n\n\nWe define the immutable singleton \nUnitful.Units{N,D}\n, where \nN\n is always a tuple of \nUnit\n objects, and \nD\n is some type, like \ntypeof(Unitful.\ud835\udc0b)\n, where \n\ud835\udc0b\n is the object representing the length dimension. Usually, the user interacts only with \nUnits\n objects, not \nUnit\n objects.\n\n\nWe define a function \ndimension\n that turns, for example, \nacre^2\n into \n\ud835\udc0b^4\n. We can add quantities with the same dimension, regardless of specific units. Note that dimensions cannot be determined by powers of the units: \nft^2\n is an area, but so is \nac^1\n (an acre).\n\n\nWe define physical quantity types as \nQuantity{T\n:Number, D, U}\n, where \nD \n: Dimensions\n and \nU \n: Units\n. By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions: \nisa(1m, Length) == true\n. This works because \nLength\n is a type alias for some subset of \nUnitful.DimensionedQuantity\n subtypes.\n\n\n\n\nQuantities\n\n\n#\n\n\nUnitful.DimensionedQuantity\n \n \nType\n.\n\n\nabstract DimensionedQuantity{D} \n: Number\n\n\n\n\n\nSuper-type of \nUnitful.Quantity\n types. Used in dispatch on quantities of a particular dimension, without having to specify the units. The type parameter \nD \n:\n \nUnitful.Dimensions\n.\n\n\nsource\n\n\n#\n\n\nUnitful.Quantity\n \n \nType\n.\n\n\nimmutable Quantity{T,D,U} \n: DimensionedQuantity{D}\n\n\n\n\n\nA quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.\n\n\nThe type parameter \nT\n represents the numeric backing type. The type parameters \nD \n:\n \nUnitful.Dimensions\n and \nU \n:\n \nUnitful.Units\n. Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.\n\n\nsource\n\n\n#\n\n\nUnitful.DimensionlessQuantity\n \n \nConstant\n.\n\n\ntypealias DimensionlessQuantity{T,U} Quantity{T, Dimensions{()},U}\n\n\n\n\n\nUseful for dispatching on \nUnitful.Quantity\n types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)\n\n\nExample:\n\n\njulia\n \nisa\n(\n1.0\nu\nmV/V\n,\n \nDimensionlessQuantity\n)\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n\n\nUnits and dimensions\n\n\n#\n\n\nUnitful.Unitlike\n \n \nType\n.\n\n\nabstract Unitlike\n\n\n\n\n\nAbstract container type for units or dimensions, which need similar manipulations for collecting powers and sorting. This abstract type is probably not strictly necessary but facilitates code reuse (see \n*(::Unitlike,::Unitlike...)\n).\n\n\nsource\n\n\n#\n\n\nUnitful.Units\n \n \nType\n.\n\n\nimmutable Units{N,D} \n: DimensionedUnits{D}\n\n\n\n\n\nInstances of this object represent units, possibly combinations thereof. Example: the unit \nm\n is actually a singleton of type \nUnits{(Unit{:Meter}(0,1),), typeof(u\"\ud835\udc0b\")}\n. After dividing by \ns\n, a singleton of type \nUnits{(Unit{:Meter}(0,1),Unit{:Second}(0,-1)), typeof(u\"\ud835\udc0b\")}\n is returned.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimensions\n \n \nType\n.\n\n\nimmutable Dimensions{N} \n: Unitlike\n\n\n\n\n\nInstances of this object represent dimensions, possibly combinations thereof.\n\n\nsource\n\n\n#\n\n\nUnitful.Unit\n \n \nType\n.\n\n\nimmutable Unit{U}\n    tens::Int\n    power::Rational{Int}\nend\n\n\n\n\n\nDescription of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit \nU\n is a symbol, e.g. \n:Meter\n, \n:Second\n, \n:Gram\n, etc. \nUnit{U}\n objects are collected in a tuple, which is used for the type parameter \nN\n of a \nUnits{N,D}\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.Dimension\n \n \nType\n.\n\n\nimmutable Dimension{D}\n    power::Rational{Int}\n    Dimension(p) = new(p)\n    Dimension(t,p) = new(p)\nend\n\n\n\n\n\nDescription of a dimension. The name of the dimension \nD\n is a symbol, e.g. \n:Length\n, \n:Time\n, \n:Mass\n, etc.\n\n\nDimension{D}\n objects are collected in a tuple, which is used for the type parameter \nN\n of a \nDimensions{N}\n object.\n\n\nThe two-argument constructor ignores the first argument and is used only in the function \n*(::Unitlike,::Unitlike...)\n.\n\n\nsource", 
            "title": "Types"
        }, 
        {
            "location": "/types/#overview", 
            "text": "We define a  Unitful.Unit{U}  type to represent a unit ( U  is a symbol, like  :Meter ).  Unit s keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g.  nm  or  km ) may help to avoid overflow issues and general ugliness.  We define the immutable singleton  Unitful.Units{N,D} , where  N  is always a tuple of  Unit  objects, and  D  is some type, like  typeof(Unitful.\ud835\udc0b) , where  \ud835\udc0b  is the object representing the length dimension. Usually, the user interacts only with  Units  objects, not  Unit  objects.  We define a function  dimension  that turns, for example,  acre^2  into  \ud835\udc0b^4 . We can add quantities with the same dimension, regardless of specific units. Note that dimensions cannot be determined by powers of the units:  ft^2  is an area, but so is  ac^1  (an acre).  We define physical quantity types as  Quantity{T :Number, D, U} , where  D  : Dimensions  and  U  : Units . By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions:  isa(1m, Length) == true . This works because  Length  is a type alias for some subset of  Unitful.DimensionedQuantity  subtypes.", 
            "title": "Overview"
        }, 
        {
            "location": "/types/#quantities", 
            "text": "#  Unitful.DimensionedQuantity     Type .  abstract DimensionedQuantity{D}  : Number  Super-type of  Unitful.Quantity  types. Used in dispatch on quantities of a particular dimension, without having to specify the units. The type parameter  D  :   Unitful.Dimensions .  source  #  Unitful.Quantity     Type .  immutable Quantity{T,D,U}  : DimensionedQuantity{D}  A quantity, which has dimensions and units specified in the type signature. The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.  The type parameter  T  represents the numeric backing type. The type parameters  D  :   Unitful.Dimensions  and  U  :   Unitful.Units . Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.  source  #  Unitful.DimensionlessQuantity     Constant .  typealias DimensionlessQuantity{T,U} Quantity{T, Dimensions{()},U}  Useful for dispatching on  Unitful.Quantity  types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)  Example:  julia   isa ( 1.0 u mV/V ,   DimensionlessQuantity )  true   source", 
            "title": "Quantities"
        }, 
        {
            "location": "/types/#units-and-dimensions", 
            "text": "#  Unitful.Unitlike     Type .  abstract Unitlike  Abstract container type for units or dimensions, which need similar manipulations for collecting powers and sorting. This abstract type is probably not strictly necessary but facilitates code reuse (see  *(::Unitlike,::Unitlike...) ).  source  #  Unitful.Units     Type .  immutable Units{N,D}  : DimensionedUnits{D}  Instances of this object represent units, possibly combinations thereof. Example: the unit  m  is actually a singleton of type  Units{(Unit{:Meter}(0,1),), typeof(u\"\ud835\udc0b\")} . After dividing by  s , a singleton of type  Units{(Unit{:Meter}(0,1),Unit{:Second}(0,-1)), typeof(u\"\ud835\udc0b\")}  is returned.  source  #  Unitful.Dimensions     Type .  immutable Dimensions{N}  : Unitlike  Instances of this object represent dimensions, possibly combinations thereof.  source  #  Unitful.Unit     Type .  immutable Unit{U}\n    tens::Int\n    power::Rational{Int}\nend  Description of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit  U  is a symbol, e.g.  :Meter ,  :Second ,  :Gram , etc.  Unit{U}  objects are collected in a tuple, which is used for the type parameter  N  of a  Units{N,D}  object.  source  #  Unitful.Dimension     Type .  immutable Dimension{D}\n    power::Rational{Int}\n    Dimension(p) = new(p)\n    Dimension(t,p) = new(p)\nend  Description of a dimension. The name of the dimension  D  is a symbol, e.g.  :Length ,  :Time ,  :Mass , etc.  Dimension{D}  objects are collected in a tuple, which is used for the type parameter  N  of a  Dimensions{N}  object.  The two-argument constructor ignores the first argument and is used only in the function  *(::Unitlike,::Unitlike...) .  source", 
            "title": "Units and dimensions"
        }, 
        {
            "location": "/newunits/", 
            "text": "The package automatically generates a useful set of units and dimensions in the \nUnitful\n module by including the file \ndeps/Defaults.jl\n, which is generated when this package is built. If a different set of default units or dimensions is desired, one can modify this file and reload \nUnitful\n. (You can also delete it and run \nPkg.build(\"Unitful\")\n to recover \"factory settings.\") In this manner, the user has flexibility to choose a minimal or specialized set of units without modifying the source code itself, which would flag the package as \"dirty\" and hinder future updates.\n\n\nMacros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the \n@unit\n macro. You can look at \ndeps/Defaults.jl\n in the package to see what units are there by default.\n\n\nA note for the experts: Some care should be taken if explicitly creating \nUnitful.Units\n objects. The ordering of \nUnitful.Unit\n objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the \nUnits\n object will return a \"canonically sorted\" \nUnits\n object. Indeed, this is how we avoid ordering issues when multiplying quantities together.\n\n\n\n\nUseful functions and macros\n\n\n#\n\n\nUnitful.@dimension\n \n \nMacro\n.\n\n\nmacro dimension(symb, abbr, name)\n\n\n\n\n\nCreates new dimensions. \nname\n will be used like an identifier in the type parameter for a \nUnitful.Dimension\n object. \nsymb\n will be a symbol defined in the namespace from which this macro is called that is bound to a \nUnitful.Dimensions\n object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.\n\n\nThis macro extends \nUnitful.abbr\n to display the new dimension in an abbreviated format using the string \nabbr\n.\n\n\nFinally, type aliases are created that allow the user to dispatch on \nUnitful.Quantity\n and \nUnitful.Units\n objects of the newly defined dimension. The type alias for quantities is simply given by \nname\n, and the type alias for units is given by \nname*\"Unit\"\n, e.g. \nLengthUnit\n.\n\n\nUsage example: \n@dimension \ud835\udc0b \"L\" Length\n (see \nsrc/Defaults.jl\n.)\n\n\nsource\n\n\n#\n\n\nUnitful.@derived_dimension\n \n \nMacro\n.\n\n\nmacro derived_dimension(name, dims)\n\n\n\n\n\nCreates type aliases to allow dispatch on \nUnitful.Quantity\n and \nUnitful.Units\n objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.\n\n\ndims\n is a \nUnitful.Dimensions\n object.\n\n\nUsage examples:\n\n\n\n\n@derived_dimension Area \ud835\udc0b^2\n gives \nArea\n and \nAreaUnit\n type aliases\n\n\n@derived_dimension Speed \ud835\udc0b/\ud835\udc13\n gives \nSpeed\n and \nSpeedUnit\n type aliases\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.@refunit\n \n \nMacro\n.\n\n\nmacro refunit(symb, name, abbr, dimension, tf)\n\n\n\n\n\nDefine a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.\n\n\nThis macro extends \nUnitful.abbr\n so that the reference unit can be displayed in an abbreviated format. If \ntf == true\n, this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A \ndimension\n must be given (\nUnitful.Dimensions\n object) that specifies the dimension of the reference unit.\n\n\nUsage example: \n@refunit m \"m\" Meter \ud835\udc0b true\n\n\nThis example will generate \nkm\n, \nm\n, \ncm\n, ...\n\n\nsource\n\n\n#\n\n\nUnitful.@preferunit\n \n \nMacro\n.\n\n\nmacro preferunit(unit)\n\n\n\n\n\nThis macro specifies the default unit for promotion for a given dimension, which is inferred from the given unit.\n\n\nUsage example: \n@preferunit kg\n\n\nsource\n\n\n#\n\n\nUnitful.@unit\n \n \nMacro\n.\n\n\nmacro unit(symb,abbr,name,equals,tf)\n\n\n\n\n\nDefine a unit. Rather than specifying a dimension like in \n@refunit\n, \nequals\n should be a \nUnitful.Quantity\n equal to one of the unit being defined. If \ntf == true\n, symbols will be made for each power-of-ten prefix.\n\n\nUsage example: \n@unit mi \"mi\" Mile (201168//125)*m false\n\n\nThis example will \nnot\n generate \nkmi\n (kilomiles).\n\n\nsource\n\n\n#\n\n\nUnitful.offsettemp\n \n \nFunction\n.\n\n\noffsettemp(::Unit)\n\n\n\n\n\nFor temperature units, this function is used to set the scale offset.\n\n\nsource\n\n\n\n\nInternals\n\n\n#\n\n\nUnitful.@prefixed_unit_symbols\n \n \nMacro\n.\n\n\nmacro prefixed_unit_symbols(symb,name)\n\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.\n\n\nExample: \n@prefixed_unit_symbols m Meter\n results in nm, cm, m, km, ... all getting defined in the calling namespace.\n\n\nsource\n\n\n#\n\n\nUnitful.@unit_symbols\n \n \nMacro\n.\n\n\nmacro unit_symbols(symb,name)\n\n\n\n\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.\n\n\nExample: \n@unit_symbols ft Foot\n results in \nft\n getting defined but not \nkft\n.\n\n\nsource\n\n\n#\n\n\nUnitful.basefactor\n \n \nFunction\n.\n\n\nbasefactor(x::Unit)\n\n\n\n\n\nSpecifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.\n\n\nsource", 
            "title": "Defining new units"
        }, 
        {
            "location": "/newunits/#useful-functions-and-macros", 
            "text": "#  Unitful.@dimension     Macro .  macro dimension(symb, abbr, name)  Creates new dimensions.  name  will be used like an identifier in the type parameter for a  Unitful.Dimension  object.  symb  will be a symbol defined in the namespace from which this macro is called that is bound to a  Unitful.Dimensions  object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.  This macro extends  Unitful.abbr  to display the new dimension in an abbreviated format using the string  abbr .  Finally, type aliases are created that allow the user to dispatch on  Unitful.Quantity  and  Unitful.Units  objects of the newly defined dimension. The type alias for quantities is simply given by  name , and the type alias for units is given by  name*\"Unit\" , e.g.  LengthUnit .  Usage example:  @dimension \ud835\udc0b \"L\" Length  (see  src/Defaults.jl .)  source  #  Unitful.@derived_dimension     Macro .  macro derived_dimension(name, dims)  Creates type aliases to allow dispatch on  Unitful.Quantity  and  Unitful.Units  objects of a derived dimension, like area, which is just length squared. The type aliases are not exported.  dims  is a  Unitful.Dimensions  object.  Usage examples:   @derived_dimension Area \ud835\udc0b^2  gives  Area  and  AreaUnit  type aliases  @derived_dimension Speed \ud835\udc0b/\ud835\udc13  gives  Speed  and  SpeedUnit  type aliases   source  #  Unitful.@refunit     Macro .  macro refunit(symb, name, abbr, dimension, tf)  Define a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.  This macro extends  Unitful.abbr  so that the reference unit can be displayed in an abbreviated format. If  tf == true , this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A  dimension  must be given ( Unitful.Dimensions  object) that specifies the dimension of the reference unit.  Usage example:  @refunit m \"m\" Meter \ud835\udc0b true  This example will generate  km ,  m ,  cm , ...  source  #  Unitful.@preferunit     Macro .  macro preferunit(unit)  This macro specifies the default unit for promotion for a given dimension, which is inferred from the given unit.  Usage example:  @preferunit kg  source  #  Unitful.@unit     Macro .  macro unit(symb,abbr,name,equals,tf)  Define a unit. Rather than specifying a dimension like in  @refunit ,  equals  should be a  Unitful.Quantity  equal to one of the unit being defined. If  tf == true , symbols will be made for each power-of-ten prefix.  Usage example:  @unit mi \"mi\" Mile (201168//125)*m false  This example will  not  generate  kmi  (kilomiles).  source  #  Unitful.offsettemp     Function .  offsettemp(::Unit)  For temperature units, this function is used to set the scale offset.  source", 
            "title": "Useful functions and macros"
        }, 
        {
            "location": "/newunits/#internals", 
            "text": "#  Unitful.@prefixed_unit_symbols     Macro .  macro prefixed_unit_symbols(symb,name)  Not called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit.  Example:  @prefixed_unit_symbols m Meter  results in nm, cm, m, km, ... all getting defined in the calling namespace.  source  #  Unitful.@unit_symbols     Macro .  macro unit_symbols(symb,name)  Not called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.  Example:  @unit_symbols ft Foot  results in  ft  getting defined but not  kft .  source  #  Unitful.basefactor     Function .  basefactor(x::Unit)  Specifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.  source", 
            "title": "Internals"
        }, 
        {
            "location": "/conversion/", 
            "text": "Converting between units\n\n\nSince \nconvert\n in Julia already means something specific (conversion between Julia types), we define \nuconvert\n for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.\n\n\n#\n\n\nUnitful.uconvert\n \n \nFunction\n.\n\n\nuconvert{T,U}(a::Units, x::Quantity{T,U})\n\n\n\n\n\nConvert a \nUnitful.Quantity\n to different units. The conversion will fail if the target units \na\n have a different dimension than the dimension of the quantity \nx\n. You can use this method to switch between equivalent representations of the same unit, like \nN m\n and \nJ\n.\n\n\nExample:\n\n\njulia\n \nuconvert\n(\nu\nhr\n,\n3602\nu\ns\n)\n\n\n1801//1800 hr\n\n\njulia\n \nuconvert\n(\nu\nJ\n,\n1.0\nu\nN*m\n)\n\n\n1.0 J\n\n\n\n\n\n\nsource\n\n\nuconvert{T,U}(a::Units, x::Quantity{T,Dimensions{(Dimension{:Temperature}(1),)},U})\n\n\n\n\n\nIn this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions.\n\n\nsource\n\n\nSince objects are callable, we can also make \nUnitful.Units\n callable with a \nNumber\n as an argument, for a unit conversion shorthand:\n\n\njulia\n \nu\ncm\n(\n1\nu\nm\n)\n\n\n100//1 cm\n\n\n\n\n\n\nThis syntax is a little confusing, but becomes appealing with the function chaining operator \n|\n:\n\n\njulia\n \n1\nu\nm\n \n|\n \nu\ncm\n\n\n100//1 cm\n\n\n\n\n\n\nNote that since \nUnitful.Units\n objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling \nuconvert\n.\n\n\n\n\nDimensionless quantities\n\n\nFor dimensionless quantities, \nuconvert\n can be used to strip the units without losing power-of-ten information:\n\n\njulia\n \nuconvert\n(\nUnitful\n.\nNoUnits\n,\n \n1.0\nu\n\u03bcm/m\n)\n\n\n1.0e-6\n\n\n\njulia\n \nuconvert\n(\nUnitful\n.\nNoUnits\n,\n \n1.0\nu\nm\n)\n\n\nERROR: Unitful.DimensionError()\n\n\n\n\n\n\nYou can also directly convert to a subtype of \nReal\n or \nComplex\n:\n\n\njulia\n \nFloat64\n(\n1.0\nu\n\u03bcm/m\n)\n\n\n1.0e-6\n\n\n\n\n\n\n\n\nBasic conversion and promotion mechanisms\n\n\nExact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.\n\n\nWe decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance. If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion. The \nUnitful.@preferunit\n macro is used in \ndeps/Defaults.jl\n to designate preferred units for each pure dimension for promotion. Adding two masses with different units will give a result in \nkg\n. Adding two velocities with different units will give \nm/s\n, and so on. You can special case for \"mixed\" dimensions, e.g. such that the preferred units of energy are \nJ\n. The behaviors can be changed in \ndeps/Defaults.jl\n.\n\n\nFor multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance, \nmV/V\n is not simplified, although \nV/V\n is. Also, \nN*m/J\n is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.\n\n\n\n\nArray promotion\n\n\nArrays are typed with as much specificity as possible upon creation. consider the following three cases:\n\n\njulia\n \n[\n1.0\nu\nm\n,\n \n2.0\nu\nm\n]\n\n\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n\n\n 1.0 m\n\n\n 2.0 m\n\n\n\njulia\n \n[\n1.0\nu\nm\n,\n \n2.0\nu\ncm\n]\n\n\n2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n\n\n  1.0 m\n\n\n 0.02 m\n\n\n\njulia\n \n[\n1.0\nu\nm\n,\n \n2.0\n]\n\n\n2-element Array{Number,1}:\n\n\n 1.0 m\n\n\n     2.0\n\n\n\n\n\n\nIn the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:\n\n\njulia\n \nf\n{\nT\n:\nUnitful\n.\nLength\n}(\nx\n::\nAbstractArray\n{\nT\n})\n \n=\n \nsum\n(\nx\n)\n\n\nf (generic function with 1 method)\n\n\n\njulia\n \nf\n([\n1.0\nu\nm\n,\n \n2.0\nu\ncm\n])\n\n\n1.02 m\n\n\n\njulia\n \nf\n([\n1.0\nu\ng\n,\n \n2.0\nu\ncm\n])\n\n\nERROR: MethodError: no method matching f(::Array{Number,1})\n\n\n\n\n\n\n\n\nTemperature conversion\n\n\nIf the dimension of a \nQuantity\n is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature \nintervals\n.", 
            "title": "Conversion"
        }, 
        {
            "location": "/conversion/#converting-between-units", 
            "text": "Since  convert  in Julia already means something specific (conversion between Julia types), we define  uconvert  for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.  #  Unitful.uconvert     Function .  uconvert{T,U}(a::Units, x::Quantity{T,U})  Convert a  Unitful.Quantity  to different units. The conversion will fail if the target units  a  have a different dimension than the dimension of the quantity  x . You can use this method to switch between equivalent representations of the same unit, like  N m  and  J .  Example:  julia   uconvert ( u hr , 3602 u s )  1801//1800 hr  julia   uconvert ( u J , 1.0 u N*m )  1.0 J   source  uconvert{T,U}(a::Units, x::Quantity{T,Dimensions{(Dimension{:Temperature}(1),)},U})  In this method, we are special-casing temperature conversion to respect scale offsets, if they do not appear in combination with other dimensions.  source  Since objects are callable, we can also make  Unitful.Units  callable with a  Number  as an argument, for a unit conversion shorthand:  julia   u cm ( 1 u m )  100//1 cm   This syntax is a little confusing, but becomes appealing with the function chaining operator  | :  julia   1 u m   |   u cm  100//1 cm   Note that since  Unitful.Units  objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling  uconvert .", 
            "title": "Converting between units"
        }, 
        {
            "location": "/conversion/#dimensionless-quantities", 
            "text": "For dimensionless quantities,  uconvert  can be used to strip the units without losing power-of-ten information:  julia   uconvert ( Unitful . NoUnits ,   1.0 u \u03bcm/m )  1.0e-6  julia   uconvert ( Unitful . NoUnits ,   1.0 u m )  ERROR: Unitful.DimensionError()   You can also directly convert to a subtype of  Real  or  Complex :  julia   Float64 ( 1.0 u \u03bcm/m )  1.0e-6", 
            "title": "Dimensionless quantities"
        }, 
        {
            "location": "/conversion/#basic-conversion-and-promotion-mechanisms", 
            "text": "Exact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.  We decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance. If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion. The  Unitful.@preferunit  macro is used in  deps/Defaults.jl  to designate preferred units for each pure dimension for promotion. Adding two masses with different units will give a result in  kg . Adding two velocities with different units will give  m/s , and so on. You can special case for \"mixed\" dimensions, e.g. such that the preferred units of energy are  J . The behaviors can be changed in  deps/Defaults.jl .  For multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance,  mV/V  is not simplified, although  V/V  is. Also,  N*m/J  is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not.", 
            "title": "Basic conversion and promotion mechanisms"
        }, 
        {
            "location": "/conversion/#array-promotion", 
            "text": "Arrays are typed with as much specificity as possible upon creation. consider the following three cases:  julia   [ 1.0 u m ,   2.0 u m ]  2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:   1.0 m   2.0 m  julia   [ 1.0 u m ,   2.0 u cm ]  2-element Array{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:    1.0 m   0.02 m  julia   [ 1.0 u m ,   2.0 ]  2-element Array{Number,1}:   1.0 m       2.0   In the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:  julia   f { T : Unitful . Length }( x :: AbstractArray { T })   =   sum ( x )  f (generic function with 1 method)  julia   f ([ 1.0 u m ,   2.0 u cm ])  1.02 m  julia   f ([ 1.0 u g ,   2.0 u cm ])  ERROR: MethodError: no method matching f(::Array{Number,1})", 
            "title": "Array promotion"
        }, 
        {
            "location": "/conversion/#temperature-conversion", 
            "text": "If the dimension of a  Quantity  is purely temperature, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature  intervals .", 
            "title": "Temperature conversion"
        }, 
        {
            "location": "/manipulations/", 
            "text": "#\n\n\nUnitful.@u_str\n \n \nMacro\n.\n\n\nmacro u_str(unit)\n\n\n\n\n\nString macro to easily recall units, dimensions, or quantities defined in the Unitful module, which does not export such things to avoid namespace pollution. Note that for now, what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".\n\n\nExamples:\n\n\njulia\n \n1.0\nu\nm/s\n\n\n1.0 m s^-1\n\n\n\njulia\n \n1.0\nu\nN*m\n\n\n1.0 m N\n\n\n\njulia\n \ntypeof\n(\n1.0\nu\nm/s\n)\n\n\nQuantity{Float64, Dimensions:{\ud835\udc0b \ud835\udc13^-1}, Units:{m s^-1}}\n\n\n\njulia\n \nu\n\u0127\n\n\n1.0545718001391127e-34 J s\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.unit\n \n \nFunction\n.\n\n\nunit{T,D,U}(x::Quantity{T,D,U})\n\n\n\n\n\nReturns the units associated with a quantity, \nU()\n.\n\n\nExamples:\n\n\njulia\n \nunit\n(\n1.0\nu\nm\n)\n \n==\n \nu\nm\n\n\ntrue\n\n\n\njulia\n \ntypeof\n(\nu\nm\n)\n\n\nUnitful.Units{(Unitful.Unit{:Meter}(0,1//1),),Unitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}}\n\n\n\n\n\n\nsource\n\n\nunit{T,D,U}(x::Type{Quantity{T,D,U}})\n\n\n\n\n\nReturns the units associated with a quantity type, \nU()\n.\n\n\nExamples:\n\n\njulia\n \nunit\n(\ntypeof\n(\n1.0\nu\nm\n))\n \n==\n \nu\nm\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\nunit(x::Number)\n\n\n\n\n\nReturns a \nUnitful.Units{(), Dimensions{()}}\n object to indicate that ordinary numbers have no units. This is a singleton, which we export as \nNoUnits\n. The unit is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n \ntypeof\n(\nunit\n(\n1.0\n))\n\n\nUnitful.Units{(),Unitful.Dimensions{()}}\n\n\njulia\n \ntypeof\n(\nunit\n(\nFloat64\n))\n\n\nUnitful.Units{(),Unitful.Dimensions{()}}\n\n\njulia\n \nunit\n(\n1.0\n)\n \n==\n \nNoUnits\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.ustrip\n \n \nFunction\n.\n\n\nustrip(x::Number)\n\n\n\n\n\nReturns the number out in front of any units. This may be different from the value in the case of dimensionless quantities. See \nuconvert\n and the example below. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is just calling \nx/unit(x)\n, which is as fast as directly accessing the \nval\n field of \nx::Quantity\n, but also works for any other kind of number.\n\n\nThis function is mainly intended for compatibility with packages that don't know how to handle quantities. This function may be deprecated in the future.\n\n\njulia\n \nustrip\n(\n2\nu\n\u03bcm/m\n)\n \n==\n \n2\n\n\ntrue\n\n\n\njulia\n \nuconvert\n(\nNoUnits\n,\n \n2\nu\n\u03bcm/m\n)\n \n==\n \n2\n//\n1000000\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\nustrip{T,D,U}(x::Array{Quantity{T,D,U}})\n\n\n\n\n\nStrip units from an \nArray\n by reinterpreting to type \nT\n. The resulting \nArray\n is a \"unit free view\" into array \nx\n. Because the units are removed, information may be lost and this should be used with some care.\n\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example. This function may be deprecated in the future.\n\n\njulia\n \na\n \n=\n \n[\n1\nu\nm\n,\n \n2\nu\nm\n]\n\n\n2-element Array{Quantity{Int64, Dimensions:{\ud835\udc0b}, Units:{m}},1}:\n\n\n 1 m\n\n\n 2 m\n\n\n\njulia\n \nb\n \n=\n \nustrip\n(\na\n)\n\n\n2-element Array{Int64,1}:\n\n\n 1\n\n\n 2\n\n\n\njulia\n \na\n[\n1\n]\n \n=\n \n3\nu\nm\n;\n \nb\n\n\n2-element Array{Int64,1}:\n\n\n 3\n\n\n 2\n\n\n\n\n\n\nsource\n\n\nustrip{T\n:Number}(x::Array{T})\n\n\n\n\n\nFall-back that returns \nx\n.\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(x::Number)\ndimension{T\n:Number}(x::Type{T})\n\n\n\n\n\nReturns a \nUnitful.Dimensions{()}\n object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as \nNoDims\n. The dimension is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n \ntypeof\n(\ndimension\n(\n1.0\n))\n\n\nUnitful.Dimensions{()}\n\n\njulia\n \ntypeof\n(\ndimension\n(\nFloat64\n))\n\n\nUnitful.Dimensions{()}\n\n\njulia\n \ndimension\n(\n1.0\n)\n \n==\n \nNoDims\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{U,D}(u::Units{U,D})\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object corresponding to the dimensions of the units, \nD()\n. For a dimensionless combination of units, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n \ndimension\n(\nu\nm\n)\n\n\n\ud835\udc0b\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\nu\nm\n))\n\n\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\nu\nm/km\n))\n\n\nUnitful.Dimensions{()}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension(x::Number)\ndimension{T\n:Number}(x::Type{T})\n\n\n\n\n\nReturns a \nUnitful.Dimensions{()}\n object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as \nNoDims\n. The dimension is displayed as an empty string.\n\n\nExamples:\n\n\njulia\n \ntypeof\n(\ndimension\n(\n1.0\n))\n\n\nUnitful.Dimensions{()}\n\n\njulia\n \ntypeof\n(\ndimension\n(\nFloat64\n))\n\n\nUnitful.Dimensions{()}\n\n\njulia\n \ndimension\n(\n1.0\n)\n \n==\n \nNoDims\n\n\ntrue\n\n\n\n\n\n\nsource\n\n\ndimension{D}(x::DimensionedQuantity{D})\n\n\n\n\n\nReturns a \nUnitful.Dimensions\n object \nD()\n corresponding to the dimensions of quantity \nx\n. For a dimensionless \nUnitful.Quantity\n, a \nUnitful.Dimensions{()}\n object is returned.\n\n\nExamples:\n\n\njulia\n \ndimension\n(\n1.0\nu\nm\n)\n\n\n\ud835\udc0b\n\n\n\njulia\n \ntypeof\n(\ndimension\n(\n1.0\nu\nm/\u03bcm\n))\n\n\nUnitful.Dimensions{()}\n\n\n\n\n\n\nsource\n\n\n#\n\n\nUnitful.dimension\n \n \nMethod\n.\n\n\ndimension{T\n:Units}(x::AbstractArray{T})\n\n\n\n\n\nJust calls \nmap(dimension, x)\n.\n\n\nsource\n\n\n#\n\n\nBase.:*\n \n \nMethod\n.\n\n\n*(a0::Unitlike, a::Unitlike...)\n\n\n\n\n\nGiven however many unit-like objects, multiply them together. Both \nUnitful.Dimensions\n and \nUnitful.Units\n objects are considered to be \nUnitlike\n in the sense that you can multiply them, divide them, and collect powers. This function will fail if there is an attempt to multiply a unit by a dimension or vice versa.\n\n\nCollect \nUnitful.Unit\n objects from the type parameter of the \nUnitful.Units\n objects. For identical units including SI prefixes (i.e. cm \u2260 m), collect powers and sort uniquely by the name of the \nUnit\n. The unique sorting permits easy unit comparisons.\n\n\nExamples:\n\n\njulia\n \nu\nkg*m/s^2\n\n\nkg m s^-2\n\n\n\njulia\n \nu\nm/s*kg/s\n\n\nkg m s^-2\n\n\n\njulia\n \ntypeof\n(\nu\nm/s*kg/s\n)\n \n==\n \ntypeof\n(\nu\nkg*m/s^2\n)\n\n\ntrue\n\n\n\n\n\n\nsource", 
            "title": "Manipulations"
        }, 
        {
            "location": "/display/", 
            "text": "#\n\n\nUnitful.abbr\n \n \nFunction\n.\n\n\nabbr(x)\n provides abbreviations for units or dimensions. Since a method should always be defined for each unit and dimension type, absence of a method for a specific unit or dimension type is likely an error. Consequently, we return \u2753 for generic arguments to flag unexpected behavior.\n\n\nsource\n\n\n#\n\n\nUnitful.prefix\n \n \nFunction\n.\n\n\nprefix(x::Unit)\n\n\n\n\n\nReturns a string representing the SI prefix for the power-of-ten held by this particular unit.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO, x::Quantity)\n\n\n\n\n\nShow a unitful quantity by calling \nshow\n on the numeric value, appending a space, and then calling \nshow\n on a units object \nU()\n.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow{T,D,U}(io::IO, ::Type{Quantity{T,D,U}})\n\n\n\n\n\nShow the type of a unitful quantity in a succinct way. Otherwise, array summaries are nearly unreadable.\n\n\nsource\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(io::IO,x::Unitlike)\n\n\n\n\n\nCall \nUnitful.showrep\n on each object in the tuple that is the type variable of a \nUnitful.Units\n or \nUnitful.Dimensions\n object.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Unit)\n\n\n\n\n\nShow the unit, prefixing with any decimal prefix and appending the exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.showrep\n \n \nMethod\n.\n\n\nshowrep(io::IO, x::Dimension)\n\n\n\n\n\nShow the dimension, appending any exponent as formatted by \nUnitful.superscript\n.\n\n\nsource\n\n\n#\n\n\nUnitful.superscript\n \n \nFunction\n.\n\n\nsuperscript(i::Rational)\n\n\n\n\n\nPrints exponents.\n\n\nsource", 
            "title": "How units are displayed"
        }, 
        {
            "location": "/trouble/", 
            "text": "Why do unit conversions yield rational numbers sometimes?\n\n\nWe use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point \n2.54\n is not equal to \n254//100\n. As a consequence, \n1inch != 2.54cm\n, because Unitful respects exact conversions. To test for equivalence, instead use \n\u2248\n (\n\\approx\n tab-completion).\n\n\n\n\nBut I want a floating point number...\n\n\nfloat(x)\n is defined for \nUnitful.Quantity\n types, and is forwarded to the underlying numeric type (units are not affected).\n\n\nWe may consider adding an option in the defaults to turn on/off use of \nRational\n numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that \ninv(2) === 0.5\n, not \n1//2\n).\n\n\n\n\nExponentiation\n\n\nMost operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a \nUnitful.Quantity\n object, raising a \nQuantity\n to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance. Example:\n\n\njulia\n \ntypeof\n((\n1.0\nu\nm\n)\n^\n2\n)\n\n\nQuantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}\n\n\n\njulia\n \ntypeof\n((\n1.0\nu\nm\n)\n^\n3\n)\n\n\nQuantity{Float64, Dimensions:{\ud835\udc0b^3}, Units:{m^3}}\n\n\n\n\n\n\nBecause the functions \ninv\n and \nsqrt\n are raising a \nQuantity\n to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a \nQuantity\n will be type-stable if done as \nx*x\n but not as \nx^2\n.\n\n\n\n\nPromotion with dimensionless numbers\n\n\nMost of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that \n\u03bcm/m\n and \nrad\n are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.\n\n\nThe result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles, \n1 rad\n is essentially just \n1\n, giving sane behavior:\n\n\njulia\n \n\u03c0\n/\n2\n*\nu\nrad\n+\n90\nu\n\u00b0\n\n\n3.141592653589793\n\n\n\n\n\n\n\n\nOther random problems\n\n\nIf using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:\n\n\njulia\n \nusing\n \nUnitful\n:\n \nm\n,\ncm\n\n\n\njulia\n \nuconvert\n(\nm\n,\n0x01c\nm\n)\n   \n# the user means cm, not 0x01c*m\n\n\n0x001c m\n\n\n\n\n\n\nThis behavior is a consequence of \na Julia issue\n.\n\n\n\n\nI have a different problem\n\n\nPlease raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/trouble/#why-do-unit-conversions-yield-rational-numbers-sometimes", 
            "text": "We use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point  2.54  is not equal to  254//100 . As a consequence,  1inch != 2.54cm , because Unitful respects exact conversions. To test for equivalence, instead use  \u2248  ( \\approx  tab-completion).", 
            "title": "Why do unit conversions yield rational numbers sometimes?"
        }, 
        {
            "location": "/trouble/#but-i-want-a-floating-point-number", 
            "text": "float(x)  is defined for  Unitful.Quantity  types, and is forwarded to the underlying numeric type (units are not affected).  We may consider adding an option in the defaults to turn on/off use of  Rational  numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that  inv(2) === 0.5 , not  1//2 ).", 
            "title": "But I want a floating point number..."
        }, 
        {
            "location": "/trouble/#exponentiation", 
            "text": "Most operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a  Unitful.Quantity  object, raising a  Quantity  to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance. Example:  julia   typeof (( 1.0 u m ) ^ 2 )  Quantity{Float64, Dimensions:{\ud835\udc0b^2}, Units:{m^2}}  julia   typeof (( 1.0 u m ) ^ 3 )  Quantity{Float64, Dimensions:{\ud835\udc0b^3}, Units:{m^3}}   Because the functions  inv  and  sqrt  are raising a  Quantity  to a fixed power (-1 and 1/2, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a  Quantity  will be type-stable if done as  x*x  but not as  x^2 .", 
            "title": "Exponentiation"
        }, 
        {
            "location": "/trouble/#promotion-with-dimensionless-numbers", 
            "text": "Most of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that  \u03bcm/m  and  rad  are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.  The result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles,  1 rad  is essentially just  1 , giving sane behavior:  julia   \u03c0 / 2 * u rad + 90 u \u00b0  3.141592653589793", 
            "title": "Promotion with dimensionless numbers"
        }, 
        {
            "location": "/trouble/#other-random-problems", 
            "text": "If using units with some of the unsigned types... well, I'm not sure what you are doing, but you should be aware of this:  julia   using   Unitful :   m , cm  julia   uconvert ( m , 0x01c m )     # the user means cm, not 0x01c*m  0x001c m   This behavior is a consequence of  a Julia issue .", 
            "title": "Other random problems"
        }, 
        {
            "location": "/trouble/#i-have-a-different-problem", 
            "text": "Please raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.", 
            "title": "I have a different problem"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nThe Unitful.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "The Unitful.jl package is licensed under the MIT \"Expat\" License:   Copyright (c) 2016: Andrew Keller.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}