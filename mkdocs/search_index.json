{
    "docs": [
        {
            "location": "/", 
            "text": "Unitful.jl\n\n\nA Julia package for physical units. Available\n\nhere\n. Inspired by Keno Fischer's\nvery clever package \nSIUnits.jl\n.\n\n\nWe want to support not only SI units but also any other unit system. We also\nwant to minimize or in some cases eliminate the run-time penalty of units.\nThere should be facilities for dimensional analysis.\nAll of this should integrate easily with the usual mathematical operations\nand collections that are found in Julia base.\n\n\nFeatures\n\n\n\n\nSupport for rational exponents. Good for power spectral density, etc.\n\n\n\u201cSticky units\u201d: by default, no implicit conversions in multiplication or division\n\n\nWe allow for implicit conversions in addition and subtraction\n\n\n\n\n\n\nSome built-in dimensional analysis\n\n\nSupport for various \nRange\n types, including \nLinSpace\n\n\n\n\nQuick start\n\n\nInstallation\n\n\n\n\n\n\nUse a recent nightly build of Julia 0.5.\n\n\n\n\n\n\nPkg.clone(\"https://github.com/ajkeller34/Unitful.jl.git\")\n\n\n\n\n\n\nIn Julia\n\n\nusing Unitful\n\n\n\n\nCautiously disregard the several warnings about overwriting methods in Base,\nwhich are expected.\n\n\nBy default, SI units and their power-of-ten prefixes are exported. Other units\nare exported but not power-of-ten prefixes.\n\n\n\n\nm\n, \nkm\n, \ncm\n, etc. are exported.\n\n\nnft\n for nano-foot is not exported.\n\n\n\n\nSome unit abbreviations conflict with Julia definitions or syntax:\n\n\n\n\ninch\n is used instead of \nin\n\n\nminute\n is used instead of \nmin\n\n\n\n\nUsage examples\n\n\n\n# The following are true:\n1kg == 1000g                    # Equivalence implies unit conversion\n!(1kg === 1000g)                # ...and yet we can distinguish these...\n1kg === 1kg                     # ...and these are indistinguishable.\n\n# Also true:\nunit(convert(\u00b0C, 212\u00b0F)) === \u00b0C\nunitless(convert(\u00b0C, 212\u00b0F)) \u2248 100\n# Note: use the \\approx tab-completion. Sometimes \u2248 is needed if there are tiny\n# floating-point errors (see to-do list note, regarding exact conversions)\n\n# Also true:\nconvert(\u00b5m/(m*\u00b0F), 9\u00b5m/(m*\u00b0C)) \u2248 5\u00b5m/(m*\u00b0F)\nmod(1h+3minute+5s, 24s) == 17s\n\nlinspace(1m, 100m, 20)\n# 20-element LinSpace{Unitful.FloatQuantity{Float64,Unitful.UnitData{(m,)}}}:\n# 1.0 m, 6.21053 m, ...\n\n\n\n\nSee \ntest/runtests.jl\n for more usage examples.\n\n\nTesting this package\n\n\nThere are of course subtleties in getting this all to work. To test that\nchanges to either Julia or Unitful haven't given rise to undesirable behavior,\nrun the test suite in Julia:\n\n\ncd(Pkg.dir(\nUnitful\n))\ninclude(\ntest/runtests.jl\n)\n\n\n\n\nTo do\n\n\n\n\n\n\nClean up how units/quantities are displayed.\nI'm waiting on \nshow\n, \nprint\n, etc.\nto be cleaned up before I work on this myself (see \nissue #14052\n and others).\n\n\n\n\n\n\nRespect exact conversions: Right now if we convert 12 inches to feet the result\nis unnecessarily floating-point based. In whole or part this is because of the method\n\nbasefactor(x::UnitDatum)\n: right now there is an explicit floating point\nconversion.\n\n\n\n\n\n\nClean up sin(degrees), etc. (not done nicely)\n\n\n\n\n\n\nAdd more units (easy pull request for someone interested)\n\n\n\n\n\n\nBenchmarking needed!\n\n\n\n\n\n\nMore tests would be nice\n\n\n\n\n\n\nAdd support for uncertainties? For quantities with uncertainty, \nisapprox\n\nbecomes a loaded / ambiguous name.", 
            "title": "Home"
        }, 
        {
            "location": "/#unitfuljl", 
            "text": "A Julia package for physical units. Available here . Inspired by Keno Fischer's\nvery clever package  SIUnits.jl .  We want to support not only SI units but also any other unit system. We also\nwant to minimize or in some cases eliminate the run-time penalty of units.\nThere should be facilities for dimensional analysis.\nAll of this should integrate easily with the usual mathematical operations\nand collections that are found in Julia base.", 
            "title": "Unitful.jl"
        }, 
        {
            "location": "/#features", 
            "text": "Support for rational exponents. Good for power spectral density, etc.  \u201cSticky units\u201d: by default, no implicit conversions in multiplication or division  We allow for implicit conversions in addition and subtraction    Some built-in dimensional analysis  Support for various  Range  types, including  LinSpace", 
            "title": "Features"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Installation    Use a recent nightly build of Julia 0.5.    Pkg.clone(\"https://github.com/ajkeller34/Unitful.jl.git\")    In Julia  using Unitful  Cautiously disregard the several warnings about overwriting methods in Base,\nwhich are expected.  By default, SI units and their power-of-ten prefixes are exported. Other units\nare exported but not power-of-ten prefixes.   m ,  km ,  cm , etc. are exported.  nft  for nano-foot is not exported.   Some unit abbreviations conflict with Julia definitions or syntax:   inch  is used instead of  in  minute  is used instead of  min   Usage examples  \n# The following are true:\n1kg == 1000g                    # Equivalence implies unit conversion\n!(1kg === 1000g)                # ...and yet we can distinguish these...\n1kg === 1kg                     # ...and these are indistinguishable.\n\n# Also true:\nunit(convert(\u00b0C, 212\u00b0F)) === \u00b0C\nunitless(convert(\u00b0C, 212\u00b0F)) \u2248 100\n# Note: use the \\approx tab-completion. Sometimes \u2248 is needed if there are tiny\n# floating-point errors (see to-do list note, regarding exact conversions)\n\n# Also true:\nconvert(\u00b5m/(m*\u00b0F), 9\u00b5m/(m*\u00b0C)) \u2248 5\u00b5m/(m*\u00b0F)\nmod(1h+3minute+5s, 24s) == 17s\n\nlinspace(1m, 100m, 20)\n# 20-element LinSpace{Unitful.FloatQuantity{Float64,Unitful.UnitData{(m,)}}}:\n# 1.0 m, 6.21053 m, ...  See  test/runtests.jl  for more usage examples.", 
            "title": "Quick start"
        }, 
        {
            "location": "/#testing-this-package", 
            "text": "There are of course subtleties in getting this all to work. To test that\nchanges to either Julia or Unitful haven't given rise to undesirable behavior,\nrun the test suite in Julia:  cd(Pkg.dir( Unitful ))\ninclude( test/runtests.jl )", 
            "title": "Testing this package"
        }, 
        {
            "location": "/#to-do", 
            "text": "Clean up how units/quantities are displayed.\nI'm waiting on  show ,  print , etc.\nto be cleaned up before I work on this myself (see  issue #14052  and others).    Respect exact conversions: Right now if we convert 12 inches to feet the result\nis unnecessarily floating-point based. In whole or part this is because of the method basefactor(x::UnitDatum) : right now there is an explicit floating point\nconversion.    Clean up sin(degrees), etc. (not done nicely)    Add more units (easy pull request for someone interested)    Benchmarking needed!    More tests would be nice    Add support for uncertainties? For quantities with uncertainty,  isapprox \nbecomes a loaded / ambiguous name.", 
            "title": "To do"
        }, 
        {
            "location": "/implementation/", 
            "text": "Design and implementation\n\n\nA view from 30000 ft (or 9144 m)\n\n\nLike SIUnits.jl, units are part of the type signature of a quantity. From there,\nthe implementations diverge. Unitful.jl uses generated functions to enable more\nflexibility than found in SIUnits.jl. Support is targeted to Julia 0.5+\nbecause of some limitations in how \npromote_op\n is used in Julia 0.4. See\n\nissue #13803\n.\n\n\nWe make an immutable \nUnitDatum\n that stores a base unit (expressed a bits type\ngenerated by an \n@enum\n), a rational exponent, and a prefix. We don't allow\narbitrary floating point exponents of units because they probably aren't very useful.\nThe prefixes on units (e.g. \nnm\n or \nkm\n) may help to avoid overflow issues\nand general ugliness.\n\n\nWe define the immutable singleton \nUnitData{T}\n, where \nT\n is always a tuple\nof \nUnitDatum\n (variable number of arguments). Usually, the user interacts\nonly with \nUnitData{T}\n objects, not \nUnitDatum\n.\n\n\nWe define methods \ndimension\n that turn, for example, \nacre^2\n into \n[L]^4\n.\nWe can in principle add quantities with the same dimension\n(\nacre [L]^2 + ft^2 [L]^2\n), provided some \"promotion\" rules are given (see below).\nNote that dimensions cannot be determined\nby powers of the units: \nft^2\n is an area, but so is \nacre^1\n.\n\n\nWe define unitful \nQuantities\n \nRealQuantity{T\n:Real, Units}\n and\n\nFloatQuantity{T\n:AbstractFloat, Units}\n where \nUnits\n is\na type \nUnitData{T}\n. To play nicely with \nFloatRange\n and \nLinSpace\n, we need\n\nFloatQuantity \n: AbstractFloat\n; we also have \nRealQuantity \n: Real\n.\nBy putting units in the type signature of a quantity,\nstaged functions can be used to offload\nas much of the unit computation to compile-time as is possible.\n\n\nCreating new units\n\n\nA user interface for creating new units is as-of-yet non-existent. However, it\nis not hard to modify this package to create units.\n\n\nAdd the unit to the enumeration beginning with \n@enum(Unit,\n. Give\na method for \nabbr\n which specifies a string to display the unit, a\nmethod for \ndimension\n that tells the dimensions, and finally a method\nfor \nbasefactor\n. This should\nspecify what one of this unit corresponds to in equivalent base SI units.\nLooking at the code should clarify this. Finally, for ease of use you may want\nto define a constant for the new unit (or perhaps constants plural, if you want\npowers-of-ten prefixes). Look at \nDefaults.jl\n for how this is done.\n\n\nSome care should be taken if explicitly making \nUnitData\n objects. The ordering\nof \nUnitDatum\n inside a tuple matters for type comparisons. Using the unary\nmultiplication operator on the \nUnitData\n object will return a \"canonically sorted\"\n\nUnitData\n object. Indeed, this is how we avoid ordering issues when multiplying\nquantities together.\n\n\nConversion and promotions\n\n\nConversions between units are rejected if the units have different dimensions.\n\n\nWe decide the result units for addition and subtraction operations based\non looking at the unit types only. We can't take runtime values into account\nwithout compromising runtime performance. By default, if we\nhave \nx (A) + y (B) = z (C)\n where \nx,y,z\n are numbers and \nA,B,C\n are units,\nthen \nC = max(1A, 1B)\n. This is an arbitrary choice and can be changed in\n\nDefaults.jl\n. For example,\n\n101cm + 1m = 2.01m\n because \n1m \n 1cm\n.\n\n\nAlthough quantities could be integrated with Julia's promotion mechanisms,\nwe instead simply define how to add or subtract the units themselves,\nand have addition of quantities rely on those definitions.\nThe concern is that implicit promotion operations\nthat were written with pure numbers in mind may give rise to surprising\nbehavior without returning errors. The operations on the numeric values of\nquantities of course utilize Julia's promotion mechanisms.\n\n\nSome of our \nconvert\n syntax breaks Julia conventions in that the first\nargument is not a type. For example, \nconvert(ft, 1m)\n converts 1 meter to feet.\nThis may rub people the wrong way and could change. A neat alternative would be\nto override other syntax: \n3m in cm\n would be succinct and intuitive.\nOverriding \nin\n is simple, but the parsing rules aren't intended for this.\nFor example, \n0\u00b0C in \u00b0F \u2248 32\u00b0F\n fails to evaluate, but \n(0\u00b0C in \u00b0F) \u2248 32\u00b0F\n\nreturns \ntrue\n.\n\n\nTemperature conversion\n\n\nIf a unit is a pure temperature unit, then conversion respects scale offsets.\nFor instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F (\u00b1 some\nsmall floating point discrepancy). If instead temperature appears in\ncombination with other units, scale offsets don't make sense and we\nconsider temperature \nintervals\n. This gives the expected behavior most of the\ntime.\n\n\nDiscussion\n\n\n\n\n\n\nIf there is a need for complex numbers to have units, please implement that\nand submit a PR, adding tests where appropriate.\n\n\n\n\n\n\nSIUnits issue 18\n: Some discussion\nregarding how to define \none(x)\n and \nzero(x)\n for quantities with units. Right now\n\none(x)\n returns no units, but \nzero(x)\n returns units. This is consistent with\nJulia documentation; \none(x)\n should be multiplicative identity and \nzero(x)\n\nshould be additive identity.\n\n\n\n\n\n\nPotential improvements to Base\n\n\nIn writing this package I\u2019ve noticed a few places where changes to Base could be helpful. I keep redefinitions of methods found in Base in \nRedefinitions.jl\n. If I receive some encouraging feedback from a Julia contributor, maybe I\u2019ll submit a PR. In the meantime, try not to be annoyed by the redefinition warnings.\n\n\nTo give a flavor of the kind of changes I suggest, here is an example.\nAccording to the documentation, \none(x)\n is supposed to be the multiplicative identity for the type of x. There are several places in \nbase/range.jl\n, for example, where \none(x)\n is being used instead of \noftype(x,1)\n. This distinction could be important for types with units:\n\n(1m) * one(1m) == 1m\n, but \n1m+oftype(1m, 1) == 2m\n, and \n1m+one(1m)\n is invalid\nsince we cannot add unitful and unitless quantities.", 
            "title": "Design and implementation"
        }, 
        {
            "location": "/implementation/#design-and-implementation", 
            "text": "", 
            "title": "Design and implementation"
        }, 
        {
            "location": "/implementation/#a-view-from-30000-ft-or-9144-m", 
            "text": "Like SIUnits.jl, units are part of the type signature of a quantity. From there,\nthe implementations diverge. Unitful.jl uses generated functions to enable more\nflexibility than found in SIUnits.jl. Support is targeted to Julia 0.5+\nbecause of some limitations in how  promote_op  is used in Julia 0.4. See issue #13803 .  We make an immutable  UnitDatum  that stores a base unit (expressed a bits type\ngenerated by an  @enum ), a rational exponent, and a prefix. We don't allow\narbitrary floating point exponents of units because they probably aren't very useful.\nThe prefixes on units (e.g.  nm  or  km ) may help to avoid overflow issues\nand general ugliness.  We define the immutable singleton  UnitData{T} , where  T  is always a tuple\nof  UnitDatum  (variable number of arguments). Usually, the user interacts\nonly with  UnitData{T}  objects, not  UnitDatum .  We define methods  dimension  that turn, for example,  acre^2  into  [L]^4 .\nWe can in principle add quantities with the same dimension\n( acre [L]^2 + ft^2 [L]^2 ), provided some \"promotion\" rules are given (see below).\nNote that dimensions cannot be determined\nby powers of the units:  ft^2  is an area, but so is  acre^1 .  We define unitful  Quantities   RealQuantity{T :Real, Units}  and FloatQuantity{T :AbstractFloat, Units}  where  Units  is\na type  UnitData{T} . To play nicely with  FloatRange  and  LinSpace , we need FloatQuantity  : AbstractFloat ; we also have  RealQuantity  : Real .\nBy putting units in the type signature of a quantity,\nstaged functions can be used to offload\nas much of the unit computation to compile-time as is possible.", 
            "title": "A view from 30000 ft (or 9144 m)"
        }, 
        {
            "location": "/implementation/#creating-new-units", 
            "text": "A user interface for creating new units is as-of-yet non-existent. However, it\nis not hard to modify this package to create units.  Add the unit to the enumeration beginning with  @enum(Unit, . Give\na method for  abbr  which specifies a string to display the unit, a\nmethod for  dimension  that tells the dimensions, and finally a method\nfor  basefactor . This should\nspecify what one of this unit corresponds to in equivalent base SI units.\nLooking at the code should clarify this. Finally, for ease of use you may want\nto define a constant for the new unit (or perhaps constants plural, if you want\npowers-of-ten prefixes). Look at  Defaults.jl  for how this is done.  Some care should be taken if explicitly making  UnitData  objects. The ordering\nof  UnitDatum  inside a tuple matters for type comparisons. Using the unary\nmultiplication operator on the  UnitData  object will return a \"canonically sorted\" UnitData  object. Indeed, this is how we avoid ordering issues when multiplying\nquantities together.", 
            "title": "Creating new units"
        }, 
        {
            "location": "/implementation/#conversion-and-promotions", 
            "text": "Conversions between units are rejected if the units have different dimensions.  We decide the result units for addition and subtraction operations based\non looking at the unit types only. We can't take runtime values into account\nwithout compromising runtime performance. By default, if we\nhave  x (A) + y (B) = z (C)  where  x,y,z  are numbers and  A,B,C  are units,\nthen  C = max(1A, 1B) . This is an arbitrary choice and can be changed in Defaults.jl . For example, 101cm + 1m = 2.01m  because  1m   1cm .  Although quantities could be integrated with Julia's promotion mechanisms,\nwe instead simply define how to add or subtract the units themselves,\nand have addition of quantities rely on those definitions.\nThe concern is that implicit promotion operations\nthat were written with pure numbers in mind may give rise to surprising\nbehavior without returning errors. The operations on the numeric values of\nquantities of course utilize Julia's promotion mechanisms.  Some of our  convert  syntax breaks Julia conventions in that the first\nargument is not a type. For example,  convert(ft, 1m)  converts 1 meter to feet.\nThis may rub people the wrong way and could change. A neat alternative would be\nto override other syntax:  3m in cm  would be succinct and intuitive.\nOverriding  in  is simple, but the parsing rules aren't intended for this.\nFor example,  0\u00b0C in \u00b0F \u2248 32\u00b0F  fails to evaluate, but  (0\u00b0C in \u00b0F) \u2248 32\u00b0F \nreturns  true .", 
            "title": "Conversion and promotions"
        }, 
        {
            "location": "/implementation/#temperature-conversion", 
            "text": "If a unit is a pure temperature unit, then conversion respects scale offsets.\nFor instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F (\u00b1 some\nsmall floating point discrepancy). If instead temperature appears in\ncombination with other units, scale offsets don't make sense and we\nconsider temperature  intervals . This gives the expected behavior most of the\ntime.", 
            "title": "Temperature conversion"
        }, 
        {
            "location": "/implementation/#discussion", 
            "text": "If there is a need for complex numbers to have units, please implement that\nand submit a PR, adding tests where appropriate.    SIUnits issue 18 : Some discussion\nregarding how to define  one(x)  and  zero(x)  for quantities with units. Right now one(x)  returns no units, but  zero(x)  returns units. This is consistent with\nJulia documentation;  one(x)  should be multiplicative identity and  zero(x) \nshould be additive identity.", 
            "title": "Discussion"
        }, 
        {
            "location": "/implementation/#potential-improvements-to-base", 
            "text": "In writing this package I\u2019ve noticed a few places where changes to Base could be helpful. I keep redefinitions of methods found in Base in  Redefinitions.jl . If I receive some encouraging feedback from a Julia contributor, maybe I\u2019ll submit a PR. In the meantime, try not to be annoyed by the redefinition warnings.  To give a flavor of the kind of changes I suggest, here is an example.\nAccording to the documentation,  one(x)  is supposed to be the multiplicative identity for the type of x. There are several places in  base/range.jl , for example, where  one(x)  is being used instead of  oftype(x,1) . This distinction could be important for types with units: (1m) * one(1m) == 1m , but  1m+oftype(1m, 1) == 2m , and  1m+one(1m)  is invalid\nsince we cannot add unitful and unitless quantities.", 
            "title": "Potential improvements to Base"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\nv0.0.1      Currently under development", 
            "title": "Release notes"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "v0.0.1      Currently under development", 
            "title": "Releases"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nThe Unitful.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "The Unitful.jl package is licensed under the MIT \"Expat\" License:   Copyright (c) 2016: Andrew Keller.  Permission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:  The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}