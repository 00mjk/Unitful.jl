{
    "docs": [
        {
            "location": "/", 
            "text": "Unitful.jl\n\n\nA Julia package for physical units. Available \nhere\n. Inspired by Keno Fischer's very clever package \nSIUnits.jl\n.\n\n\nWe want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.\n\n\n\n\nFeatures\n\n\n\n\nSupport for rational exponents. Good for power spectral density, etc.\n\n\nExact conversions are respected by using Rationals.\n\n\nCan make new units using the \n@unit\n macro without digging through the code.\n\n\n\u201cSticky units\u201d: by default, no implicit conversions in multiplication or division   - We allow for implicit conversions in addition and subtraction\n\n\nSome built-in dimensional analysis\n\n\n\n\n\n\nQuick start\n\n\n\n\nInstallation\n\n\n\n\nUse a recent nightly build of Julia 0.5.\n\n\nPkg.clone(\"https://github.com/ajkeller34/Unitful.jl.git\")\n\n\n\n\n\n\nIn Julia\n\n\nusing\n \nUnitful\n\n\n\n\n\n\nCautiously disregard the several warnings about overwriting methods in Base, which are expected.\n\n\nBy default, SI units and their power-of-ten prefixes are exported. Other units are exported but not power-of-ten prefixes.\n\n\n\n\nm\n, \nkm\n, \ncm\n, etc. are exported.\n\n\nnft\n for nano-foot is not exported.\n\n\n\n\nSome unit abbreviations conflict with Julia definitions or syntax:\n\n\n\n\ninch\n is used instead of \nin\n\n\nminute\n is used instead of \nmin\n\n\n\n\n\n\nUsage examples\n\n\n# The following are true:\n\n\n1\nkg\n \n==\n \n1000\ng\n                    \n# Equivalence implies unit conversion\n\n\n!\n(\n1\nkg\n \n===\n \n1000\ng\n)\n                \n# ...and yet we can distinguish these...\n\n\n1\nkg\n \n===\n \n1\nkg\n                     \n# ...and these are indistinguishable.\n\n\n\n# Also true:\n\n\nunit\n(\nconvert\n(\n\u00b0C\n,\n \n212\n\u00b0F\n))\n \n===\n \n\u00b0C\n\n\nunitless\n(\nconvert\n(\n\u00b0C\n,\n \n212\n\u00b0F\n))\n \n==\n \n100\n\n\n# Note: use the \\approx tab-completion. Sometimes \u2248 is needed if there are tiny\n\n\n# floating-point errors (see to-do list note, regarding exact conversions)\n\n\n\n# Also true:\n\n\nconvert\n(\n\u00b5m\n/\n(\nm\n*\n\u00b0F\n),\n \n9\n\u00b5m\n/\n(\nm\n*\n\u00b0C\n))\n \n\u2248\n \n5\n\u00b5m\n/\n(\nm\n*\n\u00b0F\n)\n\n\nmod\n(\n1\nh\n+\n3\nminute\n+\n5\ns\n,\n \n24\ns\n)\n \n==\n \n17\ns\n\n\n\n\n\n\nSee \ntest/runtests.jl\n for more usage examples.\n\n\n\n\nGotchas\n\n\nOne inch is exactly equal to 2.54 cm. However, in Julia, the floating-point 2.54 is not equal to the Rational 254//100. As a consequence, \n1inch != 2.54cm\n, because Unitful respects exact conversions and 1 inch is really 254//100 cm. To test for equivalence, instead use \n\u2248\n (backslash approx tab-completion).\n\n\nThe above applies generically to any pair of units, not just inches and centimeters.\n\n\nRanges were once supported by overriding base. Somehow, they will be supported again at some point. I have stopped overriding base to reduce warnings and encourage broader package adoption.\n\n\n\n\nTesting this package\n\n\nThere are of course subtleties in getting this all to work. To test that changes to either Julia or Unitful haven't given rise to undesirable behavior, run the test suite in Julia:\n\n\nPkg\n.\ntest\n(\nUnitful\n)\n\n\n\n\n\n\n\n\nTo do\n\n\n\n\nClean up how units/quantities are displayed.\n\n\n\n\nI'm waiting on \nshow\n, \nprint\n, etc. to be cleaned up before I work on this myself (see \nissue #14052\n and others).\n\n\n\n\nClean up sin(degrees), etc. (not done nicely)\n\n\nBenchmarking needed!\n\n\nMore tests would be nice\n\n\nAdd support for uncertainties? For quantities with uncertainty, \nisapprox\n\n\n\n\nbecomes a loaded / ambiguous name.", 
            "title": "Home"
        }, 
        {
            "location": "/#unitfuljl", 
            "text": "A Julia package for physical units. Available  here . Inspired by Keno Fischer's very clever package  SIUnits.jl .  We want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are found in Julia base.", 
            "title": "Unitful.jl"
        }, 
        {
            "location": "/#features", 
            "text": "Support for rational exponents. Good for power spectral density, etc.  Exact conversions are respected by using Rationals.  Can make new units using the  @unit  macro without digging through the code.  \u201cSticky units\u201d: by default, no implicit conversions in multiplication or division   - We allow for implicit conversions in addition and subtraction  Some built-in dimensional analysis", 
            "title": "Features"
        }, 
        {
            "location": "/#quick-start", 
            "text": "", 
            "title": "Quick start"
        }, 
        {
            "location": "/#installation", 
            "text": "Use a recent nightly build of Julia 0.5.  Pkg.clone(\"https://github.com/ajkeller34/Unitful.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#in-julia", 
            "text": "using   Unitful   Cautiously disregard the several warnings about overwriting methods in Base, which are expected.  By default, SI units and their power-of-ten prefixes are exported. Other units are exported but not power-of-ten prefixes.   m ,  km ,  cm , etc. are exported.  nft  for nano-foot is not exported.   Some unit abbreviations conflict with Julia definitions or syntax:   inch  is used instead of  in  minute  is used instead of  min", 
            "title": "In Julia"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "# The following are true:  1 kg   ==   1000 g                      # Equivalence implies unit conversion  ! ( 1 kg   ===   1000 g )                  # ...and yet we can distinguish these...  1 kg   ===   1 kg                       # ...and these are indistinguishable.  # Also true:  unit ( convert ( \u00b0C ,   212 \u00b0F ))   ===   \u00b0C  unitless ( convert ( \u00b0C ,   212 \u00b0F ))   ==   100  # Note: use the \\approx tab-completion. Sometimes \u2248 is needed if there are tiny  # floating-point errors (see to-do list note, regarding exact conversions)  # Also true:  convert ( \u00b5m / ( m * \u00b0F ),   9 \u00b5m / ( m * \u00b0C ))   \u2248   5 \u00b5m / ( m * \u00b0F )  mod ( 1 h + 3 minute + 5 s ,   24 s )   ==   17 s   See  test/runtests.jl  for more usage examples.", 
            "title": "Usage examples"
        }, 
        {
            "location": "/#gotchas", 
            "text": "One inch is exactly equal to 2.54 cm. However, in Julia, the floating-point 2.54 is not equal to the Rational 254//100. As a consequence,  1inch != 2.54cm , because Unitful respects exact conversions and 1 inch is really 254//100 cm. To test for equivalence, instead use  \u2248  (backslash approx tab-completion).  The above applies generically to any pair of units, not just inches and centimeters.  Ranges were once supported by overriding base. Somehow, they will be supported again at some point. I have stopped overriding base to reduce warnings and encourage broader package adoption.", 
            "title": "Gotchas"
        }, 
        {
            "location": "/#testing-this-package", 
            "text": "There are of course subtleties in getting this all to work. To test that changes to either Julia or Unitful haven't given rise to undesirable behavior, run the test suite in Julia:  Pkg . test ( Unitful )", 
            "title": "Testing this package"
        }, 
        {
            "location": "/#to-do", 
            "text": "Clean up how units/quantities are displayed.   I'm waiting on  show ,  print , etc. to be cleaned up before I work on this myself (see  issue #14052  and others).   Clean up sin(degrees), etc. (not done nicely)  Benchmarking needed!  More tests would be nice  Add support for uncertainties? For quantities with uncertainty,  isapprox   becomes a loaded / ambiguous name.", 
            "title": "To do"
        }, 
        {
            "location": "/implementation/", 
            "text": "Design and implementation\n\n\n\n\nA view from 30000 ft (or 9144 m)\n\n\nLike SIUnits.jl, units are part of the type signature of a quantity. From there, the implementations diverge. Unitful.jl uses generated functions to enable more flexibility than found in SIUnits.jl. Support is targeted to Julia 0.5 and up.\n\n\nWe make an immutable \nUnitDatum\n that stores a base unit (expressed a bits type, either \nNormalUnit\n or \nTemperatureUnit\n), a rational exponent, and a prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g. \nnm\n or \nkm\n) may help to avoid overflow issues and general ugliness.\n\n\nWe define the immutable singleton \nUnitData{T}\n, where \nT\n is always a tuple of \nUnitDatum\n (variable number of arguments). Usually, the user interacts only with \nUnitData{T}\n objects, not \nUnitDatum\n.\n\n\nWe define methods \ndimension\n that turn, for example, \nacre^2\n into \n[L]^4\n. We can in principle add quantities with the same dimension (\nacre [L]^2 + ft^2 [L]^2\n), provided some \"promotion\" rules are given (see below). Note that dimensions cannot be determined by powers of the units: \nft^2\n is an area, but so is \nacre^1\n.\n\n\nWe define unitful \nQuantities\n \nRealQuantity{T\n:Real, Units}\n and \nFloatQuantity{T\n:AbstractFloat, Units}\n where \nUnits\n is a type \nUnitData{T}\n. To play nicely with \nFloatRange\n and \nLinSpace\n, we need \nFloatQuantity \n: AbstractFloat\n; we also have \nRealQuantity \n: Real\n. By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible.\n\n\n\n\nCreating new units\n\n\nJust use the \n@unit\n macro, providing four arguments: the symbol for the unit, how the unit is displayed, a quantity equivalent to one of the new unit, and a \nBool\n to indicate whether or not to make symbols for all SI prefixes (as in mm, km, etc.)\n\n\nUsage example:\n\n\n@\nunit\n \npim\n \n\u03c0-meter\n \n\u03c0\n*\nm\n \nfalse\n\n\n1\npim\n \n# displays as \n1 \u03c0-meter\n\n\nconvert\n(\nm\n,\n \n1\npim\n)\n \n# evaluates to 3.14159... m\n\n\n\n\n\n\nYou can look at \nDefaults.jl\n in the package to see what units are there by default.\n\n\nNote for the experts: Some care should be taken if explicitly making \nUnitData\n objects. The ordering of \nUnitDatum\n inside a tuple matters for type comparisons. Using the unary multiplication operator on the \nUnitData\n object will return a \"canonically sorted\" \nUnitData\n object. Indeed, this is how we avoid ordering issues when multiplying quantities together.\n\n\n\n\nConversion and promotions\n\n\nConversions between units are rejected if the units have different dimensions.\n\n\nWe decide the result units for addition and subtraction operations based on looking at the unit types only. We can't take runtime values into account without compromising runtime performance. By default, if we have \nx (A) + y (B) = z (C)\n where \nx,y,z\n are numbers and \nA,B,C\n are units, then \nC = max(1A, 1B)\n. This is an arbitrary choice and can be changed in \nDefaults.jl\n. For example, \n101cm + 1m = 2.01m\n because \n1m \n 1cm\n.\n\n\nAlthough quantities could be integrated with Julia's promotion mechanisms, we instead simply define how to add or subtract the units themselves, and have addition of quantities rely on those definitions. The concern is that implicit promotion operations that were written with pure numbers in mind may give rise to surprising behavior without returning errors. The operations on the numeric values of quantities of course utilize Julia's promotion mechanisms.\n\n\nSome of our \nconvert\n syntax breaks Julia conventions in that the first argument is not a type. For example, \nconvert(ft, 1m)\n converts 1 meter to feet. This may rub people the wrong way and could change. A neat alternative would be to override other syntax: \n3m in cm\n would be succinct and intuitive. Overriding \nin\n is simple, but the parsing rules aren't intended for this. For example, \n0\u00b0C in \u00b0F == 32\u00b0F\n fails to evaluate, but \n(0\u00b0C in \u00b0F) == 32\u00b0F\n returns \ntrue\n.\n\n\nExact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion will proceed.\n\n\n\n\nTemperature conversion\n\n\nIf a unit is a pure temperature unit, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature \nintervals\n. This gives the expected behavior most of the time.", 
            "title": "Implementation"
        }, 
        {
            "location": "/implementation/#design-and-implementation", 
            "text": "", 
            "title": "Design and implementation"
        }, 
        {
            "location": "/implementation/#a-view-from-30000-ft-or-9144-m", 
            "text": "Like SIUnits.jl, units are part of the type signature of a quantity. From there, the implementations diverge. Unitful.jl uses generated functions to enable more flexibility than found in SIUnits.jl. Support is targeted to Julia 0.5 and up.  We make an immutable  UnitDatum  that stores a base unit (expressed a bits type, either  NormalUnit  or  TemperatureUnit ), a rational exponent, and a prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g.  nm  or  km ) may help to avoid overflow issues and general ugliness.  We define the immutable singleton  UnitData{T} , where  T  is always a tuple of  UnitDatum  (variable number of arguments). Usually, the user interacts only with  UnitData{T}  objects, not  UnitDatum .  We define methods  dimension  that turn, for example,  acre^2  into  [L]^4 . We can in principle add quantities with the same dimension ( acre [L]^2 + ft^2 [L]^2 ), provided some \"promotion\" rules are given (see below). Note that dimensions cannot be determined by powers of the units:  ft^2  is an area, but so is  acre^1 .  We define unitful  Quantities   RealQuantity{T :Real, Units}  and  FloatQuantity{T :AbstractFloat, Units}  where  Units  is a type  UnitData{T} . To play nicely with  FloatRange  and  LinSpace , we need  FloatQuantity  : AbstractFloat ; we also have  RealQuantity  : Real . By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible.", 
            "title": "A view from 30000 ft (or 9144 m)"
        }, 
        {
            "location": "/implementation/#creating-new-units", 
            "text": "Just use the  @unit  macro, providing four arguments: the symbol for the unit, how the unit is displayed, a quantity equivalent to one of the new unit, and a  Bool  to indicate whether or not to make symbols for all SI prefixes (as in mm, km, etc.)  Usage example:  @ unit   pim   \u03c0-meter   \u03c0 * m   false  1 pim   # displays as  1 \u03c0-meter  convert ( m ,   1 pim )   # evaluates to 3.14159... m   You can look at  Defaults.jl  in the package to see what units are there by default.  Note for the experts: Some care should be taken if explicitly making  UnitData  objects. The ordering of  UnitDatum  inside a tuple matters for type comparisons. Using the unary multiplication operator on the  UnitData  object will return a \"canonically sorted\"  UnitData  object. Indeed, this is how we avoid ordering issues when multiplying quantities together.", 
            "title": "Creating new units"
        }, 
        {
            "location": "/implementation/#conversion-and-promotions", 
            "text": "Conversions between units are rejected if the units have different dimensions.  We decide the result units for addition and subtraction operations based on looking at the unit types only. We can't take runtime values into account without compromising runtime performance. By default, if we have  x (A) + y (B) = z (C)  where  x,y,z  are numbers and  A,B,C  are units, then  C = max(1A, 1B) . This is an arbitrary choice and can be changed in  Defaults.jl . For example,  101cm + 1m = 2.01m  because  1m   1cm .  Although quantities could be integrated with Julia's promotion mechanisms, we instead simply define how to add or subtract the units themselves, and have addition of quantities rely on those definitions. The concern is that implicit promotion operations that were written with pure numbers in mind may give rise to surprising behavior without returning errors. The operations on the numeric values of quantities of course utilize Julia's promotion mechanisms.  Some of our  convert  syntax breaks Julia conventions in that the first argument is not a type. For example,  convert(ft, 1m)  converts 1 meter to feet. This may rub people the wrong way and could change. A neat alternative would be to override other syntax:  3m in cm  would be succinct and intuitive. Overriding  in  is simple, but the parsing rules aren't intended for this. For example,  0\u00b0C in \u00b0F == 32\u00b0F  fails to evaluate, but  (0\u00b0C in \u00b0F) == 32\u00b0F  returns  true .  Exact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion will proceed.", 
            "title": "Conversion and promotions"
        }, 
        {
            "location": "/implementation/#temperature-conversion", 
            "text": "If a unit is a pure temperature unit, then conversion respects scale offsets. For instance, converting 0\u00b0C to \u00b0F returns the expected result, 32\u00b0F. If instead temperature appears in combination with other units, scale offsets don't make sense and we consider temperature  intervals . This gives the expected behavior most of the time.", 
            "title": "Temperature conversion"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "License\n\n\nThe Unitful.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/LICENSE/#license", 
            "text": "The Unitful.jl package is licensed under the MIT \"Expat\" License:   Copyright (c) 2016: Andrew Keller.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}